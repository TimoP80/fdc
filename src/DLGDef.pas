(*

Fallout Dialogue Creator - dialogue editor for Fallout 2 mods
Copyright (C) 2005-2025 T. Pitkänen

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

*)


unit DLGDef;

{ DLGDef
  Version: 1.0 Release 0 Build 306
  SSL Dialogue Generator
  Date of Generation: 19.7.2005 18:29
  Author: T. Pitkänen
  (c) 2003 Dj Unique

  This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
  this file that you edit manually will be over-written when the file is
  regenerated.
}

interface

uses
  Classes,
  CocoBase,
  JclStrings,
  mwStringHashList,
  ScriptCompilerIntf,
  SysUtils,
  Variants;

const
  maxT = 77;

type
  SymbolSet = array[0..maxT div setsize] of TBitSet;

  EDLGDef = class(Exception);
  TDLGDef = class;

  TDLGDefScanner = class(TCocoRScanner)
  private
    FOwner:    TDLGDef;
    fHashList: TmwStringHashList;
    procedure CheckLiteral(var Sym: integer);
    function GetNextSymbolString: string;
    function Comment: boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;
    destructor Destroy; override;

    procedure Get(var sym: integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner: TDLGDef Read fOwner Write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TDLGDefScanner }

  TDLGDef = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet: array[0..2] of SymbolSet; // symSet[0] = allSyncSyms

    function GetMajorVersion: integer;
    function GetMinorVersion: integer;
    function GetRelease: integer;
    function GetBuild: integer;
    function GetBuildDate: TDateTime;
    function GetVersionComment: ansistring;
    function GetGrammarAuthor: ansistring;
    function GetGrammarCopyright: ansistring;
    function GetVersion: ansistring;
    procedure SetVersion(const Value: ansistring);
    function _In(var s: SymbolSet; x: integer): boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _StartNodeData;
    procedure _AddProc;
    procedure _CustomCodeBlock;
    procedure _PlayerOpt;
    procedure _Conditions;
    procedure _Data;
    procedure _AddMessage;
    procedure _Stringdata;
    procedure _condsdata;
    procedure _TimedEvent;
    procedure _Nodes;
    procedure _variabledef;
    procedure _SkillChecks;
    procedure _variables;
    procedure _Messages;
    procedure _StartNodes;
    procedure _Output;
    procedure _Dialogue;
    procedure _TimedEvents;
    procedure _LookAtProc;
    procedure _Main;
    procedure _DLGDef;

  private
    fOutputStream:   TMemoryStream;
    fSubSelectDepth: integer;
    fInNaturalJoin:  boolean;

    procedure Init;
    procedure Final;
    procedure WriteStr(S: string);
    property OutputStream: TMemoryStream Read fOutputStream Write fOutputStream;
    property SubSelectDepth: integer Read fSubSelectDepth Write fSubSelectDepth;
    property InNaturalJoin: boolean Read fInNaturalJoin Write fInNaturalJoin;

  protected
    { Protected Declarations }
    procedure Get; override;
  public
    { Public Declarations }
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode: integer; const Data: ansistring): ansistring; override;
    procedure Execute;
    function GetScanner: TDLGDefScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property MajorVersion: integer Read GetMajorVersion;
    property MinorVersion: integer Read GetMinorVersion;
    property Release: integer Read GetRelease;
    property Build: integer Read GetBuild;
    property BuildDate: TDateTime Read GetBuildDate;
    property VersionComment: ansistring Read GetVersionComment;
    property GrammarAuthor: ansistring Read GetGrammarAuthor;
    property GrammarCopyright: ansistring Read GetGrammarCopyright;

  public

  published
    { Published Declarations }
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
    property Version: ansistring Read GetVersion Write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TDLGDef }

var
  debug_nodes:           boolean;
  write_Text_data:       boolean;
  direct_compile:        boolean;
  include_variablenotes: boolean;
  debug_local_vars:      boolean;
  debug_skillchecks:     boolean;
  localvarsdebugstr:     string;
  headerspath:           string;
  template_name:         string;

implementation

uses
  VCL.Dialogs;

const

  EOFSYMB = 0;
  identifierSym = 1;
  integer_Sym = 2;
  _floatSym = 3;
  _stringSym = 4;
  HexLiteralSym = 5;
  MSGOUTPUTNAMESym = 6;
  _equalSym = 7;
  SCROUTPUTNAMESym = 8;
  SCRIPTTEMPLATESym = 9;
  SCRIPTIDSym = 10;
  NPCNAMESym = 11;
  DESCRIPTIONSym = 12;
  LOCATIONSym = 13;
  DESCPROCSym = 14;
  BEGINSym = 15;
  _semicolonSym = 16;
  UNKNOWNSym = 17;
  KNOWNSym = 18;
  DETAILEDSym = 19;
  ENDSym = 20;
  ADDSKILLCHECKSym = 21;
  _lbraceSym = 22;
  FIELDSym = 23;
  MODIFIERSym = 24;
  ONSUCCESSSym = 25;
  _equal_greaterSym = 26;
  ONFAILURESym = 27;
  _rbraceSym = 28;
  IMPORTSym = 29;
  EXPORTSym = 30;
  LOCALSym = 31;
  VARIABLESym = 32;
  _commaSym = 33;
  DIALOGUESym = 34;
  _colonSym = 35;
  TIME_underscoreEVENTSym = 36;
  INTERVALSym = 37;
  _minusSym = 38;
  CODESym = 39;
  TIMED_underscoreEVENTS_underscoreBLOCKS = 40;
  DEFAULT_underscoreEVENTSym = 41;
  _plusSym = 42;
  ADDMSGSym = 43;
  MESSAGESSym = 44;
  _lparenSym = 45;
  _rparenSym = 46;
  _equal_equalSym = 47;
  _bang_equalSym = 48;
  _lessSym = 49;
  _greaterSym = 50;
  _greater_equalSym = 51;
  _less_equalSym = 52;
  ANDSym = 53;
  ORSym  = 54;
  PLAYERSym = 55;
  _lbrackSym = 56;
  INTSym = 57;
  _rbrackSym = 58;
  REACTIONSym = 59;
  BADSym = 60;
  NEUTRALSym = 61;
  GOODSym = 62;
  CONDITIONSym = 63;
  GOTOSym = 64;
  USE_underscoreACTIONSym = 65;
  NOTESSym = 66;
  CUSTOM_underscoreCODESym = 67;
  ADD_underscoreNEW_underscorePROCSym = 68;
  STARTNUMSym = 69;
  NPCSym = 70;
  FEMALESym = 71;
  RANDOMFLOATSSym = 72;
  CASESym = 73;
  ENDCASESym = 74;
  STARTNODESSym = 75;
  DEFAULTNODESym = 76;
  NOSYMB = 77;
  _noSym = NOSYMB;   {error token code}

 { --------------------------------------------------------------------------- }
 { Arbitrary Code from ATG file }
const
  REACTION_NEUTRAL = 1;

const
  REACTION_GOOD = 2;

const
  REACTION_BAD = 3;

const
  PadLen = 20;

// Notes for dialogue data storage:

// All text should be stored as generated SSL Code

// Features done:

 //  *dialogue start node list with conditions or a default node that is called every time
 //  *node descriptions
 //  *automatic message data optimization
 //  *Timed Events
 //  *Skill checks
 //  *Custom procedures
 //  *Custom code in the beginning of a procedure
 //  *

const
  CHECK_TYPE_SKILL = 1;
  CHECK_TYPE_STAT  = 2;


  CHECK_FIELD_STAT_ST = 1;
  CHECK_FIELD_STAT_PE = 2;
  CHECK_FIELD_STAT_EN = 3;
  CHECK_FIELD_STAT_CH = 4;
  CHECK_FIELD_STAT_IN = 5;
  CHECK_FIELD_STAT_AG = 6;
  CHECK_FIELD_STAT_LK = 7;

  CHECK_FIELD_SKILL_SMALLGUNS = 1;
  CHECK_FIELD_SKILL_BIGGUNS = 2;
  CHECK_FIELD_SKILL_ENERGYWEAPONS = 3;
  CHECK_FIELD_SKILL_UNARMED = 4;
  CHECK_FIELD_SKILL_MELEE  = 5;
  CHECK_FIELD_SKILL_THROWING = 6;
  CHECK_FIELD_SKILL_FIRSTAID = 7;
  CHECK_FIELD_SKILL_DOCTOR = 8;
  CHECK_FIELD_SKILL_SNEAK  = 9;
  CHECK_FIELD_SKILL_LOCKPICK = 10;
  CHECK_FIELD_SKILL_STEAL  = 11;
  CHECK_FIELD_SKILL_TRAPS  = 12;
  CHECK_FIELD_SKILL_SCIENCE = 13;
  CHECK_FIELD_SKILL_REPAIR = 14;
  CHECK_FIELD_SKILL_SPEECH = 15;
  CHECK_FIELD_SKILL_BARTER = 16;
  CHECK_FIELD_SKILL_GAMBLING = 17;
  CHECK_FIELD_SKILL_OUTDOORSMAN = 18;


type
  skillcheck = record
    check_proc_name: string;
    check_what: integer;
    modifier: integer;
    successnode: string;
    failurenode: string;
  end;

type
  poption = record
    notes: string;
    conditiondata: string;
    intelligence: integer;
    textdata_string: string;
    textdata: string;
    reaction: integer;
    linknode: string;
  end;

type
  dialoguenode = record
    notes: string;
    Name:  string;
    desc:  string;
    npcdata: string;
    npcdata_female: string;
    npcdata_text: string;
    npcdatafemale_text: string;
    isfloat: boolean;
    replyisrandom: boolean;
    floatmin, floatmax: integer;
    custom_code: string;
    playerdata: array [0..100] of poption;
    playerdatacnt: integer;
  end;

type
  msgdata = record
    markercomment: string;
    belongs_to_node: integer;
    index: integer;
    Data:  string;
  end;

type
  timed_event = record
    define_name:  string;
    define_value: integer;

    interval1: integer;
    interval2: integer;
    code: TStrings;

  end;


type
  timedeventglobal = record
    default_index: integer;
    events: array [0..200] of ^timed_event;
    eventcnt: integer;
  end;

type
  startnode = record
    condition: string;
    gotonode:  string;
  end;


const
  VAR_TYPE_STRING = 0;
  VAR_TYPE_INT = 1;
  VAR_TYPE_FLOAT = 2;

const
  VAR_FLAGS_NONE  = 0;
  VAR_FLAGS_IMPORT = 1;
  VAR_FLAGS_EXPORT = 2;
  VAR_FLAGS_LOCAL = 3;


type
  TVariable = record
    Name:  string;
    varflags: integer;
    vartype: integer;
    Value: variant;
    notes: string;
  end;

type
  custom_code = record
    Name:  string;
    Lines: string;
  end;


var
  vars:  array [0..2000] of ^Tvariable;
  varcnt: integer;
  custom_procedures: array [0..200] of ^custom_code;
  customproccnt: integer;
  stringtable: array [0..65534] of ^msgdata;
  strcnt: integer;
  nodes: array [0..1024] of ^dialoguenode;
  firstcontainer, container, talkproccode: string;
  startnodes: array [0..20] of startnode;
  globaltimedevents: timedeventglobal;
  skillchecks: array [0..1000] of ^skillcheck;
  skillcheckcnt: integer;
  startnodecnt: integer;
  varbase: integer = 8;
  nodecnt: integer;
  markerindex: integer;
  stored_id: integer;
  used_template, msgoutput: string;
  template: TStrings;
  str, script_id: string;
  inlineSSL: string;
  timedevents, codeheader: TStrings;
  actualcode: TStrings;
  insert_var_notes, lastoptimized: boolean;
  npcname, location, npcdesc: string;
  ssloutput: string;
  finalid, currentid: integer;
  header: string;
  skillprocs_string: string;
  vars_string: string;
  timedevents_string: string;
  firsttimeevent: string;
  timedefs_string: string;
  currentnode, currentstring: string;
  currentcondition, currentcode: string;
  Count: integer;
  customprocs_string: string;

function PadR(S: ansistring; Ch: char; L: integer): ansistring;
var
  i: integer;
begin
  for i := 1 to L - (Length(s)) do
    s := s + Ch;
  Result := s;
end;

procedure TDLGDef.Init;
begin
  varcnt  := 0;
  nodecnt := 0;
  strcnt  := 0;
  customproccnt := 0;
  skillcheckcnt := 0;
  globaltimedevents.default_index := -1;
  formatsettings.decimalseparator := '.';
  OutputStream.Clear;
  SubSelectDepth := 0;
end;

function is_float_node(Name: string): boolean;
var
  t: integer;
begin
  Result := False;
  for t := 0 to nodecnt - 1 do
  begin
    if (Name = nodes[t].Name) and (nodes[t].isfloat = True) then
    begin
      Result := True;
      exit;
    end;
  end;
end;

procedure TDLGDef.Final;
var
  t: textfile;
  check_skill: string;
  talkproc_code_header: string;
  talkproc_code_footer: string;
  x, i: integer;
begin

  //  writeln('NodeCount: ',nodecnt);


  // Node verification code goes here

  (*
     if (1) then begin
      start_gdialog(NAME,self_obj,4,-1,-1);
      gSay_Start;
      ##TALKPROCCODE##
      gSay_End;
      end_dialogue;
   end

  *)

  talkproc_code_header := '       start_gdialog(NAME,self_obj,4,-1,-1);' +
    #13#10 + '       gSay_Start;' + #13#10;

  talkproc_code_footer := '       gSay_End;' + #13#10 + '       end_dialogue;' + #13#10;

  talkproccode := '';
  for x := 0 to startnodecnt - 1 do
  begin
    if (startnodes[x].condition = '(default)') then
      startnodes[x].condition := '';

    if (is_float_node(startnodes[x].gotonode)) then
    begin
      if (startnodes[x].condition <> '') then
      begin
        talkproccode := talkproccode + 'if ' + startnodes[x].condition +
          ' then call ' + startnodes[x].gotonode + ';' + #13#10;
      end
      else
      if (startnodes[x].condition = '') then
        talkproccode := talkproccode + 'call ' + startnodes[x].gotonode + ';' + #13#10;
    end
    else
    begin
      ;

      if (startnodes[x].condition <> '') then
      begin
        ;
        talkproccode := talkproccode + 'if ' + startnodes[x].condition +
          ' then begin ' + #13#10 + talkproc_code_header + '       call ' +
          startnodes[x].gotonode + ';' + #13#10 + talkproc_code_footer + 'end ';
      end
      else
      if (startnodes[x].condition = '') then
      begin
        ;
        if (x < startnodecnt - 1) then

          talkproccode := talkproccode + #13#10 + 'begin ' + #13#10 +
            talkproc_code_header + '       call ' + startnodes[x].gotonode +
            ';' + #13#10 + talkproc_code_footer + #13#10 + ' end;'
        else
          talkproccode := talkproccode + #13#10 + talkproc_code_header +
            '       call ' + startnodes[x].gotonode + ';' + #13#10 +
            talkproc_code_footer;
      end;

    end;


    if x < startnodecnt - 1 then
      talkproccode := talkproccode + 'else ';

  end;

  AssignFile(t, msgoutput);
  Rewrite(t);
  writeln(t, '# Message file for ' + extractfilename(ssloutput) + ' ');
  writeln(t, '# Number of nodes: ', nodecnt);
  writeln(t);
  for i := 0 to strcnt - 1 do
  begin
    if stringtable[i].markercomment <> '' then
    begin
      writeln(t);
      writeln(t, '# ', stringtable[i].markercomment);
    end;
    writeln(t, '{', stringtable[i].index, '}{}{', stringtable[i].Data, '}');

  end;
  CloseFile(t);


  AssignFile(t, 'temp_procnames.tmp');
  Rewrite(t);
  for i := 0 to nodecnt - 1 do
  begin
    writeln(t, 'procedure ', nodes[i].Name, ';');
  end;
  Close(t);

  AssignFile(t, 'temp_code.tmp');
  Rewrite(t);
  writeln(t);
  for i := 0 to nodecnt - 1 do
  begin
    if nodes[i].notes <> '' then
    begin
      writeln(t, '// Node ' + nodes[i].Name);
      writeln(t, '//');
      writeln(t, '// Notes:');
      writeln(t, '//');
      writeln(t, '// ', nodes[i].notes);
      writeln(t);
    end;

    writeln(t, 'procedure ', nodes[i].Name);
    writeln(t, 'begin');
    if (debug_nodes = True) then
      writeln(t, 'debug_msg("Current node == ' + nodes[i].Name + '");');

    if nodes[i].custom_code <> '' then
    begin
      writeln(t, nodes[i].custom_code);
    end;

    if nodes[i].isfloat = False then
    begin
      if nodes[i].playerdatacnt > 0 then
      begin
        if (nodes[i].npcdata_female <> '') then
        begin
          if (write_text_data) then
            writeln(t, '// ', StringReplace(nodes[i].npcdata_text,
              #13#10, #13#10 + '//', [rfReplaceAll]));
          writeln(t, 'if (dude_is_male) then Reply(', nodes[i].npcdata, '); else');
          if (write_text_data) then
            writeln(t, '// ', StringReplace(nodes[i].npcdatafemale_text,
              #13#10, #13#10 + '//', [rfReplaceAll]));
          writeln(t, 'if (dude_is_female) then Reply(', nodes[i].npcdata_female, ');');

        end
        else
        begin
          if (write_text_data) then
            writeln(t, '// ', nodes[i].npcdata_text);
          writeln(t, 'Reply(', nodes[i].npcdata, ');');
        end;
        for x := 0 to nodes[i].playerdatacnt - 1 do
        begin
          if nodes[i].playerdata[x].notes <> '' then
          begin
            nodes[i].playerdata[x].notes :=
              StringReplace(nodes[i].playerdata[x].notes, #13#10,
              #13#10 + '//', [rfReplaceAll]);
            writeln(t, '// NOTE: ' + nodes[i].playerdata[x].notes);
          end;

          if (write_text_data) then
            writeln(t, '// ', nodes[i].playerdata[x].textdata_string);
          if nodes[i].playerdata[x].conditiondata <> '' then
            writeln(t, 'if ' + nodes[i].playerdata[x].conditiondata + ' then ');
          case nodes[i].playerdata[x].reaction of
            REACTION_GOOD:
              writeln(t, 'GOption(', nodes[i].playerdata[x].textdata,
                ',', nodes[i].playerdata[x].linknode, ',',
                nodes[i].playerdata[x].intelligence, ');');
            REACTION_NEUTRAL:
              writeln(t, 'NOption(', nodes[i].playerdata[x].textdata,
                ',', nodes[i].playerdata[x].linknode, ',',
                nodes[i].playerdata[x].intelligence, ');');
            REACTION_BAD:
              writeln(t, 'BOption(', nodes[i].playerdata[x].textdata,
                ',', nodes[i].playerdata[x].linknode, ',',
                nodes[i].playerdata[x].intelligence, ');');
          end;
        end;
      end
      else
      begin
        if (nodes[i].npcdata_female <> '') then
        begin
          if (write_text_data) then
            writeln(t, '// Male NPC      : ', nodes[i].npcdata_text);
          if (write_text_data) then
            writeln(t, '// Female NPC    : ', nodes[i].npcdatafemale_text);
          writeln(t, 'if (dude_is_male) then NMessage(', nodes[i].npcdata, '); else');
          writeln(t, 'if (dude_is_female) then NMessage(',
            nodes[i].npcdata_female, ');');
          writeln(t, 'set_local_var(LVAR_Herebefore,1);');

        end
        else
        begin
          if (write_text_data) then
            writeln(t, '// ', nodes[i].npcdata_text);
          writeln(t, 'NMessage(', nodes[i].npcdata, ');');
          writeln(t, 'set_local_var(LVAR_Herebefore,1);');
        end;

      end;

    end
    else
    if nodes[i].isfloat = True then
    begin
      writeln(t, 'floater_rand(', nodes[i].floatmin, ',', nodes[i].floatmax, ');');
    end;

    writeln(t, 'end');
    writeln(t);
  end;

  Close(t);

  Template := TStringList.Create;
  template.loadfromfile(used_template);
  codeheader := TStringList.Create;
  actualcode := TStringList.Create;
  codeheader.loadfromfile('temp_procnames.tmp');
  actualcode.loadfromfile('temp_code.tmp');
  if varcnt > 0 then
  begin
    ;
    vars_string := '';

    for I := 0 to varcnt - 1 do
    begin
      if (vars[i].notes <> '') and (include_variablenotes = True) then
        vars_string := vars_string + '// ' + wraptext(vars[i].notes,
          #13#10 + '// ', [#9, ' ', ',', '_', '.'], 70) + #13#10;
      if (vars[i].varflags = VAR_FLAGS_LOCAL) then
      begin
        vars_string := vars_string + '#define LVAR_' + vars[i].Name +
          ' (' + IntToStr(varbase + i) + ')' + #13#10;
      end
      else
      begin
        if vars[i].varflags = VAR_FLAGS_IMPORT then
          vars_String := vars_string + 'import variable ' + vars[i].Name
        else
        if vars[i].varflags = VAR_FLAGS_EXPORT then
          vars_String := vars_string + 'export variable ' + vars[i].Name
        else
          vars_String := vars_string + 'variable ' + vars[i].Name;
        if vars[i].vartype <> -1 then
        begin
          ;
          vars_String := vars_string + ' := ';
          case vars[i].vartype of
            VAR_TYPE_INT:
              vars_string := vars_string + IntToStr(vars[i].Value);
            VAR_TYPE_STRING:
              vars_string := vars_string + '"' + vars[i].Value + '"';
            VAR_TYPE_FLOAT:
              vars_string := vars_string + floattostr(vars[i].Value);
          end;
        end;
        vars_string := vars_string + ';' + #13#10;
      end;
      if (vars[i].notes <> '') and (include_variablenotes = True) then
        vars_string := vars_string + #13#10;
    end;

  end;

  skillprocs_string := '';

  for i := 0 to skillcheckcnt - 1 do
  begin
    skillprocs_string := skillprocs_string + 'procedure ' +
      skillchecks[i].check_proc_name + ';' + #13#10;
  end;

  template.Text := StringReplace(template.Text, '##VARIABLES##', vars_string, []);


  template.Text := StringReplace(template.Text, '##SKILLCHECKHEADERS##',
    skillprocs_string, []);
  customprocs_string := '';

  for i := 0 to customproccnt - 1 do
  begin
    customprocs_string := customprocs_string + 'procedure ' +
      custom_procedures[i].Name + ';' + #13#10;
  end;

  template.Text := StringReplace(template.Text, '##CUSTOMPROCHEADERS##',
    customprocs_string, []);

  customprocs_string := '';

  for i := 0 to customproccnt - 1 do
  begin
    customprocs_string := customprocs_string + 'procedure ' +
      custom_procedures[i].Name + ' begin' + #13#10 + custom_procedures[i].Lines +
      #13#10 + 'end' + #13#10 + #13#10;
  end;

  template.Text := StringReplace(template.Text, '##CUSTOMPROCS##',
    customprocs_string, []);

  skillprocs_string := '';
  for i := 0 to skillcheckcnt - 1 do
  begin
    ;
    skillprocs_string := skillprocs_String + format('procedure %s begin' +
      #13#10, [skillchecks[i].check_proc_name]);
    case skillchecks[i].check_what of
      CHECK_FIELD_SKILL_SMALLGUNS:
        check_skill := 'SKILL_SMALL_GUNS';
      CHECK_FIELD_SKILL_BIGGUNS:
        check_skill := 'SKILL_BIG_GUNS';
      CHECK_FIELD_SKILL_ENERGYWEAPONS:
        check_skill := 'SKILL_ENERGY_WEAPONS';
      CHECK_FIELD_SKILL_UNARMED:
        check_skill := 'SKILL_UNARMED_COMBAT';
      CHECK_FIELD_SKILL_MELEE:
        check_skill := 'SKILL_MELEE';
      CHECK_FIELD_SKILL_THROWING:
        check_skill := 'SKILL_THROWING';
      CHECK_FIELD_SKILL_FIRSTAID:
        check_skill := 'SKILL_FIRST_AID';
      CHECK_FIELD_SKILL_DOCTOR:
        check_skill := 'SKILL_DOCTOR';
      CHECK_FIELD_SKILL_SNEAK:
        check_skill := 'SKILL_SNEAK';
      CHECK_FIELD_SKILL_LOCKPICK:
        check_skill := 'SKILL_LOCKPICK';
      CHECK_FIELD_SKILL_STEAL:
        check_skill := 'SKILL_STEAL';
      CHECK_FIELD_SKILL_TRAPS:
        check_skill := 'SKILL_TRAPS';
      CHECK_FIELD_SKILL_SCIENCE:
        check_skill := 'SKILL_SCIENCE';
      CHECK_FIELD_SKILL_REPAIR:
        check_skill := 'SKILL_REPAIR';
      CHECK_FIELD_SKILL_SPEECH:
        check_skill := 'SKILL_CONVERSANT';
      CHECK_FIELD_SKILL_BARTER:
        check_skill := 'SKILL_BARTER';
      CHECK_FIELD_SKILL_GAMBLING:
        check_skill := 'SKILL_GAMBLING';
      CHECK_FIELD_SKILL_OUTDOORSMAN:
        check_skill := 'SKILL_OUTDOORSMAN';
      18 + CHECK_FIELD_STAT_ST:
        check_skill := 'STAT_st';
      18 + CHECK_FIELD_STAT_PE:
        check_skill := 'STAT_pe';
      18 + CHECK_FIELD_STAT_EN:
        check_skill := 'STAT_en';
      18 + CHECK_FIELD_STAT_CH:
        check_skill := 'STAT_ch';
      18 + CHECK_FIELD_STAT_IN:
        check_skill := 'STAT_iq';
      18 + CHECK_FIELD_STAT_AG:
        check_skill := 'STAT_ag';
      18 + CHECK_FIELD_STAT_LK:
        check_skill := 'STAT_lu';

    end;
    if debug_skillchecks = True then
    begin
      skillprocs_string := skillprocs_string + 'variable roll_temp;' +
        #13#10 + 'debug_msg("Skill_Check: ' + check_skill + '\n");';

      if pos('STAT', check_skill) <> 0 then
        skillprocs_string := skillprocs_string + #13#10 +
          format('roll_temp := do_check(dude_obj, %s, %d);',
          [check_skill, skillchecks[i].modifier]) + #13#10
      else

        skillprocs_string := skillprocs_string + #13#10 +
          format('roll_temp := roll_vs_skill(dude_obj, %s, %d);',
          [check_skill, skillchecks[i].modifier]) + #13#10;
      skillprocs_string := skillprocs_string +
        'debug_msg("rolled "+roll_temp+" at the skill check.\n");';
      skillprocs_string := skillprocs_string + 'if is_success(roll_temp) then' + #13#10;
      skillprocs_string := skillprocs_string + 'begin' + #13#10 +
        'debug_msg("skill check node "+"' + skillchecks[i].check_proc_name +
        '"+" succeeded check. success_value="+how_much('+check_skill+'));' + #13#10 + 'call ' + skillchecks[i].successnode +
        ';'#13#10 + 'end ' + #13#10 + 'else begin ' + #13#10 +
        ' debug_msg("skill check node "+"' + skillchecks[i].check_proc_name +
        '"+" failed check.  failure_value="+how_much('+check_skill+'); ' + #13#10 + 'call ' + skillchecks[i].failurenode +
        ';' + #13#10 + ' end ' + #13#10;
      skillprocs_string := skillprocs_string + 'end' + #13#10 + #13#10;
    end
    else
    begin
      skillprocs_string := skillprocs_string + 'variable roll_temp;';

      if pos('STAT', check_skill) <> 0 then
        skillprocs_string := skillprocs_string + #13#10 +
          format('roll_temp := do_check(dude_obj, %s, %d);',
          [check_skill, skillchecks[i].modifier]) + #13#10
      else

        skillprocs_string := skillprocs_string + #13#10 +
          format('roll_temp := roll_vs_skill(dude_obj, %s, %d);',
          [check_skill, skillchecks[i].modifier]) + #13#10;

      skillprocs_string := skillprocs_string + 'if is_success(roll_temp) then' + #13#10;
      skillprocs_string := skillprocs_string + 'begin' + #13#10 +
        'call ' + skillchecks[i].successnode + ';'#13#10 + 'end ' +
        #13#10 + 'else begin ' + #13#10 + 'call ' + skillchecks[i].failurenode +
        ';' + #13#10 + ' end ' + #13#10;
      skillprocs_string := skillprocs_string + 'end' + #13#10 + #13#10;

    end;

  end;

  localvarsdebugstr := '';
  if debug_local_vars = True then
  begin
    ;
    for i := 0 to varcnt - 1 do
    begin
      ;
      if vars[i].varflags = VAR_FLAGS_LOCAL then
        localvarsdebugstr := localvarsdebugstr + 'debug_msg("local var "+"' +
          vars[i].Name + '"+" == "+local_var(LVAR_' + vars[i].Name + '));' + #13#10;
    end;
  end;

  template.Text := StringReplace(template.Text, '##LOCALVARDEBUG##',
    localvarsdebugstr, [rfReplaceAll]);
  template.Text := StringReplace(template.Text, '##SKILLCHECKPROCS##',
    skillprocs_string, [rfReplaceAll]);
  template.Text := StringReplace(template.Text, '##NODEHEADERS##', codeheader.Text, []);
  template.Text := StringReplace(template.Text, '##NODEPROCS##', actualcode.Text, []);
  template.Text := StringReplace(template.Text, '##SCRNUM##', script_id, [rfReplaceAll]);
  template.Text := StringReplace(template.Text, '##TALKPROCCODE##', talkproccode, []);
  template.Text := StringReplace(template.Text, '##NAME##', npcname, []);
  template.Text := StringReplace(template.Text, '##HEADERS_PATH##',
    headerspath, [rfReplaceALl]);
  template.Text := StringReplace(template.Text, '##LOCATION##', location, []);
  template.Text := StringReplace(template.Text, '##DESCRIPTION##', npcdesc, []);
  template.Text := StringReplace(template.Text, '##CREATIONDATE##',
    datetimetostr(now), []);

  timedefs_string := '';
  for i := 0 to globaltimedevents.eventcnt - 1 do
  begin
    ;
    timedefs_string := timedefs_string + format('#define %s (%d)' +
      #13#10, [globaltimedevents.events[i].define_name,
      globaltimedevents.events[i].define_value]);
  end;

  template.Text := StringReplace(template.Text, '##TIMED_EVENT_DEFINES##',
    timedefs_string, []);

  timedefs_string := '';
  if (globaltimedevents.default_index <> -1) then
  begin
    ;
    if (globaltimedevents.events[globaltimedevents.default_index].interval2 <> -1) then
      timedefs_string := format(
        'flush_add_timer_event_sec(self_obj,random(%d, %d), %s);',
        [globaltimedevents.events[globaltimedevents.default_index].interval1,
        globaltimedevents.events[globaltimedevents.default_index].interval2,
        globaltimedevents.events[globaltimedevents.default_index].define_name])
    else
      timedefs_string := format('flush_add_timer_event_sec(self_obj,%d, %s);',
        [globaltimedevents.events[globaltimedevents.default_index].interval1,
        globaltimedevents.events[globaltimedevents.default_index].define_name]);
  end;

  template.Text := StringReplace(template.Text, '##FIRST_TIMED_EVENT##',
    timedefs_string, []);
  timedevents := TStringList.Create;
  for i := 0 to globaltimedevents.eventcnt - 1 do
  begin
    ;
    timedevents.add(format('if (fixed_param == %s) then',
      [globaltimedevents.events[i].define_name]));
    timedevents.add('          begin');
    timedevents.AddStrings(globaltimedevents.events[i].code);
    if i < globaltimedevents.eventcnt - 1 then
      timedevents.add('          end else')
    else

      timedevents.add('end');

  end;

  template.Text := StringReplace(template.Text, '##TIMED_EVENT_CODE##',
    timedevents.Text, []);

 // template.savetofile(script_output + '\' + extractfilename(
 //   changefileext(ssloutput, '.ssl')));
  template.SaveToFile(ssloutput);
  timedevents.Free;
  codeheader.Free;
  actualcode.Free;

  //writeln('ssloutput: ' + ssloutput + ', compiling...');

{$IFNDEF BUILD_ScriptExporter}
{$MESSAGE 'DDFC build.'}
  if direct_compile = True then
  begin
    ;
    if DoCompile(script_output + '\' + extractfilename(
      changefileext(ssloutput, '.ssl'))) then
    begin

        {$IFDEF CONSOLE}
       writeln('Output file: ' + script_output + '\' + extractfilename(changefileext(ssloutput, '.int')));
       {$ELSE}
      MessageDlg('Script successfully compiled. Output file: ' +
        script_output + '\' + extractfilename(changefileext(ssloutput, '.int')),
        mtInformation, [mbOK], 0);
       {$ENDIF}

      if fileexists(script_output + '\' + extractfilename(
        changefileext(ssloutput, '.int'))) then
      begin
        ;
       {$IFDEF CONSOLE}
       writeln('File exists, compile successful.');
       {$ENDIF}
      end
      else
      begin
        ;
       {$IFDEF CONSOLE}
       writeln
       {$ELSE}
        ShowMessage
       {$ENDIF}
        ('File does not exist. Compile was potentially unsuccessful.');
      end;

    end;
  end;

{$ELSE}
{$MESSAGE 'ScriptExporter build.'}
{$ENDIF}
  deletefile('temp_procnames.tmp');
  deletefile('temp_code.tmp');
  OutputStream.Position := 0;
  OutputStream.SaveToStream(ListStream);
  OutputStream.Clear;
end;


procedure TDLGDef.WriteStr(S: string);
begin
  S := S + #13#10;
  OutputStream.WriteBuffer(S[1], length(S));
end;

function stringtoskill(skillstr: string): integer;
begin
  ;
  Result := 0;

  if skillstr = 'CHECK_FIELD_SKILL_SMALLGUNS' then
    Result := CHECK_FIELD_SKILL_SMALLGUNS
  else
  if skillstr = 'CHECK_FIELD_SKILL_BIGGUNS' then
    Result := CHECK_FIELD_SKILL_BIGGUNS
  else
  if skillstr = 'CHECK_FIELD_SKILL_ENERGYWEAPONS' then
    Result := CHECK_FIELD_SKILL_ENERGYWEAPONS
  else
  if skillstr = 'CHECK_FIELD_SKILL_UNARMED' then
    Result := CHECK_FIELD_SKILL_UNARMED
  else
  if skillstr = 'CHECK_FIELD_SKILL_MELEE' then
    Result := CHECK_FIELD_SKILL_MELEE
  else
  if skillstr = 'CHECK_FIELD_SKILL_THROWING' then
    Result := CHECK_FIELD_SKILL_THROWING
  else
  if skillstr = 'CHECK_FIELD_SKILL_FIRSTAID' then
    Result := CHECK_FIELD_SKILL_FIRSTAID
  else
  if skillstr = 'CHECK_FIELD_SKILL_DOCTOR' then
    Result := CHECK_FIELD_SKILL_DOCTOR
  else
  if skillstr = 'CHECK_FIELD_SKILL_SNEAK' then
    Result := CHECK_FIELD_SKILL_SNEAK
  else
  if skillstr = 'CHECK_FIELD_SKILL_LOCKPICK' then
    Result := CHECK_FIELD_SKILL_LOCKPICK
  else
  if skillstr = 'CHECK_FIELD_SKILL_STEAL' then
    Result := CHECK_FIELD_SKILL_STEAL
  else
  if skillstr = 'CHECK_FIELD_SKILL_TRAPS' then
    Result := CHECK_FIELD_SKILL_TRAPS
  else
  if skillstr = 'CHECK_FIELD_SKILL_REPAIR' then
    Result := CHECK_FIELD_SKILL_REPAIR
  else
  if skillstr = 'CHECK_FIELD_SKILL_SPEECH' then
    Result := CHECK_FIELD_SKILL_SPEECH
  else
  if skillstr = 'CHECK_FIELD_SKILL_BARTER' then
    Result := CHECK_FIELD_SKILL_BARTER
  else
  if skillstr = 'CHECK_FIELD_SKILL_GAMBLING' then
    Result := CHECK_FIELD_SKILL_GAMBLING
  else
  if skillstr = 'CHECK_FIELD_SKILL_OUTDOORSMAN' then
    Result := CHECK_FIELD_SKILL_OUTDOORSMAN
  else
  if skillstr = 'CHECK_FIELD_STAT_STRENGTH' then
    Result := 18 + CHECK_FIELD_STAT_ST
  else
  if skillstr = 'CHECK_FIELD_STAT_PERCEPTION' then
    Result := 18 + CHECK_FIELD_STAT_PE
  else
  if skillstr = 'CHECK_FIELD_STAT_ENDURANCE' then
    Result := 18 + CHECK_FIELD_STAT_EN
  else
  if skillstr = 'CHECK_FIELD_STAT_CHARISMA' then
    Result := 18 + CHECK_FIELD_STAT_CH
  else
  if skillstr = 'CHECK_FIELD_STAT_INTELLIGENCE' then
    Result := 18 + CHECK_FIELD_STAT_IN
  else
  if skillstr = 'CHECK_FIELD_STAT_AGILITY' then
    Result := 18 + CHECK_FIELD_STAT_AG
  else if skillstr = 'CHECK_FIELD_STAT_LUCK' then
    Result := 18 + CHECK_FIELD_STAT_LK;

end;

function parse_string(zstr: ansistring): ansistring;
var
  t: integer;
var
  temp: ansistring;
var
  len: integer;
begin
  ;
  len := 0;
  //writeln ('Parsing string: ',zstr);
  t := pos('"', zstr) + 1;
  len := length(zstr);
  while (zstr[t] <> '"') do
  begin
    ;
    //writeln (zstr[t]);
    if (zstr[t] = '\') and (zstr[t + 1] = '"') then
    begin
      ;
      temp := temp + '"';
      Inc(t, 1);
    end
    else
    if (zstr[t] = '\') and (zstr[t + 1] = '\') then
    begin
      ;
      temp := temp + '\';
      Inc(t, 1);
    end
    else
    if (zstr[t] = '\') and (zstr[t + 1] = 'n') then
    begin
      ;
      temp := temp + #13#10;
      Inc(t, 1);
    end
    else

      temp := temp + zstr[t];

    Inc(t);
  end;
  Result := temp;
end;


function msgdataexists(str: string): boolean;
var
  x: integer;
begin
  ;
  Result := False;
  for x := 0 to strcnt - 1 do
  begin
    ;
    if stringtable[x].Data = str then
    begin
      ;
      Result := True;
      exit;
    end;

  end;

end;

function getmsgdataID(str: string): integer;
var
  x: integer;
begin
  ;
  Result := 0;
  for x := 0 to strcnt - 1 do
  begin
    ;
    if stringtable[x].Data = str then
    begin
      ;
      Result := stringtable[x].index;
      exit;
    end;

  end;

end;

function addMSGData(id: integer; Data: string; var lastmsg: string;
  var lastwasoptimized: boolean): integer;
var
  X: integer;
begin
  ;
  if msgdataexists(Data) = False then
  begin
    ;
    lastmsg := lastmsg + ' [' + IntToStr(id) + '] "' + Data + '"';
    lastwasoptimized := False;
    New(stringtable[strcnt]);
    stringtable[strcnt].index := id;
    stringtable[strcnt].Data  := Data;
    Inc(strcnt);
    Result := id;
  end
  else
  begin
    ;
    //writeln ('MSGData: {',data,'} already exists. Optimized to ID: ',getmsgdataid(data));
    lastwasoptimized := True;
    Result  := getmsgdataid(Data);
    lastmsg := lastmsg + ' [' + IntToStr(Result) + '] "' + Data + '"';
  end;

end;

function getlastmsgid: integer;
begin
  ;
  Result := stringtable[strcnt - 1].index;
end;


(* End of Arbitrary Code *)



 { --------------------------------------------------------------------------- }
 { ---- implementation for TDLGDefScanner ---- }

procedure TDLGDefScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  SrcStream.Seek(BufferPosition, soFromBeginning);
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) or ((CurrInputCh = _LF) and (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    //if Assigned(OnStatusUpdate) then
    //  OnStatusUpdate(Owner, IntToStr(CurrLine), CurrLine);
    StartOfLine := BufferPosition;
  end;
end;  {NextCh}

function TDLGDefScanner.Comment: boolean;
var
  level: integer;
  startLine: integer;
  oldLineStart: longint;
  CommentStr: string;
begin
  level  := 1;
  startLine := CurrLine;
  oldLineStart := StartOfLine;
  CommentStr := CharAt(BufferPosition);
  Result := False;
  if (CurrInputCh = '/') then
  begin
    NextCh;
    CommentStr := CommentStr + CharAt(BufferPosition);
    if (CurrInputCh = '/') then
    begin
      NextCh;
      CommentStr := CommentStr + CharAt(BufferPosition);
      while True do
      begin
        if (CurrInputCh = CHR(13)) then
        begin
          level := level - 1;
          NumEOLInComment := CurrLine - startLine;
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
          if level = 0 then
          begin
            Result := True;
            Exit;
          end;
        end
        else if CurrInputCh = _EF then
        begin
          Result := False;
          Exit;
        end
        else
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
        end;
      end; { WHILE TRUE }
    end
    else
    begin
      if (CurrInputCh = _CR) or (CurrInputCh = _LF) then
      begin
        CurrLine := CurrLine - 1;
        StartOfLine := oldLineStart;
      end;
      BufferPosition := BufferPosition - 1;
      CurrInputCh := LastInputCh;
      Result := False;
    end;
  end;
  Result := False;
  if (CurrInputCh = '/') then
  begin
    NextCh;
    CommentStr := CommentStr + CharAt(BufferPosition);
    if (CurrInputCh = '*') then
    begin
      NextCh;
      CommentStr := CommentStr + CharAt(BufferPosition);
      while True do
      begin
        if (CurrInputCh = '*') then
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
          if (CurrInputCh = '/') then
          begin
            level := level - 1;
            NextCh;
            CommentStr := CommentStr + CharAt(BufferPosition);
            if level = 0 then
            begin
              Result := True;
              Exit;
            end;
          end;
        end
        else if CurrInputCh = _EF then
        begin
          Result := False;
          Exit;
        end
        else
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
        end;
      end; { WHILE TRUE }
    end
    else
    begin
      if (CurrInputCh = _CR) or (CurrInputCh = _LF) then
      begin
        CurrLine := CurrLine - 1;
        StartOfLine := oldLineStart;
      end;
      BufferPosition := BufferPosition - 1;
      CurrInputCh := LastInputCh;
      Result := False;
    end;
  end;
end;  { Comment }

function TDLGDefScanner.GetNextSymbolString: string;
var
  i: integer;
  q: integer;
begin
  Result := '';
  i := 1;
  q := bpCurrToken;
  while i <= NextSymbol.Len do
  begin
    Result := Result + CurrentCh(q);
    Inc(q);
    Inc(i);
  end;
end; {GetNextSymbolString}

procedure TDLGDefScanner.CheckLiteral(var Sym: integer);
var
  SymId:  integer;
  DefaultSymId: integer;
  aToken: string;
begin
  aToken := GetNextSymbolString;
  if fHashList.Hash(aToken, SymId, DefaultSymId) then
  begin
    sym := SymId;
  end;
end; {CheckLiteral}


procedure TDLGDefScanner.Get(var sym: integer);
var
  state: integer;
begin   {Get}
  while (CurrInputCh = ' ') or ((CurrInputCh >= CHR(1)) and (CurrInputCh <= ' ')) do
    NextCh;
  if ((CurrInputCh = '/') or (CurrInputCh = '/')) and Comment then
  begin
    Get(sym);
    exit;
  end;
  CurrentSymbol.pos := NextSymbol.Pos;
  NextSymbol.Pos := BufferPosition;
  CurrentSymbol.col := NextSymbol.Col;
  NextSymbol.Col := BufferPosition - StartOfLine;
  CurrentSymbol.line := NextSymbol.Line;
  NextSymbol.Line := CurrLine;
  CurrentSymbol.Len := NextSymbol.Len;
  NextSymbol.Len := 0;
  ContextLen := 0;
  state := StartState[Ord(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while True do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit;
    end;
    case state of
      1:
        if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or
          (CurrInputCh >= 'A') and (CurrInputCh <= 'Z') or (CurrInputCh = '_') or
          (CurrInputCh >= CHR(196)) and (CurrInputCh <= CHR(197)) or
          (CurrInputCh = CHR(214)) or (CurrInputCh >= CHR(228)) and
          (CurrInputCh <= CHR(229)) or (CurrInputCh = CHR(246))) then
        begin

        end
        else
        begin
          sym := identifierSym;
          CheckLiteral(sym);
          exit;
        end;
      2:
        if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 3;
        end
        else
        begin
          sym := _plusSym;
          exit;
        end;
      3:
        if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else
        begin
          sym := integer_Sym;
          exit;
        end;
      4:
        if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 5;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      5:
        if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else if (CurrInputCh = 'F') then
        begin
          state := 6;
        end
        else
        begin
          sym := _floatSym;
          exit;
        end;
      6:
      begin
        sym := _floatSym;
        exit;
      end;
      7:
        if ((CurrInputCh <= CHR(12)) or (CurrInputCh >= CHR(14)) and
          (CurrInputCh <= '!') or (CurrInputCh >= '#') and (CurrInputCh <= '[') or
          (CurrInputCh >= ']')) then
        begin

        end
        else if (CurrInputCh = '"') then
        begin
          state := 8;
        end
        else if (CurrInputCh = '\') then
        begin
          state := 12;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      8:
      begin
        sym := _stringSym;
        exit;
      end;
      9:
        if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or
          (CurrInputCh >= 'A') and (CurrInputCh <= 'Z') or (CurrInputCh = '_') or
          (CurrInputCh >= CHR(196)) and (CurrInputCh <= CHR(197)) or
          (CurrInputCh = CHR(214)) or (CurrInputCh >= CHR(228)) and
          (CurrInputCh <= CHR(229)) or (CurrInputCh = CHR(246))) then
        begin

        end
        else
        begin
          sym := HexLiteralSym;
          exit;
        end;
      10:
        if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else if (CurrInputCh = '.') then
        begin
          state := 4;
        end
        else
        begin
          sym := integer_Sym;
          exit;
        end;
      11:
        if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 10;
        end
        else
        begin
          sym := _minusSym;
          exit;
        end;
      12:
        if ((CurrInputCh <= CHR(12)) or (CurrInputCh >= CHR(14)) and
          (CurrInputCh <= '!') or (CurrInputCh >= '#') and (CurrInputCh <= '[') or
          (CurrInputCh >= ']')) then
        begin
          state := 7;
        end
        else if (CurrInputCh = '"') then
        begin
          state := 13;
        end
        else if (CurrInputCh = '\') then
        begin

        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      13:
        if ((CurrInputCh <= CHR(12)) or (CurrInputCh >= CHR(14)) and
          (CurrInputCh <= '!') or (CurrInputCh >= '#') and (CurrInputCh <= '[') or
          (CurrInputCh >= ']')) then
        begin
          state := 7;
        end
        else if (CurrInputCh = '"') then
        begin
          state := 8;
        end
        else if (CurrInputCh = '\') then
        begin
          state := 12;
        end
        else
        begin
          sym := _stringSym;
          exit;
        end;
      14:
        if (CurrInputCh = '>') then
        begin
          state := 17;
        end
        else if (CurrInputCh = '=') then
        begin
          state := 23;
        end
        else
        begin
          sym := _equalSym;
          exit;
        end;
      15:
      begin
        sym := _semicolonSym;
        exit;
      end;
      16:
      begin
        sym := _lbraceSym;
        exit;
      end;
      17:
      begin
        sym := _equal_greaterSym;
        exit;
      end;
      18:
      begin
        sym := _rbraceSym;
        exit;
      end;
      19:
      begin
        sym := _commaSym;
        exit;
      end;
      20:
      begin
        sym := _colonSym;
        exit;
      end;
      21:
      begin
        sym := _lparenSym;
        exit;
      end;
      22:
      begin
        sym := _rparenSym;
        exit;
      end;
      23:
      begin
        sym := _equal_equalSym;
        exit;
      end;
      24:
        if (CurrInputCh = '=') then
        begin
          state := 25;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      25:
      begin
        sym := _bang_equalSym;
        exit;
      end;
      26:
        if (CurrInputCh = '=') then
        begin
          state := 29;
        end
        else
        begin
          sym := _lessSym;
          exit;
        end;
      27:
        if (CurrInputCh = '=') then
        begin
          state := 28;
        end
        else
        begin
          sym := _greaterSym;
          exit;
        end;
      28:
      begin
        sym := _greater_equalSym;
        exit;
      end;
      29:
      begin
        sym := _less_equalSym;
        exit;
      end;
      30:
      begin
        sym := _lbrackSym;
        exit;
      end;
      31:
      begin
        sym := _rbrackSym;
        exit;
      end;
      32:
      begin
        sym := EOFSYMB;
        CurrInputCh := #0;
        BufferPosition := BufferPosition - 1;
        exit;
      end;
      else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TDLGDefScanner.Create;
begin
  inherited;
  fHashList := TmwStringHashList.Create(ITinyHash, HashSecondaryOne, IHashCompare);
  fHashList.AddString('ADDMSG', ADDMSGSym, ADDMSGSym);
  fHashList.AddString('ADDSKILLCHECK', ADDSKILLCHECKSym, ADDSKILLCHECKSym);
  fHashList.AddString('ADD_NEW_PROC', ADD_underscoreNEW_underscorePROCSym,
    ADD_underscoreNEW_underscorePROCSym);
  fHashList.AddString('AND', ANDSym, ANDSym);
  fHashList.AddString('BAD', BADSym, BADSym);
  fHashList.AddString('BEGIN', BEGINSym, BEGINSym);
  fHashList.AddString('CASE', CASESym, CASESym);
  fHashList.AddString('CODE', CODESym, CODESym);
  fHashList.AddString('CONDITION', CONDITIONSym, CONDITIONSym);
  fHashList.AddString('CUSTOM_CODE', CUSTOM_underscoreCODESym, CUSTOM_underscoreCODESym);
  fHashList.AddString('DEFAULTNODE', DEFAULTNODESym, DEFAULTNODESym);
  fHashList.AddString('DEFAULT_EVENT', DEFAULT_underscoreEVENTSym,
    DEFAULT_underscoreEVENTSym);
  fHashList.AddString('DESCPROC', DESCPROCSym, DESCPROCSym);
  fHashList.AddString('DESCRIPTION', DESCRIPTIONSym, DESCRIPTIONSym);
  fHashList.AddString('DETAILED', DETAILEDSym, DETAILEDSym);
  fHashList.AddString('DIALOGUE', DIALOGUESym, DIALOGUESym);
  fHashList.AddString('END', ENDSym, ENDSym);
  fHashList.AddString('ENDCASE', ENDCASESym, ENDCASESym);
  fHashList.AddString('EXPORT', EXPORTSym, EXPORTSym);
  fHashList.AddString('FEMALE', FEMALESym, FEMALESym);
  fHashList.AddString('FIELD', FIELDSym, FIELDSym);
  fHashList.AddString('GOOD', GOODSym, GOODSym);
  fHashList.AddString('GOTO', GOTOSym, GOTOSym);
  fHashList.AddString('IMPORT', IMPORTSym, IMPORTSym);
  fHashList.AddString('INT', INTSym, INTSym);
  fHashList.AddString('INTERVAL', INTERVALSym, INTERVALSym);
  fHashList.AddString('KNOWN', KNOWNSym, KNOWNSym);
  fHashList.AddString('LOCAL', LOCALSym, LOCALSym);
  fHashList.AddString('LOCATION', LOCATIONSym, LOCATIONSym);
  fHashList.AddString('MESSAGES', MESSAGESSym, MESSAGESSym);
  fHashList.AddString('MODIFIER', MODIFIERSym, MODIFIERSym);
  fHashList.AddString('MSGOUTPUTNAME', MSGOUTPUTNAMESym, MSGOUTPUTNAMESym);
  fHashList.AddString('NEUTRAL', NEUTRALSym, NEUTRALSym);
  fHashList.AddString('NOTES', NOTESSym, NOTESSym);
  fHashList.AddString('NPC', NPCSym, NPCSym);
  fHashList.AddString('NPCNAME', NPCNAMESym, NPCNAMESym);
  fHashList.AddString('ONFAILURE', ONFAILURESym, ONFAILURESym);
  fHashList.AddString('ONSUCCESS', ONSUCCESSSym, ONSUCCESSSym);
  fHashList.AddString('OR', ORSym, ORSym);
  fHashList.AddString('PLAYER', PLAYERSym, PLAYERSym);
  fHashList.AddString('RANDOMFLOATS', RANDOMFLOATSSym, RANDOMFLOATSSym);
  fHashList.AddString('REACTION', REACTIONSym, REACTIONSym);
  fHashList.AddString('SCRIPTID', SCRIPTIDSym, SCRIPTIDSym);
  fHashList.AddString('SCRIPTTEMPLATE', SCRIPTTEMPLATESym, SCRIPTTEMPLATESym);
  fHashList.AddString('SCROUTPUTNAME', SCROUTPUTNAMESym, SCROUTPUTNAMESym);
  fHashList.AddString('STARTNODES', STARTNODESSym, STARTNODESSym);
  fHashList.AddString('STARTNUM', STARTNUMSym, STARTNUMSym);
  fHashList.AddString('TIMED_EVENTS_BLOCK', TIMED_underscoreEVENTS_underscoreBLOCKS,
    TIMED_underscoreEVENTS_underscoreBLOCKS);
  fHashList.AddString('TIME_EVENT', TIME_underscoreEVENTSym, TIME_underscoreEVENTSym);
  fHashList.AddString('UNKNOWN', UNKNOWNSym, UNKNOWNSym);
  fHashList.AddString('USE_ACTION', USE_underscoreACTIONSym, USE_underscoreACTIONSym);
  fHashList.AddString('VARIABLE', VARIABLESym, VARIABLESym);
  CurrentCh := CapChAt;
  fStartState[0] := 32;
  fStartState[1] := 33;
  fStartState[2] := 33;
  fStartState[3] := 33;
  fStartState[4] := 33;
  fStartState[5] := 33;
  fStartState[6] := 33;
  fStartState[7] := 33;
  fStartState[8] := 33;
  fStartState[9] := 33;
  fStartState[10] := 33;
  fStartState[11] := 33;
  fStartState[12] := 33;
  fStartState[13] := 33;
  fStartState[14] := 33;
  fStartState[15] := 33;
  fStartState[16] := 33;
  fStartState[17] := 33;
  fStartState[18] := 33;
  fStartState[19] := 33;
  fStartState[20] := 33;
  fStartState[21] := 33;
  fStartState[22] := 33;
  fStartState[23] := 33;
  fStartState[24] := 33;
  fStartState[25] := 33;
  fStartState[26] := 33;
  fStartState[27] := 33;
  fStartState[28] := 33;
  fStartState[29] := 33;
  fStartState[30] := 33;
  fStartState[31] := 33;
  fStartState[32] := 33;
  fStartState[33] := 24;
  fStartState[34] := 7;
  fStartState[35] := 33;
  fStartState[36] := 9;
  fStartState[37] := 33;
  fStartState[38] := 33;
  fStartState[39] := 33;
  fStartState[40] := 21;
  fStartState[41] := 22;
  fStartState[42] := 33;
  fStartState[43] := 2;
  fStartState[44] := 19;
  fStartState[45] := 11;
  fStartState[46] := 4;
  fStartState[47] := 33;
  fStartState[48] := 10;
  fStartState[49] := 10;
  fStartState[50] := 10;
  fStartState[51] := 10;
  fStartState[52] := 10;
  fStartState[53] := 10;
  fStartState[54] := 10;
  fStartState[55] := 10;
  fStartState[56] := 10;
  fStartState[57] := 10;
  fStartState[58] := 20;
  fStartState[59] := 15;
  fStartState[60] := 26;
  fStartState[61] := 14;
  fStartState[62] := 27;
  fStartState[63] := 33;
  fStartState[64] := 33;
  fStartState[65] := 1;
  fStartState[66] := 1;
  fStartState[67] := 1;
  fStartState[68] := 1;
  fStartState[69] := 1;
  fStartState[70] := 1;
  fStartState[71] := 1;
  fStartState[72] := 1;
  fStartState[73] := 1;
  fStartState[74] := 1;
  fStartState[75] := 1;
  fStartState[76] := 1;
  fStartState[77] := 1;
  fStartState[78] := 1;
  fStartState[79] := 1;
  fStartState[80] := 1;
  fStartState[81] := 1;
  fStartState[82] := 1;
  fStartState[83] := 1;
  fStartState[84] := 1;
  fStartState[85] := 1;
  fStartState[86] := 1;
  fStartState[87] := 1;
  fStartState[88] := 1;
  fStartState[89] := 1;
  fStartState[90] := 1;
  fStartState[91] := 30;
  fStartState[92] := 33;
  fStartState[93] := 31;
  fStartState[94] := 33;
  fStartState[95] := 1;
  fStartState[96] := 33;
  fStartState[97] := 33;
  fStartState[98] := 33;
  fStartState[99] := 33;
  fStartState[100] := 33;
  fStartState[101] := 33;
  fStartState[102] := 33;
  fStartState[103] := 33;
  fStartState[104] := 33;
  fStartState[105] := 33;
  fStartState[106] := 33;
  fStartState[107] := 33;
  fStartState[108] := 33;
  fStartState[109] := 33;
  fStartState[110] := 33;
  fStartState[111] := 33;
  fStartState[112] := 33;
  fStartState[113] := 33;
  fStartState[114] := 33;
  fStartState[115] := 33;
  fStartState[116] := 33;
  fStartState[117] := 33;
  fStartState[118] := 33;
  fStartState[119] := 33;
  fStartState[120] := 33;
  fStartState[121] := 33;
  fStartState[122] := 33;
  fStartState[123] := 16;
  fStartState[124] := 33;
  fStartState[125] := 18;
  fStartState[126] := 33;
  fStartState[127] := 33;
  fStartState[128] := 33;
  fStartState[129] := 33;
  fStartState[130] := 33;
  fStartState[131] := 33;
  fStartState[132] := 33;
  fStartState[133] := 33;
  fStartState[134] := 33;
  fStartState[135] := 33;
  fStartState[136] := 33;
  fStartState[137] := 33;
  fStartState[138] := 33;
  fStartState[139] := 33;
  fStartState[140] := 33;
  fStartState[141] := 33;
  fStartState[142] := 33;
  fStartState[143] := 33;
  fStartState[144] := 33;
  fStartState[145] := 33;
  fStartState[146] := 33;
  fStartState[147] := 33;
  fStartState[148] := 33;
  fStartState[149] := 33;
  fStartState[150] := 33;
  fStartState[151] := 33;
  fStartState[152] := 33;
  fStartState[153] := 33;
  fStartState[154] := 33;
  fStartState[155] := 33;
  fStartState[156] := 33;
  fStartState[157] := 33;
  fStartState[158] := 33;
  fStartState[159] := 33;
  fStartState[160] := 33;
  fStartState[161] := 33;
  fStartState[162] := 33;
  fStartState[163] := 33;
  fStartState[164] := 33;
  fStartState[165] := 33;
  fStartState[166] := 33;
  fStartState[167] := 33;
  fStartState[168] := 33;
  fStartState[169] := 33;
  fStartState[170] := 33;
  fStartState[171] := 33;
  fStartState[172] := 33;
  fStartState[173] := 33;
  fStartState[174] := 33;
  fStartState[175] := 33;
  fStartState[176] := 33;
  fStartState[177] := 33;
  fStartState[178] := 33;
  fStartState[179] := 33;
  fStartState[180] := 33;
  fStartState[181] := 33;
  fStartState[182] := 33;
  fStartState[183] := 33;
  fStartState[184] := 33;
  fStartState[185] := 33;
  fStartState[186] := 33;
  fStartState[187] := 33;
  fStartState[188] := 33;
  fStartState[189] := 33;
  fStartState[190] := 33;
  fStartState[191] := 33;
  fStartState[192] := 33;
  fStartState[193] := 33;
  fStartState[194] := 33;
  fStartState[195] := 33;
  fStartState[196] := 1;
  fStartState[197] := 1;
  fStartState[198] := 33;
  fStartState[199] := 33;
  fStartState[200] := 33;
  fStartState[201] := 33;
  fStartState[202] := 33;
  fStartState[203] := 33;
  fStartState[204] := 33;
  fStartState[205] := 33;
  fStartState[206] := 33;
  fStartState[207] := 33;
  fStartState[208] := 33;
  fStartState[209] := 33;
  fStartState[210] := 33;
  fStartState[211] := 33;
  fStartState[212] := 33;
  fStartState[213] := 33;
  fStartState[214] := 1;
  fStartState[215] := 33;
  fStartState[216] := 33;
  fStartState[217] := 33;
  fStartState[218] := 33;
  fStartState[219] := 33;
  fStartState[220] := 33;
  fStartState[221] := 33;
  fStartState[222] := 33;
  fStartState[223] := 33;
  fStartState[224] := 33;
  fStartState[225] := 33;
  fStartState[226] := 33;
  fStartState[227] := 33;
  fStartState[228] := 1;
  fStartState[229] := 1;
  fStartState[230] := 33;
  fStartState[231] := 33;
  fStartState[232] := 33;
  fStartState[233] := 33;
  fStartState[234] := 33;
  fStartState[235] := 33;
  fStartState[236] := 33;
  fStartState[237] := 33;
  fStartState[238] := 33;
  fStartState[239] := 33;
  fStartState[240] := 33;
  fStartState[241] := 33;
  fStartState[242] := 33;
  fStartState[243] := 33;
  fStartState[244] := 33;
  fStartState[245] := 33;
  fStartState[246] := 1;
  fStartState[247] := 33;
  fStartState[248] := 33;
  fStartState[249] := 33;
  fStartState[250] := 33;
  fStartState[251] := 33;
  fStartState[252] := 33;
  fStartState[253] := 33;
  fStartState[254] := 33;
  fStartState[255] := 33;
end; {Create}

destructor TDLGDefScanner.Destroy;
begin
  fHashList.Free;
  fHashList := nil;
  inherited;
end;

 { --------------------------------------------------------------------------- }
 { ---- implementation for TDLGDef ---- }

constructor TDLGDef.Create(AOwner: TComponent);
begin
  inherited;
  Scanner := TDLGDefScanner.Create;
  GetScanner.Owner := self;
  fOutputStream := TMemoryStream.Create;

  InitSymSet;
end; {Create}

destructor TDLGDef.Destroy;
begin
  Scanner.Free;
  fOutputStream.Free;

  inherited;
end; {Destroy}

function TDLGDef.ErrorStr(const ErrorCode: integer; const Data: ansistring): ansistring;
begin
  case ErrorCode of
    0:
      Result := 'EOF expected';
    1:
      Result := 'identifier expected';
    2:
      Result := 'integer value expected';
    3:
      Result := '_float expected';
    4:
      Result := 'string constant expected';
    5:
      Result := 'HexLiteral expected';
    6:
      Result := '"MSGOUTPUTNAME" expected';
    7:
      Result := '"=" expected';
    8:
      Result := '"SCROUTPUTNAME" expected';
    9:
      Result := '"SCRIPTTEMPLATE" expected';
    10:
      Result := '"SCRIPTID" expected';
    11:
      Result := '"NPCNAME" expected';
    12:
      Result := '"DESCRIPTION" expected';
    13:
      Result := '"LOCATION" expected';
    14:
      Result := '"DESCPROC" expected';
    15:
      Result := '"BEGIN" expected';
    16:
      Result := '";" expected';
    17:
      Result := '"UNKNOWN" expected';
    18:
      Result := '"KNOWN" expected';
    19:
      Result := '"DETAILED" expected';
    20:
      Result := '"END" expected';
    21:
      Result := '"ADDSKILLCHECK" expected';
    22:
      Result := '"{" expected';
    23:
      Result := '"FIELD" expected';
    24:
      Result := '"MODIFIER" expected';
    25:
      Result := '"ONSUCCESS" expected';
    26:
      Result := '"=>" expected';
    27:
      Result := '"ONFAILURE" expected';
    28:
      Result := '"}" expected';
    29:
      Result := '"IMPORT" expected';
    30:
      Result := '"EXPORT" expected';
    31:
      Result := '"LOCAL" expected';
    32:
      Result := '"VARIABLE" expected';
    33:
      Result := '"," expected';
    34:
      Result := '"DIALOGUE" expected';
    35:
      Result := '":" expected';
    36:
      Result := '"TIME_EVENT" expected';
    37:
      Result := '"INTERVAL" expected';
    38:
      Result := '"-" expected';
    39:
      Result := '"CODE" expected';
    40:
      Result := '"TIMED_EVENTS_BLOCK" expected';
    41:
      Result := '"DEFAULT_EVENT" expected';
    42:
      Result := '"+" expected';
    43:
      Result := '"ADDMSG" expected';
    44:
      Result := '"MESSAGES" expected';
    45:
      Result := '"(" expected';
    46:
      Result := '")" expected';
    47:
      Result := '"==" expected';
    48:
      Result := '"!=" expected';
    49:
      Result := '"<" expected';
    50:
      Result := '">" expected';
    51:
      Result := '">=" expected';
    52:
      Result := '"<=" expected';
    53:
      Result := '"AND" expected';
    54:
      Result := '"OR" expected';
    55:
      Result := '"PLAYER" expected';
    56:
      Result := '"[" expected';
    57:
      Result := '"INT" expected';
    58:
      Result := '"]" expected';
    59:
      Result := '"REACTION" expected';
    60:
      Result := '"BAD" expected';
    61:
      Result := '"NEUTRAL" expected';
    62:
      Result := '"GOOD" expected';
    63:
      Result := '"CONDITION" expected';
    64:
      Result := '"GOTO" expected';
    65:
      Result := '"USE_ACTION" expected';
    66:
      Result := '"NOTES" expected';
    67:
      Result := '"CUSTOM_CODE" expected';
    68:
      Result := '"ADD_NEW_PROC" expected';
    69:
      Result := '"STARTNUM" expected';
    70:
      Result := '"NPC" expected';
    71:
      Result := '"FEMALE" expected';
    72:
      Result := '"RANDOMFLOATS" expected';
    73:
      Result := '"CASE" expected';
    74:
      Result := '"ENDCASE" expected';
    75:
      Result := '"STARTNODES" expected';
    76:
      Result := '"DEFAULTNODE" expected';
    77:
      Result := 'not expected';
    78:
      Result := 'invalid PlayerOpt';
    79:
      Result := 'invalid Data';
    80:
      Result := 'invalid Stringdata';
    81:
      Result := 'invalid Stringdata';
    82:
      Result := 'invalid condsdata';
    83:
      Result := 'invalid Nodes';
    84:
      Result := 'invalid variabledef';
    85:
      Result := 'invalid StartNodes';
    86:
      Result := 'invalid Main';


    else
      if Assigned(OnCustomError) then
        Result := OnCustomError(Self, ErrorCode, Data)
      else
      begin
        Result := 'Error: ' + IntToStr(ErrorCode);
        if Trim(Data) > '' then
          Result := Result + ' (' + Data + ')';
      end;
  end;  {case nr}
end; {ErrorStr}

procedure TDLGDef.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

 // if Assigned(OnStatusUpdate) then
 //   OnStatusUpdate(Self, 'parsing source', -1);

  { instigate the compilation }
  if Assigned(BeforeParse) then
    BeforeParse(Self);
  Parse;
  if Assigned(AfterParse) then
    AfterParse(Self);

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) or ((GenListWhen = glOnError) and
    (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful and Assigned(OnSuccess) then
    OnSuccess(Self);
  if (not Successful) and Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TDLGDef.Get;
begin
  repeat


    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
end;  {Get}

function TDLGDef.GetScanner: TDLGDefScanner;
begin
  Result := Scanner as TDLGDefScanner;
end;  {GetScanner}

function TDLGDef._In(var s: SymbolSet; x: integer): boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TDLGDef._StartNodeData;
begin
  Expect(CASESym);
  _Conditions;
  startnodes[startnodecnt].condition := currentcondition;
  ;
  Expect(_colonSym);
  Expect(identifierSym);
  startnodes[startnodecnt].gotonode := lexstring;
  ;
  Expect(ENDCASESym);
  Inc(startnodecnt);
  ;
end;

procedure TDLGDef._AddProc;
begin
  Expect(ADD_underscoreNEW_underscorePROCSym);
  Expect(identifierSym);
  New(custom_procedures[customproccnt]);
  custom_procedures[customproccnt].Name  := lexstring;
  custom_procedures[customproccnt].Lines := '';
  ;
  Expect(_lbraceSym);
  Expect(_stringSym);
  custom_procedures[customproccnt].Lines :=
    custom_procedures[customproccnt].Lines + parse_string(lexstring) + #13#10;
  while (fCurrentInputSymbol = _commaSym) do
  begin
    Get;
    Expect(_stringSym);
    custom_procedures[customproccnt].Lines :=
      custom_procedures[customproccnt].Lines + parse_string(lexstring) + #13#10;
  end;
  Expect(_rbraceSym);
  Inc(customproccnt);
end;

procedure TDLGDef._CustomCodeBlock;
begin
  Expect(CUSTOM_underscoreCODESym);
  nodes[nodecnt].custom_code := '';
  ;
  Expect(_lbraceSym);
  Expect(_stringSym);
  nodes[nodecnt].custom_code :=
    nodes[nodecnt].custom_code + parse_string(lexstring) + #13#10;
  ;
  while (fCurrentInputSymbol = _commaSym) do
  begin
    Get;
    Expect(_stringSym);
    nodes[nodecnt].custom_code :=
      nodes[nodecnt].custom_code + parse_string(lexstring) + #13#10;
    ;
  end;
  Expect(_rbraceSym);
end;

procedure TDLGDef._PlayerOpt;
begin
  Expect(PLAYERSym);
  Expect(_lbrackSym);
  Expect(INTSym);
  Expect(_equalSym);
  Expect(integer_Sym);
  nodes[nodecnt].playerdata[nodes[nodecnt].playerdatacnt].intelligence :=
    StrToInt(lexstring);
  ;
  Expect(_rbrackSym);
  Expect(_lbrackSym);
  Expect(REACTIONSym);
  Expect(_equalSym);
  if (fCurrentInputSymbol = BADSym) then
  begin
    Get;
    nodes[nodecnt].playerdata[nodes[nodecnt].playerdatacnt].reaction := REACTION_BAD;
    ;
  end
  else if (fCurrentInputSymbol = NEUTRALSym) then
  begin
    Get;
    nodes[nodecnt].playerdata[nodes[nodecnt].playerdatacnt].reaction := REACTION_NEUTRAL;
    ;
  end
  else if (fCurrentInputSymbol = GOODSym) then
  begin
    Get;
    nodes[nodecnt].playerdata[nodes[nodecnt].playerdatacnt].reaction := REACTION_GOOD;
    ;
  end
  else
  begin
    SynError(78);
  end;
  Expect(_rbrackSym);
  if (fCurrentInputSymbol = CONDITIONSym) then
  begin
    Get;
    Expect(_colonSym);
    _Conditions;
    nodes[nodecnt].playerdata[nodes[nodecnt].playerdatacnt].conditiondata :=
      currentcondition;
    ;
  end;
  Expect(_colonSym);
  _Stringdata;
  nodes[nodecnt].playerdata[nodes[nodecnt].playerdatacnt].textdata := currentcode;
  nodes[nodecnt].playerdata[nodes[nodecnt].playerdatacnt].textdata_string := container;
  ;
  Expect(_commaSym);
  Expect(GOTOSym);
  Expect(_equal_greaterSym);
  Expect(identifierSym);
  nodes[nodecnt].playerdata[nodes[nodecnt].playerdatacnt].linknode := lexstring;
  ;
  if (fCurrentInputSymbol = USE_underscoreACTIONSym) then
  begin
    Get;
    Expect(identifierSym);
  end;
  if (fCurrentInputSymbol = NOTESSym) then
  begin
    Get;
    Expect(_stringSym);
    nodes[nodecnt].playerdata[nodes[nodecnt].playerdatacnt].notes :=
      parse_string(lexstring);
    ;
  end;
  Expect(_semicolonSym);
  Inc(nodes[nodecnt].playerdatacnt);
  ;
end;

procedure TDLGDef._Conditions;
begin
  currentcondition := '';
  ;
  Expect(_lparenSym);

  _Data;
  Expect(_rparenSym);

  while (fCurrentInputSymbol = ANDSym) or (fCurrentInputSymbol = ORSym) do
  begin
    if (fCurrentInputSymbol = ANDSym) then
    begin
      Get;
      currentcondition := currentcondition + ' and ';
    end
    else
    begin
      Get;
      currentcondition := currentcondition + ' or ';
    end;
    Expect(_lparenSym);
    _Data;
    Expect(_rparenSym);
  end;
end;

procedure TDLGDef._Data;
begin
 if  fCurrentInputSymbol=_stringSym then
 begin
  get;
  currentcondition := currentcondition + '(' + parse_string(lexstring);

 end else
 if  fCurrentInputSymbol=identifierSym then
 begin
Get;
  currentcondition := currentcondition + '(' + lexstring;
 end;
  if (fCurrentInputSymbol = _lparenSym) then
  begin
    Get;
    currentcondition := currentcondition + '(';
    ;
    _condsdata;
    while (fCurrentInputSymbol = _commaSym) do
    begin
      Get;
      currentcondition := currentcondition + ',';
      ;
      _condsdata;
    end;
    Expect(_rparenSym);
    currentcondition := currentcondition + ')';
    ;
  end;
  if _In(symSet[1], fCurrentInputSymbol) then
  begin
    case fCurrentInputSymbol of
      _equal_equalSym:
      begin
        Get;
        currentcondition := currentcondition + '==';
      end;
      _bang_equalSym:
      begin
        Get;
        currentcondition := currentcondition + '!=';
      end;
      _lessSym:
      begin
        Get;
        currentcondition := currentcondition + '<';
      end;
      _greaterSym:
      begin
        Get;
        currentcondition := currentcondition + '>';
      end;
      _greater_equalSym:
      begin
        Get;
        currentcondition := currentcondition + '>=';
      end;
      _less_equalSym:
      begin
        Get;
        currentcondition := currentcondition + '<=';
      end;
    end;
    if (fCurrentInputSymbol = identifierSym) then
    begin
      Get;
    end
    else if (fCurrentInputSymbol = integer_Sym) then
    begin
      Get;
    end
    else if (fCurrentInputSymbol = _stringSym) then
    begin
      Get;
    end
    else
    begin
      SynError(79);
    end;
    currentcondition := currentcondition + lexstring;
  end;
  currentcondition := currentcondition + ')';
end;

procedure TDLGDef._AddMessage;
begin
  Expect(ADDMSGSym);
  Expect(integer_Sym);
  currentid := StrToInt(lexstring);
  Expect(_commaSym);
  _Stringdata;
  Expect(_semicolonSym);
end;

procedure TDLGDef._Stringdata;
begin
  container := '';
  Count := 0;
  currentcode := '';
  markerindex := strcnt;
  if (fCurrentInputSymbol = identifierSym) then
  begin
    Get;
    currentcode := currentcode + LexString;
    container := container + ' [variable: ' + lexstring + ']';
    ;
    stored_id := -1;
  end
  else if (fCurrentInputSymbol = _stringSym) then
  begin
    Get;
    currentstring := parse_string(lexstring);
    stored_id := addmsgdata(currentid, currentstring, container, lastoptimized);
    currentcode := currentcode + IntToStr(stored_id);
    if lastoptimized = False then
      currentid := currentid + 1;
  end
  else
  begin
    SynError(80);
  end;
  while (fCurrentInputSymbol = _plusSym) do
  begin
    Get;

    if Count = 0 then
    begin
      if stored_id <> -1 then
        currentcode := 'mstr(' + IntToStr(stored_id) + ')+'
      else
        currentcode := currentcode + '+';
      // writeln ('CODE=',currentcode);
    end
    else
    begin
      ;
      // writeln ('CODE=',currentcode);
      currentcode := currentcode + '+';
    end;
    Count := Count + 1;
    if (fCurrentInputSymbol = identifierSym) then
    begin
      Get;
      currentcode := currentcode + lexstring;
      container := container + ' [variable: ' + lexstring + ']';
      ;
    end
    else if (fCurrentInputSymbol = _stringSym) then
    begin
      Get;
      currentstring := parse_string(lexstring);
      stored_id := currentid;
      finalid := addmsgdata(currentid, currentstring, container, lastoptimized);
      currentcode := currentcode + 'mstr(' + IntToStr(finalid) + ')';
      if lastoptimized = False then
        currentid := currentid + 1;
      ;
    end
    else
    begin
      SynError(81);
    end;
  end;
end;

procedure TDLGDef._condsdata;
begin
  if (fCurrentInputSymbol = identifierSym) then
  begin
    Get;
    currentcondition := currentcondition + lexstring;
    ;
  end
  else if (fCurrentInputSymbol = _stringSym) then
  begin
    Get;
    currentcondition := currentcondition + parse_string(lexstring);
    ;
  end
  else if (fCurrentInputSymbol = integer_Sym) then
  begin
    Get;
    currentcondition := currentcondition + lexstring;
    ;
  end
  else
  begin
    SynError(82);
  end;
end;

procedure TDLGDef._TimedEvent;
begin
  Expect(TIME_underscoreEVENTSym);
  New(globaltimedevents.events[globaltimedevents.eventcnt]);
  globaltimedevents.events[globaltimedevents.eventcnt].code := TStringList.Create;
  globaltimedevents.events[globaltimedevents.eventcnt].interval2 := -1;
  Expect(identifierSym);
  globaltimedevents.events[globaltimedevents.eventcnt].define_name := lexstring;
  ;
  Expect(_equalSym);
  Expect(integer_Sym);
  globaltimedevents.events[globaltimedevents.eventcnt].define_value :=
    StrToInt(lexstring);
  ;
  Expect(_semicolonSym);
  Expect(INTERVALSym);
  Expect(integer_Sym);
  globaltimedevents.events[globaltimedevents.eventcnt].interval1 := StrToInt(lexstring);
  ;
  if (fCurrentInputSymbol = _minusSym) then
  begin
    Get;
    Expect(integer_Sym);
    globaltimedevents.events[globaltimedevents.eventcnt].interval2 :=
      StrToInt(lexstring);
    ;
  end;
  Expect(_semicolonSym);
  Expect(CODESym);
  Expect(BEGINSym);
  Expect(_stringSym);
  globaltimedevents.events[globaltimedevents.eventcnt].code.add(parse_string(lexstring));
  while (fCurrentInputSymbol = _commaSym) do
  begin
    Get;
    Expect(_stringSym);
    globaltimedevents.events[globaltimedevents.eventcnt].code.add(
      parse_string(lexstring));
  end;
  Expect(ENDSym);
  Inc(globaltimedevents.eventcnt);
end;

procedure TDLGDef._Nodes;
begin
  Expect(identifierSym);
  // writeln('Node: ',lexstring,' cnt=',nodecnt);
  New(nodes[nodecnt]);
  nodes[nodecnt].isfloat := False;
  nodes[nodecnt].playerdatacnt := 0;
  nodes[nodecnt].Name := lexstring;
  Expect(_colonSym);
  if (fCurrentInputSymbol = _lparenSym) then
  begin
    Get;
    Expect(_stringSym);
    nodes[nodecnt].desc := parse_string(lexstring);
    ;
    Expect(_rparenSym);
  end;
  if (fCurrentInputSymbol = NOTESSym) then
  begin
    Get;
    Expect(_stringSym);
    nodes[nodecnt].notes := parse_string(lexstring);
    ;
  end;
  Expect(STARTNUMSym);
  Expect(_equalSym);
  Expect(integer_Sym);
  currentid := StrToInt(lexstring);
  ;
  Expect(_semicolonSym);
  if (fCurrentInputSymbol = ADD_underscoreNEW_underscorePROCSym) then
  begin
    _AddProc;
    while (fCurrentInputSymbol = ADD_underscoreNEW_underscorePROCSym) do
    begin
      _AddProc;
    end;
  end;
  Expect(BEGINSym);
  if (fCurrentInputSymbol = ADDSKILLCHECKSym) then
  begin
    _SkillChecks;
    while (fCurrentInputSymbol = ADDSKILLCHECKSym) do
    begin
      _SkillChecks;
    end;
  end;
  if (fCurrentInputSymbol = CUSTOM_underscoreCODESym) then
  begin
    _CustomCodeBlock;
  end;
  if (fCurrentInputSymbol = NPCSym) then
  begin
    Get;
    Expect(_colonSym);
    _Stringdata;
    nodes[nodecnt].npcdata := currentcode;
    nodes[nodecnt].npcdata_text := container;
    if (stringtable[markerindex] = nil) then
      New(stringtable[markerindex]);

    stringtable[markerindex].markercomment := nodes[nodecnt].Name;
    if nodes[nodecnt].desc <> '' then
      stringtable[markerindex].markercomment := nodes[nodecnt].desc;
    ;
    if (fCurrentInputSymbol = FEMALESym) then
    begin
      Get;
      Expect(_colonSym);
      _Stringdata;

      nodes[nodecnt].npcdata_female := currentcode;
      nodes[nodecnt].npcdatafemale_text := container;

      ;
    end;
    Expect(_semicolonSym);
    if (fCurrentInputSymbol = PLAYERSym) then
    begin
      _PlayerOpt;
      while (fCurrentInputSymbol = PLAYERSym) do
      begin
        _PlayerOpt;
      end;
    end;
  end
  else if (fCurrentInputSymbol = RANDOMFLOATSSym) then
  begin
    Get;
    nodes[nodecnt].floatmin := currentid;
    Expect(_lparenSym);
    _Stringdata;

    stringtable[markerindex].markercomment :=
      'Node ' + IntToStr(nodecnt) + ' [' + nodes[nodecnt].Name + ']';
    if nodes[nodecnt].desc <> '' then
      stringtable[markerindex].markercomment := nodes[nodecnt].desc;


    while (fCurrentInputSymbol = _commaSym) do
    begin
      Get;
      _Stringdata;
    end;
    Expect(_rparenSym);
    nodes[nodecnt].floatmax := currentid - 1;
    nodes[nodecnt].isfloat  := True;
    ;
  end
  else
  begin
    SynError(83);
  end;
  Expect(ENDSym);
  Inc(nodecnt);
  ;
end;

procedure TDLGDef._variabledef;
begin
  New(vars[varcnt]);
  ;
  if (fCurrentInputSymbol = IMPORTSym) or (fCurrentInputSymbol = EXPORTSym) or
    (fCurrentInputSymbol = LOCALSym) then
  begin
    if (fCurrentInputSymbol = IMPORTSym) then
    begin
      Get;
      vars[varcnt].varflags := VAR_FLAGS_IMPORT;
      ;
    end
    else if (fCurrentInputSymbol = EXPORTSym) then
    begin
      Get;
      vars[varcnt].varflags := VAR_FLAGS_EXPORT;
      ;
    end
    else
    begin
      Get;
      vars[varcnt].varflags := VAR_FLAGS_LOCAL;
      ;
    end;
  end;
  Expect(identifierSym);

  vars[varcnt].vartype := -1;
  vars[varcnt].Name := lexstring;
  if (fCurrentInputSymbol = NOTESSym) then
  begin
    Get;
    Expect(_stringSym);

    vars[varcnt].notes := parse_string(lexstring);
  end;


  if (fCurrentInputSymbol = _equalSym) then
  begin
    Get;
    if (fCurrentInputSymbol = integer_Sym) then
    begin
      Get;
      vars[varcnt].vartype := VAR_TYPE_INT;
      vars[varcnt].Value := StrToInt(lexstring);
    end
    else if (fCurrentInputSymbol = _stringSym) then
    begin
      Get;
      vars[varcnt].vartype := VAR_TYPE_STRING;
      vars[varcnt].Value := parse_string(lexstring);
    end
    else if (fCurrentInputSymbol = _floatSym) then
    begin
      Get;
      vars[varcnt].vartype := VAR_TYPE_FLOAT;
      vars[varcnt].Value := strtofloat(lexstring);
    end
    else
    begin
      SynError(84);
    end;
  end;
  Inc(varcnt);

end;

procedure TDLGDef._SkillChecks;
begin
  Expect(ADDSKILLCHECKSym);
  Expect(identifierSym);
  New(skillchecks[skillcheckcnt]);
  skillchecks[skillcheckcnt].check_proc_name := lexstring;
  ;
  Expect(_lbraceSym);
  Expect(FIELDSym);
  Expect(_equalSym);
  Expect(identifierSym);
  skillchecks[skillcheckcnt].check_what := stringtoskill(lexstring);
  ;
  Expect(MODIFIERSym);
  Expect(_equalSym);
  Expect(integer_Sym);
  skillchecks[skillcheckcnt].modifier := StrToInt(lexstring);
  ;
  Expect(ONSUCCESSSym);
  Expect(_equal_greaterSym);
  Expect(identifierSym);
  skillchecks[skillcheckcnt].successnode := lexstring;
  ;
  Expect(ONFAILURESym);
  Expect(_equal_greaterSym);
  Expect(identifierSym);
  skillchecks[skillcheckcnt].failurenode := lexstring;
  ;
  Expect(_rbraceSym);
  Inc(skillcheckcnt);
  ;
end;

procedure TDLGDef._variables;
begin
  Expect(VARIABLESym);
  _variabledef;
  while (fCurrentInputSymbol = _commaSym) do
  begin
    Get;
    _variabledef;
  end;
  Expect(_semicolonSym);
end;

procedure TDLGDef._Messages;
begin
  Expect(MESSAGESSym);
  Expect(_lbraceSym);
  _AddMessage;
  while (fCurrentInputSymbol = ADDMSGSym) do
  begin
    _AddMessage;
  end;
  Expect(_rbraceSym);
end;

procedure TDLGDef._StartNodes;
begin
  Expect(STARTNODESSym);
  Expect(BEGINSym);
  startnodecnt := 0;
  ;
  if (fCurrentInputSymbol = DEFAULTNODESym) then
  begin
    Get;
    Expect(_colonSym);
    Expect(identifierSym);
    startnodes[startnodecnt].condition := '';
    startnodes[startnodecnt].gotonode  := lexstring;
    Inc(startnodecnt);
    ;
  end
  else if (fCurrentInputSymbol = CASESym) then
  begin
    _StartNodeData;
    while (fCurrentInputSymbol = CASESym) do
    begin
      _StartNodeData;
    end;
  end
  else
  begin
    SynError(85);
  end;
  Expect(ENDSym);
end;

procedure TDLGDef._Output;
begin
  Expect(MSGOUTPUTNAMESym);
  Expect(_equalSym);
  Expect(_stringSym);
  msgoutput := parse_string(lexstring);
  ;
  Expect(SCROUTPUTNAMESym);
  Expect(_equalSym);
  Expect(_stringSym);
  ssloutput := parse_String(lexstring);
  ;
  Expect(SCRIPTTEMPLATESym);
  Expect(_equalSym);
  Expect(_stringSym);
  used_template := parse_String(lexstring);
  ;
  Expect(SCRIPTIDSym);
  Expect(_equalSym);
  Expect(identifierSym);
  script_id := lexstring;
  ;
  if (fCurrentInputSymbol = NPCNAMESym) then
  begin
    Get;
    Expect(_equalSym);
    Expect(_stringSym);
    npcname := parse_string(lexstring);
    ;
    Expect(DESCRIPTIONSym);
    Expect(_equalSym);
    Expect(_stringSym);
    npcdesc := parse_string(lexstring);
    ;
    Expect(LOCATIONSym);
    Expect(_equalSym);
    Expect(_stringSym);
    location := parse_string(lexstring);
    ;
  end;
end;

procedure TDLGDef._Dialogue;
begin
  Expect(DIALOGUESym);
  Expect(_colonSym);
  Expect(BEGINSym);
  _Nodes;
  while (fCurrentInputSymbol = identifierSym) do
  begin
    _Nodes;
  end;
  Expect(ENDSym);
end;

procedure TDLGDef._TimedEvents;
begin
  Expect(TIMED_underscoreEVENTS_underscoreBLOCKS);
  Expect(DEFAULT_underscoreEVENTSym);
  Expect(_equalSym);
  Expect(integer_Sym);
  globaltimedevents.eventcnt := 0;
  globaltimedevents.default_index := StrToInt(lexstring);
  Expect(_semicolonSym);
  Expect(BEGINSym);
  _TimedEvent;
  while (fCurrentInputSymbol = TIME_underscoreEVENTSym) do
  begin
    _TimedEvent;
  end;
  Expect(ENDSym);
end;

procedure TDLGDef._LookAtProc;
begin
  Expect(DESCPROCSym);
  Expect(BEGINSym);
  Expect(_semicolonSym);
  Expect(UNKNOWNSym);
  Expect(_equalSym);
  Expect(_stringSym);
  currentid := 100;
  currentstring := parse_string(lexstring);
  addmsgdata(currentid, currentstring, container, lastoptimized);
  ;
  Expect(KNOWNSym);
  Expect(_equalSym);
  Expect(_stringSym);
  currentid := 101;
  currentstring := parse_string(lexstring);
  addmsgdata(currentid, currentstring, container, lastoptimized);
  ;
  Expect(DETAILEDSym);
  Expect(_equalSym);
  Expect(_stringSym);
  currentid := 102;
  currentstring := parse_string(lexstring);
  addmsgdata(currentid, currentstring, container, lastoptimized);
  ;
  Expect(ENDSym);
  Expect(_semicolonSym);
end;

procedure TDLGDef._Main;
begin
  case fCurrentInputSymbol of
    DESCPROCSym:
    begin
      _LookAtProc;
    end;
    TIMED_underscoreEVENTS_underscoreBLOCKS:
    begin
      _TimedEvents;
    end;
    DIALOGUESym:
    begin
      _Dialogue;
    end;
    MSGOUTPUTNAMESym:
    begin
      _Output;
    end;
    STARTNODESSym:
    begin
      _StartNodes;
    end;
    MESSAGESSym:
    begin
      _Messages;
    end;
    VARIABLESym:
    begin
      _variables;
    end;
    else
    begin
      SynError(86);
    end;
  end;
end;

procedure TDLGDef._DLGDef;
begin
  Init;
  ;
  _Main;
  while _In(symSet[2], fCurrentInputSymbol) do
  begin
    _Main;
  end;
  Final;
  ;
end;

function TDLGDef.GetMajorVersion: integer;
begin
  Result := 1;
end;

function TDLGDef.GetMinorVersion: integer;
begin
  Result := 0;
end;

function TDLGDef.GetRelease: integer;
begin
  Result := 0;
end;

function TDLGDef.GetBuild: integer;
begin
  Result := 306;
end;

function TDLGDef.GetBuildDate: TDateTime;
const
  BDate = 38552;
  Hour = 18;
  Min = 29;
begin
  Result := BDate + EncodeTime(Hour, Min, 0, 0);
end;

function TDLGDef.GetVersion: ansistring;
var
  MinorVersionStr: string;
begin
  MinorVersionStr := IntToStr(MinorVersion);
  if (length(MinorVersionStr) > 0) and (MinorVersion > 0) then
    MinorVersionStr := '0' + MinorVersionStr;
  Result := 'Version: ' + IntToStr(MajorVersion) + '.' + MinorVersionStr +
    ' Release ' + IntToStr(Release) + ' Build ' + IntToStr(Build);
end;

function TDLGDef.GetVersionComment: ansistring;
begin
  Result := 'SSL Dialogue Generator';
end;

function TDLGDef.GetGrammarAuthor: ansistring;
begin
  Result := 'T. Pitkänen';
end;

function TDLGDef.GetGrammarCopyright: ansistring;
begin
  Result := '(c) 2003 Dj Unique';
end;

procedure TDLGDef.SetVersion(const Value: ansistring);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TDLGDef.Parse;
begin
  errDist := minErrDist;
  GetScanner._Reset;
  Get;
  _DLGDef;
end;  {Parse}

procedure TDLGDef.InitSymSet;
begin
  symSet[0, 0] := [EOFSYMB];
  symSet[0, 1] := [];
  symSet[0, 2] := [];
  symSet[0, 3] := [];
  symSet[0, 4] := [];
  symSet[1, 0] := [];
  symSet[1, 1] := [];
  symSet[1, 2] := [_equal_equalSym - 32];
  symSet[1, 3] := [_bang_equalSym - 48, _lessSym - 48, _greaterSym -
    48, _greater_equalSym - 48, _less_equalSym - 48];
  symSet[1, 4] := [];
  symSet[2, 0] := [MSGOUTPUTNAMESym, DESCPROCSym];
  symSet[2, 1] := [];
  symSet[2, 2] := [VARIABLESym - 32, DIALOGUESym - 32,
    TIMED_underscoreEVENTS_underscoreBLOCKS - 32, MESSAGESSym - 32];
  symSet[2, 3] := [];
  symSet[2, 4] := [STARTNODESSym - 64];
end; {InitSymSet}

end { DLGDef }.

