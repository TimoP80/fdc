(*

  The initial code was generated by Deepseek R1, I hand coded the rest of it
  to make the import process work flawlessly.

  The parser still can't handle more complex if .. then statements due to the way
  the .fmf format is created but it should generally import just about any script
  especially ones converted with DialougeConverter, the official scripts work fine
  but i need to test a lot of them to see if there are nay issues

*)

unit SSLParser;

interface

uses System.Sysutils, SSLImportUnit, System.RegularExpressions, Classes;

type
  TScriptVariable = record
    Name: string;
    Value: string;
  end;

  TScriptProcedure = record
    Name: string;
    Body: TStringList;
  end;

  TScriptCommand = record
    Command: string;
    Parameters: TArray<string>;
  end;

  TScriptIfStatement = record
    Condition: string;
    ThenBlock: TStringList;
    ElseBlock: TStringList;
  end;

  TScript = class
  private
    FVariables: TArray<TScriptVariable>;
    FProcedures: TArray<TScriptProcedure>;
    function ParseExpression(const Expr: string): string;
    // Parses arithmetic/logical expressions
    function ParseCondition(const Condition: string): string;
    // Parses conditions
    function ParseCommand(const Line: string): TScriptCommand;
    // Parses script commands
    function SplitParameters(const ParamStr: string): TArray<string>;
    // Splits parameters into fields
    function ParseIfStatement(var Index: Integer; ProcedureBody: TStringList)
      : TScriptIfStatement; // Parses if statements
    function EvaluateExpression(const Expr: string): string;
    // Evaluates expressions
procedure ParseCommands(Block: TStringList; condition: string);
    // Parses commands within a block
    function EvaluateFunctionCall(const FuncCall: string): string;
    // Evaluates function calls
    function ParseFunctionCallsInCommand(const Command: string): string;
    // Parses function calls in a command
  public
    constructor Create;
    destructor Destroy; override;
    procedure ParseScript(const ScriptText: TStringList);
    procedure AddVariable(const Name, Value: string);
    procedure AddProcedure(const Name: string; Body: TStringList);
    procedure ParseProcedureBody(ProcedureBody: TStringList);
    // Parses procedure bodies
  end;

var
  CurrentProcedure: TScriptProcedure;

implementation

constructor TScript.Create;
begin
  inherited;
  FVariables := [];
  FProcedures := [];
end;

destructor TScript.Destroy;
var
  I: Integer;
begin
  for I := 0 to High(FProcedures) do
    FProcedures[I].Body.Free;
  inherited;
end;
(*
procedure TScript.ParseScript(const ScriptText: TStringList);
var
  I: Integer;
  Line: string;
  Match: TMatch;
  level: integer;
  procname: string;
  InProcedure: Boolean;
begin
  InProcedure := False;
  level:=1;
  for I := 0 to ScriptText.Count - 1 do
  begin
    Line := Trim(ScriptText[I]);
    writeln('Script Line: ',line, ' level ',level);
    if Line.StartsWith('procedure ') then
    begin
      InProcedure := True;
      if pos('begin', Line) = 0 then
      begin
        Match := TRegEx.Match(Line, 'procedure\s+(\w+)', [roIgnoreCase]);

        if Match.Success then
        begin
          procname := Match.Groups[1].Value;
          CurrentProcedure.Name := procname;

        end;

      end
      else
     begin
        CurrentProcedure.Name := Copy(Line, 11, pos(' ', Line, 11) - 11);
     end;
      CurrentProcedure.Body := TStringList.Create;

      Data_AddProcedureHeader(CurrentProcedure.Name);
    end

    else if (Line = 'begin')  then
    begin

       if InProcedure = True then
      begin
        // data_addcommand(currentprocedure.name,'begin',[]);

        // Do nothing, just marking the start of the procedure body
      end;
    end
    else if Line = 'end' then
    begin
      // writeln('encountered end');
     //  if level>0 then dec(level);

      if (InProcedure)  then
      begin
       writeln('parsing procedure body, currentproc: ', CurrentProcedure.Name);
        ParseProcedureBody(CurrentProcedure.Body); // Parse the procedure body
        AddProcedure(CurrentProcedure.Name, CurrentProcedure.Body);
        InProcedure := False;
      end;
   end
    else if InProcedure then
    begin
      // writeln('Adding to procedure body ',line);
      CurrentProcedure.Body.Add(Line);
    end
    else if Line.StartsWith('#define ') then
    begin
      // Handle variable definitions
      AddVariable(Copy(Line, 9, pos(' ', Line, 9) - 9),
        Copy(Line, pos(' ', Line, 9) + 1, Length(Line)));
    end;

  end;
end;
  *)
procedure TScript.ParseScript(const ScriptText: TStringList);
var
  I: Integer;
  Line: string;
  Match: TMatch;
  level: integer;
  procname: string;
  InProcedure: Boolean;
begin
  InProcedure := False;
  level := 0; // Initialize nesting level counter
  for I := 0 to ScriptText.Count - 1 do
  begin
    Line := Trim(ScriptText[I]);
    writeln('Script Line: ', line, ' level ', level);

    if Line.StartsWith('procedure ') then
    begin
      InProcedure := True;
      if pos('begin', Line) = 0 then
      begin
        Match := TRegEx.Match(Line, 'procedure\s+(\w+)', [roIgnoreCase]);

        if Match.Success then
        begin
          procname := Match.Groups[1].Value;
          CurrentProcedure.Name := procname;
        end;
      end
      else
      begin
        CurrentProcedure.Name := Copy(Line, 11, pos(' ', Line, 11) - 11);
      end;
      CurrentProcedure.Body := TStringList.Create;
      Data_AddProcedureHeader(CurrentProcedure.Name);
    end

    else if (Line = 'begin') then
    begin
      if InProcedure then
      begin
        Inc(level); // Increment nesting level for every `begin`
        writeln('Encountered begin, level: ', level);
      end;
    end

    else if Line = 'end' then
    begin
      if InProcedure then
      begin
        if level > 0 then
        begin
          Dec(level); // Decrement nesting level for every `end`
          writeln('Encountered end, level: ', level);
        end;

        // Only end the procedure if the nesting level is 0
        if level = 0 then
        begin
          writeln('Parsing procedure body, currentproc: ', CurrentProcedure.Name);
          ParseProcedureBody(CurrentProcedure.Body); // Parse the procedure body
          AddProcedure(CurrentProcedure.Name, CurrentProcedure.Body);
          InProcedure := False;
        end;
      end;
    end

    else if InProcedure then
    begin
      // Add the line to the procedure body
      CurrentProcedure.Body.Add(Line);
    end

    else if Line.StartsWith('#define ') then
    begin
      // Handle variable definitions
      AddVariable(Copy(Line, 9, pos(' ', Line, 9) - 9),
        Copy(Line, pos(' ', Line, 9) + 1, Length(Line)));
    end;
  end;
end;

  procedure TScript.AddVariable(const Name, Value: string);
begin
  SetLength(FVariables, Length(FVariables) + 1);
  FVariables[High(FVariables)].Name := Name;
  FVariables[High(FVariables)].Value := Value;
end;

procedure TScript.AddProcedure(const Name: string; Body: TStringList);
begin
  SetLength(FProcedures, Length(FProcedures) + 1);
  //writeln('Add procedure:');
  //writeln(Body.text);
  FProcedures[High(FProcedures)].Name := Name;
  FProcedures[High(FProcedures)].Body := Body;
end;

procedure TScript.ParseProcedureBody(ProcedureBody: TStringList);
var
  I: Integer;
  Line: string;
  TrimmedLine: string;
  Command: TScriptCommand;
  IfStatement: TScriptIfStatement;
begin
  I := 0;
  while I < ProcedureBody.Count do
  begin
    Line := ProcedureBody[I];
    TrimmedLine := Trim(Line);
    writeln('Procedure body:',trimmedline);
    // Skip empty lines and comments
    if (TrimmedLine = '') or (TrimmedLine.StartsWith('//')) or
      (TrimmedLine.StartsWith('/*')) then
    begin
      inc(I);
      Continue;
    end;

    // Handle if statements
    if TrimmedLine.StartsWith('if ') then
    begin
      IfStatement := ParseIfStatement(I, ProcedureBody);
      // Process the if statement (e.g., execute or store it)
      // Writeln('If Condition: ', IfStatement.Condition);
      // Writeln('Then Block:');
      Data_AddCondition(CurrentProcedure.Name, IfStatement.Condition);
      ParseCommands(IfStatement.ThenBlock, ifstatement.Condition);
      // Parse commands in the "then" block
      if IfStatement.ElseBlock.Count > 0 then
      begin
        // Writeln('Else Block:');
     ParseCommands(IfStatement.ElseBlock, '');
        // Parse commands in the "else" block
      end;
    end
    else if pos('variable', TrimmedLine) <> 0 then
    begin
      // writeln ('Variable definition at ',trimmedline);
      inc(I);
    end
    else if pos('(', TrimmedLine) > 0 then
    begin
      Command := ParseCommand(TrimmedLine);
      // Process the command (e.g., execute or store it)
    Writeln('Command: ', Command.Command);
      // writeln('Params raw: '+command.parameters[0]);
       Writeln('Parameters: ', string.Join(', ', Command.Parameters));
      inc(I);
    end
    else if pos(':=', TrimmedLine) > 0 then
    begin
      // Handle variable assignments
      // Example: variable := value
      // You can split the line into variable name and value
      inc(I);
    end
    else if pos('call', TrimmedLine) > 0 then
    begin
      // Writeln('Procedure call: ' + TrimmedLine);
      Command := ParseCommand(TrimmedLine);
      inc(I);
    end
    else
    begin
      // Handle other statements (e.g., expressions, commands)
      writeln('Other code ', TrimmedLine);
      inc(I);
    end;
  end;
end;

function TScript.ParseExpression(const Expr: string): string;
begin
  // Placeholder for expression parsing logic
  // This could involve evaluating arithmetic, logical, or comparison expressions
  Result := Expr; // For now, just return the expression as-is
end;

function TScript.ParseCondition(const Condition: string): string;
begin
  // Placeholder for condition parsing logic
  // This could involve evaluating logical or comparison conditions
  Result := Condition; // For now, just return the condition as-is
end;

function ExtractFunctionParams(const Input: string): string;
var
  OpenParen, CloseParen: Integer;
begin
  OpenParen := pos('(', Input);
  if OpenParen = 0 then
    Exit('');

  CloseParen := Length(Input); // Default to the end
  while (CloseParen > OpenParen) and (Input[CloseParen] <> ')') do
    dec(CloseParen);

  if CloseParen > OpenParen then
    Result := Copy(Input, OpenParen + 1, CloseParen - OpenParen - 1)
  else
    Result := '';
end;

function ParseParameters(const Input: string): TArray<string>;
var
  I: Integer;
  InQuotes: Boolean;
  Params: TArray<string>;
  Param: string;
begin
  InQuotes := False;
  SetLength(Params, 0);
  Param := '';

  for I := 1 to Length(Input) do
  begin
    case Input[I] of
      '"':
        InQuotes := not InQuotes;
      ',':
        if not InQuotes then
        begin
          Param := Trim(Param);
          SetLength(Params, Length(Params) + 1);
          Params[High(Params)] := Param;
          Param := '';
          Continue;
        end;
    end;
    Param := Param + Input[I];
  end;

  Param := Trim(Param);
  if Param <> '' then
  begin
    SetLength(Params, Length(Params) + 1);
    Params[High(Params)] := Param;
  end;

  Result := Params;
end;

function TScript.ParseCommand(const Line: string): TScriptCommand;
var
  CommandStr: string;
  ParamStr: string;
  ParamTemp: string;
  FinalParam: string;
  I: Integer;
  parencount: Integer;
  OpenParenPos: Integer;
  CloseParenPos: Integer;
begin
  // writeln('Parse command ',line);
  OpenParenPos := pos('(', Line);
  CloseParenPos := pos(')', Line);
  if pos('call', Line) <> 0 then
  begin
    Result.Command := 'call';
    ParamStr := Copy(Line, 5, Length(Line) - 2);
    // Writeln('procedure call ' + ParamStr);
    Result.Parameters := SplitParameters(ParamStr);

    Data_AddCommand(CurrentProcedure.Name, Result.Command, Result.Parameters);
  end;
  if (OpenParenPos > 0) and (CloseParenPos > OpenParenPos) then
  begin
    CommandStr := Trim(Copy(Line, 1, OpenParenPos - 1));
    if pos('+', Line) <> 0 then
    begin
      ParamStr := Copy(Line, OpenParenPos + 1, CloseParenPos);
      ParamTemp := ParamStr;
      FinalParam := ExtractFunctionParams(Line);
      ParamStr := FinalParam;
      Result.Command := CommandStr;
    end
    else if pos('))', Line) <> 0 then
    begin
      ParamStr := Copy(Line, OpenParenPos + 1, CloseParenPos);
      ParamTemp := ParamStr;
      FinalParam := ExtractFunctionParams(Line);
      ParamStr := FinalParam;
      Result.Command := CommandStr;
    end
    else
    begin
      // writeln('parsing command: ',commandstr);
      ParamStr := Trim(Copy(Line, OpenParenPos + 1,
        CloseParenPos - OpenParenPos - 1));
      Result.Command := CommandStr;

    end;

    Result.Parameters := ParseParameters(ParamStr);
    Data_AddCommand(CurrentProcedure.Name, Result.Command, Result.Parameters);
  end
  else
  begin
    Result.Command := Line;
    Result.Parameters := [];
  end;
end;

function TScript.SplitParameters(const ParamStr: string): TArray<string>;
var
  Params: TStringList;
  I: Integer;
begin
  Params := TStringList.Create;
  try
    Params.Delimiter := ',';
    Params.StrictDelimiter := True;
    Params.DelimitedText := ParamStr;

    SetLength(Result, Params.Count);
    for I := 0 to Params.Count - 1 do
    begin
      Result[I] := Trim(Params[I]);
    end;
  finally
    Params.Free;
  end;
end;

function TScript.ParseIfStatement(var Index: Integer;
  ProcedureBody: TStringList): TScriptIfStatement;
var
  Line: string;
  lineafterif: string;
  TrimmedLine: string;
  BeginCount: Integer;
begin
  // Extract the condition
  Line := ProcedureBody[Index];
  Result.Condition := Copy(Line, pos('if ', Line) + 3,
    pos(' then', Line) - (pos('if ', Line) + 3));
  writeln('Extracted condition: ', Result.Condition);
  Result.ThenBlock := TStringList.Create;
  Result.ElseBlock := TStringList.Create;

  // Move to the next line after "if ... then"
  inc(Index);

  // Parse the "then" block
  BeginCount := 0;
  while Index < ProcedureBody.Count do
  begin
    Line := ProcedureBody[Index];
    TrimmedLine := Trim(Line);

    if TrimmedLine = 'begin' then
    begin
      // writeln('Encountered begin!');
      inc(BeginCount);
    end
    else if TrimmedLine = 'end' then
    begin
      // writeln('Encountered end!');
      dec(BeginCount);
      if BeginCount = 0 then
        Break;
    end
    else if (TrimmedLine = 'else') and (BeginCount = 0) then
    begin
      // Handle the "else" block
      // writeln('trimmedline else: ',trimmedline);
      inc(Index);
      while Index < ProcedureBody.Count do
      begin
        Line := ProcedureBody[Index];
        TrimmedLine := Trim(Line);

        if TrimmedLine = 'begin' then
        begin
          // writeln('Enountered begin!');
          inc(BeginCount);
        end
        else if TrimmedLine = 'end' then
        begin
          dec(BeginCount);
          if BeginCount = 0 then
            Break;
        end;
        // writeln('Elseblock: ',line);
        // AddCustomCodeToNode(CurrentProcedure.name, line,'',false);
        Result.ElseBlock.Add(Line);
        inc(Index);
      end;
      Break;
    end;
    writeln('adding to then block: ',line);
    Result.ThenBlock.Add(Line);
    inc(Index);
  end;
end;

function TScript.EvaluateExpression(const Expr: string): string;
begin
  // Placeholder for expression evaluation logic
  // This could involve evaluating arithmetic, logical, or comparison expressions
  Result := Expr; // For now, just return the expression as-is
end;

function TScript.EvaluateFunctionCall(const FuncCall: string): string;
var
  FuncName: string;
  FuncParams: string;
  OpenParenPos: Integer;
  CloseParenPos: Integer;
begin
  OpenParenPos := pos('(', FuncCall);
  CloseParenPos := pos(')', FuncCall);

  FuncName := Copy(FuncCall, 1, OpenParenPos - 1);
  FuncParams := Copy(FuncCall, OpenParenPos + 1,
    CloseParenPos - OpenParenPos - 1);

  // Handle specific function calls
  if FuncName = 'mstr' then
  begin
    // Example: mstr(109) -> Return a message string
    Result := 'Message ' + FuncParams;
  end
  else if FuncName = 'obj_name' then
  begin
    // Example: obj_name(dude_obj) -> Return the name of the object
    Result := 'Object Name: ' + FuncParams;
  end
  else
  begin
    // Default case: return the function call as-is
    Result := FuncCall;
  end;
end;

function TScript.ParseFunctionCallsInCommand(const Command: string): string;
var
  TempStr: string;
  FuncCall: string;
  OpenParenPos: Integer;
  CloseParenPos: Integer;
begin
  TempStr := Command;
  Result := '';

  while TempStr <> '' do
  begin
    OpenParenPos := pos('(', TempStr);
    CloseParenPos := pos(')', TempStr);

    if (OpenParenPos > 0) and (CloseParenPos > OpenParenPos) then
    begin
      // Extract the function call
      FuncCall := Copy(TempStr, OpenParenPos, CloseParenPos - OpenParenPos + 1);

      // Evaluate the function call
      Result := Result + EvaluateFunctionCall(FuncCall);

      // Remove the processed part from the string
      Delete(TempStr, 1, CloseParenPos);
    end
    else
    begin
      // Handle non-function parts (e.g., literals, variables)
      Result := Result + TempStr;
      Break;
    end;
  end;
end;

function ExtractConditionManual(const Input: string): string;
var
  StartPos, EndPos: Integer;
begin
  StartPos := pos('if (', Input);
  if StartPos = 0 then
    Exit('');

  StartPos := StartPos + 4; // Move past 'if ('
  EndPos := pos(') then', Input);

  if (EndPos > StartPos) then
    Result := Trim(Copy(Input, StartPos, EndPos - StartPos))
  else
    Result := '';
end;

procedure TScript.ParseCommands(Block: TStringList; condition: string);
var
  I: Integer;
  Line: string;
  TrimmedLine: string;
  ConditionLine: string;
  Command: TScriptCommand;
begin

if block.count>2 then
begin
//writeln('Conditional block:');
//writeln(block.text);
Data_AddCommand(currentprocedure.name,'begin',[], condition);

end;
  for I := 0 to Block.Count - 1 do
  begin
    Line := Block[I];
    TrimmedLine := Trim(Line);
    // writeln('line: ',line);
    // Skip empty lines and comments
    if (TrimmedLine = '') or (TrimmedLine.StartsWith('//')) then
      Continue;

    // Parse commands
    if (pos('(', TrimmedLine) > 0) and (pos('if', TrimmedLine) = 0) then
    begin
      Command := ParseCommand(TrimmedLine);
      // Process the command (e.g., execute or store it)

    end
    else if pos('if', TrimmedLine) > 0 then
    begin
      ConditionLine := ExtractConditionManual(TrimmedLine);
      Data_AddCondition(CurrentProcedure.Name, ConditionLine);
      Continue;
    end
    else if (pos('else', TrimmedLine) <> 0) then
    begin
      // writeln('Else part');
      // writeln('line = ',trimmedline);
      AddCustomCodeToNode(CurrentProcedure.Name, ' else ', '', False);
      Data_AddElsePart(CurrentProcedure.Name);
    end
    else if pos(':=', TrimmedLine) > 0 then
    begin
      // Handle variable assignments
      // Example: variable := value
      // You can split the line into variable name and value
    end
    else
    begin
      // Handle other statements (e.g., expressions, commands)
    end;
  end;

 if block.count>2 then
begin
Data_AddCommand(currentprocedure.name,'end',[]);
end;

  end;

end.
