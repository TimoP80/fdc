unit GVarParse;




{ GVarParse
  Version: 1.0 Release 0 Build 0
  Global Variables parser
  Date of Generation: 12.6.2008 13:57
  Author: T. Pitkänen
  (c) 2008 T. Pitkänen

  This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
  this file that you edit manually will be over-written when the file is
  regenerated.
}

interface

uses  SysUtils, Classes, CocoBase;

const
  maxT = 11;

type
  GVAR = record
    Name:  string;
    Value: integer;
  end;

  SymbolSet = array[0..maxT div setsize] of TBitSet;

  EGVarParse = class(Exception);
  TGVarParse = class;

  TGVarParseScanner = class(TCocoRScanner)
  private
    FOwner:           TGVarParse;
    fLastCommentList: TCommentList;
    procedure CheckLiteral(var Sym: integer);
    function Equal(s: ansistring): boolean;
    function Comment: boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;
    destructor Destroy; override;

    procedure Get(var sym: integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner: TGVarParse Read fOwner Write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TGVarParseScanner }

  TGVarParse = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet: array[0..0] of SymbolSet; // symSet[0] = allSyncSyms
    fInternalGrammarComment: TCommentEvent;

    function GetMajorVersion: integer;
    function GetMinorVersion: integer;
    function GetRelease: integer;
    function GetBuild: integer;
    function GetBuildDate: TDateTime;
    function GetVersionComment: string;
    function GetGrammarAuthor: string;
    function GetGrammarCopyright: string;
    function GetVersion: string;
    procedure SetVersion(const Value: string);
    function _In(var s: SymbolSet; x: integer): boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _VarDefinition;
    procedure _GVarParse;

  private
    fOutputStream:   TMemoryStream;
    fSubSelectDepth: integer;
    fInNaturalJoin:  boolean;

    procedure Init;
    procedure Final;

    property OutputStream: TMemoryStream Read fOutputStream Write fOutputStream;

  protected
    { Protected Declarations }
    procedure Get; override;
    property InternalGrammarComment: TCommentEvent
      Read fInternalGrammarComment Write fInternalGrammarComment;
  public
    { Public Declarations }
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode: integer; const Data: ansistring): ansistring; override;
    procedure Execute;
    function GetScanner: TGVarParseScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property MajorVersion: integer Read GetMajorVersion;
    property MinorVersion: integer Read GetMinorVersion;
    property Release: integer Read GetRelease;
    property Build: integer Read GetBuild;
    property BuildDate: TDateTime Read GetBuildDate;
    property VersionComment: string Read GetVersionComment;
    property GrammarAuthor: string Read GetGrammarAuthor;
    property GrammarCopyright: string Read GetGrammarCopyright;

  published
    { Published Declarations }
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
    property Version: string Read GetVersion Write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TGVarParse }

var
  gvars:     array of ^gvar;
  gvarcount: integer;

implementation



const

  EOFSYMB = 0;
  identifierSym = 1;
  numberSym = 2;
  hexnumberSym = 3;
  stringSym = 4;
  charSym = 5;
  librarySym = 6;
  GAME_underscoreGLOBAL_underscoreVARSSym = 7;
  _colonSym = 8;
  _colon_equalSym = 9;
  _semicolonSym = 10;
  NOSYMB  = 11;
  _noSym  = NOSYMB;   {error token code}

 { --------------------------------------------------------------------------- }
 { Arbitrary Code from ATG file }
const
  PadLen = 20;

function PadR(S: string; Ch: char; L: integer): string;
var
  i: integer;
begin
  for i := 1 to L - (Length(s)) do
    s := s + Ch;
  Result := s;
end;

procedure TGVarParse.Init;
begin
  OutputStream.Clear;

end;

procedure TGVarParse.Final;
begin
  OutputStream.Position := 0;
  OutputStream.SaveToStream(ListStream);
  OutputStream.Clear;
end;




(* End of Arbitrary Code *)



 { --------------------------------------------------------------------------- }
 { ---- implementation for TGVarParseScanner ---- }

procedure TGVarParseScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  SrcStream.Seek(BufferPosition, soFromBeginning);
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) or ((CurrInputCh = _LF) and (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    StartOfLine := BufferPosition;
  end;
end;  {NextCh}

function TGVarParseScanner.Comment: boolean;
var
  level: integer;
  CommentColumn: integer;
  CommentLine: integer;
  startLine: integer;
  oldLineStart: longint;
  CommentStr: string;
begin
  level  := 1;
  startLine := CurrLine;
  oldLineStart := StartOfLine;
  CommentStr := CharAt(BufferPosition);
  CommentColumn := BufferPosition - StartOfLine - 1;
  CommentLine := CurrLine;
  Result := False;
  if (CurrInputCh = '/') then
  begin
    NextCh;
    CommentStr := CommentStr + CharAt(BufferPosition);
    if (CurrInputCh = '/') then
    begin
      NextCh;
      CommentStr := CommentStr + CharAt(BufferPosition);
      while True do
      begin
        if (CurrInputCh = CHR(13)) then
        begin
          level := level - 1;
          NumEOLInComment := CurrLine - startLine;
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
          if level = 0 then
          begin
            Result := True;
            fLastCommentList.Add(CommentStr, CommentLine, CommentColumn);
            Exit;
          end;
        end
        else if CurrInputCh = _EF then
        begin
          Result := False;
          fLastCommentList.Add(CommentStr, CommentLine, CommentColumn);
          Exit;
        end
        else
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
        end;
      end; { WHILE TRUE }
    end
    else
    begin
      if (CurrInputCh = _CR) or (CurrInputCh = _LF) then
      begin
        CurrLine := CurrLine - 1;
        StartOfLine := oldLineStart;
      end;
      BufferPosition := BufferPosition - 1;
      CurrInputCh := LastInputCh;
      Result := False;
    end;
  end;
end;  { Comment }

function TGVarParseScanner.Equal(s: ansistring): boolean;
var
  i: integer;
  q: longint;
begin
  if NextSymbol.Len <> Length(s) then
  begin
    Result := False;
    EXIT;
  end;
  i := 1;
  q := bpCurrToken;
  while i <= NextSymbol.Len do
  begin
    if CurrentCh(q) <> s[i] then
    begin
      Result := False;
      EXIT;
    end;
    Inc(i);
    Inc(q);
  end;
  Result := True;
end;  {Equal}

procedure TGVarParseScanner.CheckLiteral(var Sym: integer);
begin
  case CurrentCh(bpCurrToken) of
    'G': if Equal('GAME_GLOBAL_VARS') then
      begin
        sym := GAME_underscoreGLOBAL_underscoreVARSSym;
      end;

    else
    begin
    end
  end;
end; {CheckLiteral}


procedure TGVarParseScanner.Get(var sym: integer);
var
  state: integer;
begin   {Get}
  while (CurrInputCh = ' ') or ((CurrInputCh >= CHR(1)) and (CurrInputCh <= ' ')) do
    NextCh;
  if ((CurrInputCh = '/')) and Comment then
  begin
    Get(sym);
    exit;
  end;
  CurrentSymbol.pos := NextSymbol.Pos;
  NextSymbol.Pos := BufferPosition;
  CurrentSymbol.col := NextSymbol.Col;
  NextSymbol.Col := BufferPosition - StartOfLine;
  CurrentSymbol.line := NextSymbol.Line;
  NextSymbol.Line := CurrLine;
  CurrentSymbol.Len := NextSymbol.Len;
  NextSymbol.Len := 0;
  ContextLen := 0;
  state := StartState[Ord(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while True do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit;
    end;
    case state of
      1: if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or
          (CurrInputCh >= 'A') and (CurrInputCh <= 'Z') or (CurrInputCh = '_')) then
        begin

        end
        else
        begin
          sym := identifierSym;
          CheckLiteral(sym);
          exit;
        end;
      2: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 3;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      3: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else if ((CurrInputCh = 'L') or (CurrInputCh = 'U')) then
        begin
          state := 17;
        end
        else if (CurrInputCh = '.') then
        begin
          state := 4;
        end
        else
        begin
          sym := numberSym;
          exit;
        end;
      4: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else if ((CurrInputCh = 'L') or (CurrInputCh = 'U')) then
        begin
          state := 17;
        end
        else
        begin
          sym := numberSym;
          exit;
        end;
      5: if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or
          (CurrInputCh >= 'A') and (CurrInputCh <= 'F')) then
        begin
          state := 6;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      6: if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or
          (CurrInputCh >= 'A') and (CurrInputCh <= 'F')) then
        begin

        end
        else if ((CurrInputCh = 'L') or (CurrInputCh = 'U')) then
        begin
          state := 18;
        end
        else
        begin
          sym := hexnumberSym;
          exit;
        end;
      7: if ((CurrInputCh >= ' ') and (CurrInputCh <= '!') or (CurrInputCh >= '#')) then
        begin
          state := 8;
        end
        else if (CurrInputCh = '"') then
        begin
          state := 9;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      8: if ((CurrInputCh >= ' ') and (CurrInputCh <= '!') or (CurrInputCh >= '#')) then
        begin

        end
        else if (CurrInputCh = '"') then
        begin
          state := 9;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      9:
      begin
        sym := stringSym;
        exit;
      end;
      10: if ((CurrInputCh >= ' ') and (CurrInputCh <= '&') or
          (CurrInputCh >= '(') and (CurrInputCh <= '[') or (CurrInputCh >= ']')) then
        begin
          state := 11;
        end
        else if (CurrInputCh = '\') then
        begin
          state := 19;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      11: if (CurrInputCh = CHR(39)) then
        begin
          state := 12;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      12:
      begin
        sym := charSym;
        exit;
      end;
      13: if ((CurrInputCh = '.') or (CurrInputCh >= '0') and
          (CurrInputCh <= ':') or (CurrInputCh >= 'A') and (CurrInputCh <= 'Z') or
          (CurrInputCh = '\')) then
        begin
          state := 14;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      14: if ((CurrInputCh = '.') or (CurrInputCh >= '0') and
          (CurrInputCh <= ':') or (CurrInputCh >= 'A') and (CurrInputCh <= 'Z') or
          (CurrInputCh = '\')) then
        begin

        end
        else if (CurrInputCh = '>') then
        begin
          state := 15;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      15:
      begin
        sym := librarySym;
        exit;
      end;
      16: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 3;
        end
        else if ((CurrInputCh = 'L') or (CurrInputCh = 'U')) then
        begin
          state := 17;
        end
        else if (CurrInputCh = '.') then
        begin
          state := 4;
        end
        else if (CurrInputCh = 'X') then
        begin
          state := 5;
        end
        else
        begin
          sym := numberSym;
          exit;
        end;
      17:
      begin
        sym := numberSym;
        exit;
      end;
      18:
      begin
        sym := hexnumberSym;
        exit;
      end;
      19: if ((CurrInputCh >= ' ') and (CurrInputCh <= '&') or (CurrInputCh >= '(')) then
        begin
          state := 11;
        end
        else if (CurrInputCh = CHR(39)) then
        begin
          state := 12;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      20: if (CurrInputCh = '=') then
        begin
          state := 21;
        end
        else
        begin
          sym := _colonSym;
          exit;
        end;
      21:
      begin
        sym := _colon_equalSym;
        exit;
      end;
      22:
      begin
        sym := _semicolonSym;
        exit;
      end;
      23:
      begin
        sym := EOFSYMB;
        CurrInputCh := #0;
        BufferPosition := BufferPosition - 1;
        exit;
      end;
      else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TGVarParseScanner.Create;
begin
  inherited;
  fLastCommentList := TCommentList.Create;
  CurrentCh := CapChAt;
  fStartState[0] := 23;
  fStartState[1] := 24;
  fStartState[2] := 24;
  fStartState[3] := 24;
  fStartState[4] := 24;
  fStartState[5] := 24;
  fStartState[6] := 24;
  fStartState[7] := 24;
  fStartState[8] := 24;
  fStartState[9] := 24;
  fStartState[10] := 24;
  fStartState[11] := 24;
  fStartState[12] := 24;
  fStartState[13] := 24;
  fStartState[14] := 24;
  fStartState[15] := 24;
  fStartState[16] := 24;
  fStartState[17] := 24;
  fStartState[18] := 24;
  fStartState[19] := 24;
  fStartState[20] := 24;
  fStartState[21] := 24;
  fStartState[22] := 24;
  fStartState[23] := 24;
  fStartState[24] := 24;
  fStartState[25] := 24;
  fStartState[26] := 24;
  fStartState[27] := 24;
  fStartState[28] := 24;
  fStartState[29] := 24;
  fStartState[30] := 24;
  fStartState[31] := 24;
  fStartState[32] := 24;
  fStartState[33] := 24;
  fStartState[34] := 7;
  fStartState[35] := 24;
  fStartState[36] := 24;
  fStartState[37] := 24;
  fStartState[38] := 24;
  fStartState[39] := 10;
  fStartState[40] := 24;
  fStartState[41] := 24;
  fStartState[42] := 24;
  fStartState[43] := 24;
  fStartState[44] := 24;
  fStartState[45] := 2;
  fStartState[46] := 24;
  fStartState[47] := 24;
  fStartState[48] := 16;
  fStartState[49] := 3;
  fStartState[50] := 3;
  fStartState[51] := 3;
  fStartState[52] := 3;
  fStartState[53] := 3;
  fStartState[54] := 3;
  fStartState[55] := 3;
  fStartState[56] := 3;
  fStartState[57] := 3;
  fStartState[58] := 20;
  fStartState[59] := 22;
  fStartState[60] := 13;
  fStartState[61] := 24;
  fStartState[62] := 24;
  fStartState[63] := 24;
  fStartState[64] := 24;
  fStartState[65] := 1;
  fStartState[66] := 1;
  fStartState[67] := 1;
  fStartState[68] := 1;
  fStartState[69] := 1;
  fStartState[70] := 1;
  fStartState[71] := 1;
  fStartState[72] := 1;
  fStartState[73] := 1;
  fStartState[74] := 1;
  fStartState[75] := 1;
  fStartState[76] := 1;
  fStartState[77] := 1;
  fStartState[78] := 1;
  fStartState[79] := 1;
  fStartState[80] := 1;
  fStartState[81] := 1;
  fStartState[82] := 1;
  fStartState[83] := 1;
  fStartState[84] := 1;
  fStartState[85] := 1;
  fStartState[86] := 1;
  fStartState[87] := 1;
  fStartState[88] := 1;
  fStartState[89] := 1;
  fStartState[90] := 1;
  fStartState[91] := 24;
  fStartState[92] := 24;
  fStartState[93] := 24;
  fStartState[94] := 24;
  fStartState[95] := 1;
  fStartState[96] := 24;
  fStartState[97] := 24;
  fStartState[98] := 24;
  fStartState[99] := 24;
  fStartState[100] := 24;
  fStartState[101] := 24;
  fStartState[102] := 24;
  fStartState[103] := 24;
  fStartState[104] := 24;
  fStartState[105] := 24;
  fStartState[106] := 24;
  fStartState[107] := 24;
  fStartState[108] := 24;
  fStartState[109] := 24;
  fStartState[110] := 24;
  fStartState[111] := 24;
  fStartState[112] := 24;
  fStartState[113] := 24;
  fStartState[114] := 24;
  fStartState[115] := 24;
  fStartState[116] := 24;
  fStartState[117] := 24;
  fStartState[118] := 24;
  fStartState[119] := 24;
  fStartState[120] := 24;
  fStartState[121] := 24;
  fStartState[122] := 24;
  fStartState[123] := 24;
  fStartState[124] := 24;
  fStartState[125] := 24;
  fStartState[126] := 24;
  fStartState[127] := 24;
  fStartState[128] := 24;
  fStartState[129] := 24;
  fStartState[130] := 24;
  fStartState[131] := 24;
  fStartState[132] := 24;
  fStartState[133] := 24;
  fStartState[134] := 24;
  fStartState[135] := 24;
  fStartState[136] := 24;
  fStartState[137] := 24;
  fStartState[138] := 24;
  fStartState[139] := 24;
  fStartState[140] := 24;
  fStartState[141] := 24;
  fStartState[142] := 24;
  fStartState[143] := 24;
  fStartState[144] := 24;
  fStartState[145] := 24;
  fStartState[146] := 24;
  fStartState[147] := 24;
  fStartState[148] := 24;
  fStartState[149] := 24;
  fStartState[150] := 24;
  fStartState[151] := 24;
  fStartState[152] := 24;
  fStartState[153] := 24;
  fStartState[154] := 24;
  fStartState[155] := 24;
  fStartState[156] := 24;
  fStartState[157] := 24;
  fStartState[158] := 24;
  fStartState[159] := 24;
  fStartState[160] := 24;
  fStartState[161] := 24;
  fStartState[162] := 24;
  fStartState[163] := 24;
  fStartState[164] := 24;
  fStartState[165] := 24;
  fStartState[166] := 24;
  fStartState[167] := 24;
  fStartState[168] := 24;
  fStartState[169] := 24;
  fStartState[170] := 24;
  fStartState[171] := 24;
  fStartState[172] := 24;
  fStartState[173] := 24;
  fStartState[174] := 24;
  fStartState[175] := 24;
  fStartState[176] := 24;
  fStartState[177] := 24;
  fStartState[178] := 24;
  fStartState[179] := 24;
  fStartState[180] := 24;
  fStartState[181] := 24;
  fStartState[182] := 24;
  fStartState[183] := 24;
  fStartState[184] := 24;
  fStartState[185] := 24;
  fStartState[186] := 24;
  fStartState[187] := 24;
  fStartState[188] := 24;
  fStartState[189] := 24;
  fStartState[190] := 24;
  fStartState[191] := 24;
  fStartState[192] := 24;
  fStartState[193] := 24;
  fStartState[194] := 24;
  fStartState[195] := 24;
  fStartState[196] := 24;
  fStartState[197] := 24;
  fStartState[198] := 24;
  fStartState[199] := 24;
  fStartState[200] := 24;
  fStartState[201] := 24;
  fStartState[202] := 24;
  fStartState[203] := 24;
  fStartState[204] := 24;
  fStartState[205] := 24;
  fStartState[206] := 24;
  fStartState[207] := 24;
  fStartState[208] := 24;
  fStartState[209] := 24;
  fStartState[210] := 24;
  fStartState[211] := 24;
  fStartState[212] := 24;
  fStartState[213] := 24;
  fStartState[214] := 24;
  fStartState[215] := 24;
  fStartState[216] := 24;
  fStartState[217] := 24;
  fStartState[218] := 24;
  fStartState[219] := 24;
  fStartState[220] := 24;
  fStartState[221] := 24;
  fStartState[222] := 24;
  fStartState[223] := 24;
  fStartState[224] := 24;
  fStartState[225] := 24;
  fStartState[226] := 24;
  fStartState[227] := 24;
  fStartState[228] := 24;
  fStartState[229] := 24;
  fStartState[230] := 24;
  fStartState[231] := 24;
  fStartState[232] := 24;
  fStartState[233] := 24;
  fStartState[234] := 24;
  fStartState[235] := 24;
  fStartState[236] := 24;
  fStartState[237] := 24;
  fStartState[238] := 24;
  fStartState[239] := 24;
  fStartState[240] := 24;
  fStartState[241] := 24;
  fStartState[242] := 24;
  fStartState[243] := 24;
  fStartState[244] := 24;
  fStartState[245] := 24;
  fStartState[246] := 24;
  fStartState[247] := 24;
  fStartState[248] := 24;
  fStartState[249] := 24;
  fStartState[250] := 24;
  fStartState[251] := 24;
  fStartState[252] := 24;
  fStartState[253] := 24;
  fStartState[254] := 24;
  fStartState[255] := 24;
end; {Create}

destructor TGVarParseScanner.Destroy;
begin
  if Assigned(fLastCommentList) then
  begin
    fLastCommentList.Free;
    fLastCommentList := nil;
  end;
  inherited;
end;

 { --------------------------------------------------------------------------- }
 { ---- implementation for TGVarParse ---- }

constructor TGVarParse.Create(AOwner: TComponent);
begin
  inherited;
  Scanner := TGVarParseScanner.Create;
  GetScanner.Owner := self;
  fOutputStream := TMemoryStream.Create;

  InitSymSet;
end; {Create}

destructor TGVarParse.Destroy;
begin
  Scanner.Free;
  fOutputStream.Free;

  inherited;
end; {Destroy}

function TGVarParse.ErrorStr(const ErrorCode: integer; const Data: ansistring): ansistring;
begin
  case ErrorCode of
    0: Result  := 'EOF expected';
    1: Result  := 'identifier expected';
    2: Result  := 'number expected';
    3: Result  := 'hexnumber expected';
    4: Result  := 'string expected';
    5: Result  := 'char expected';
    6: Result  := 'library expected';
    7: Result  := '"GAME_GLOBAL_VARS" expected';
    8: Result  := '":" expected';
    9: Result  := '":=" expected';
    10: Result := '";" expected';
    11: Result := 'not expected';


    else
      if Assigned(OnCustomError) then
        Result := OnCustomError(Self, ErrorCode, Data)
      else
      begin
        Result := 'Error: ' + IntToStr(ErrorCode);
        if Trim(Data) > '' then
          Result := Result + ' (' + Data + ')';
      end;
  end;  {case nr}
end; {ErrorStr}

procedure TGVarParse.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  
  { instigate the compilation }
  if Assigned(BeforeParse) then
    BeforeParse(Self);
  Parse;
  if Assigned(AfterParse) then
    AfterParse(Self);

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) or ((GenListWhen = glOnError) and
    (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful and Assigned(OnSuccess) then
    OnSuccess(Self);
  if (not Successful) and Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TGVarParse.Get;
begin
  repeat

    if GetScanner.fLastCommentList.Count > 0 then
    begin
      if Assigned(fInternalGrammarComment) then
        fInternalGrammarComment(Self, GetScanner.fLastCommentList);
      GetScanner.fLastCommentList.Clear;
    end;

    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
end;  {Get}

function TGVarParse.GetScanner: TGVarParseScanner;
begin
  Result := Scanner as TGVarParseScanner;
end; {GetScanner}

function TGVarParse._In(var s: SymbolSet; x: integer): boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TGVarParse._VarDefinition;
begin
  Expect(identifierSym);
  setlength(gvars, gvarcount + 1);
  New(gvars[gvarcount]);
  gvars[gvarcount].Name := lexstring;

  Expect(_colon_equalSym);
  Expect(numberSym);
  gvars[gvarcount].Value := StrToInt(lexstring);
  Expect(_semicolonSym);
  Inc(gvarcount);
end;

procedure TGVarParse._GVarParse;
begin
  Expect(GAME_underscoreGLOBAL_underscoreVARSSym);
  gvarcount := 0;
  Expect(_colonSym);
  _VarDefinition;
  while (fCurrentInputSymbol = identifierSym) do
  begin
    _VarDefinition;
  end;
  if GetScanner.fLastCommentList.Count > 0 then
  begin
    if Assigned(fInternalGrammarComment) then
      fInternalGrammarComment(Self, GetScanner.fLastCommentList);
    GetScanner.fLastCommentList.Clear;
  end;
end;

function TGVarParse.GetMajorVersion: integer;
begin
  Result := 1;
end;

function TGVarParse.GetMinorVersion: integer;
begin
  Result := 0;
end;

function TGVarParse.GetRelease: integer;
begin
  Result := 0;
end;

function TGVarParse.GetBuild: integer;
begin
  Result := 0;
end;

function TGVarParse.GetBuildDate: TDateTime;
const
  BDate = 39611;
  Hour = 13;
  Min = 57;
begin
  Result := BDate + EncodeTime(Hour, Min, 0, 0);
end;

function TGVarParse.GetVersion: string;
var
  MinorVersionStr: string;
begin
  MinorVersionStr := IntToStr(MinorVersion);
  if (length(MinorVersionStr) > 0) and (MinorVersion > 0) then
    MinorVersionStr := '0' + MinorVersionStr;
  Result := 'Version: ' + IntToStr(MajorVersion) + '.' + MinorVersionStr +
    ' Release ' + IntToStr(Release) + ' Build ' + IntToStr(Build);
end;

function TGVarParse.GetVersionComment: string;
begin
  Result := 'Global Variables parser';
end;

function TGVarParse.GetGrammarAuthor: string;
begin
  Result := 'T. Pitkänen';
end;

function TGVarParse.GetGrammarCopyright: string;
begin
  Result := '(c) 2008 T. Pitkänen';
end;

procedure TGVarParse.SetVersion(const Value: string);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TGVarParse.Parse;
begin
  errDist := minErrDist;
  GetScanner._Reset;
  Get;
  _GVarParse;
end;  {Parse}

procedure TGVarParse.InitSymSet;
begin
  symSet[0, 0] := [EOFSYMB];
end; {InitSymSet}

end { GVarParse }.

