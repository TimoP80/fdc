unit MSGParser;




{ MSGParser
  Version: 0.0 Release 0 Build 0
  Fallout 2 MSG Parser
  Date of Generation: 18.6.2008 19:20
  Author: T. Pitkänen
  (c) 2008 T. Pitkänen

  This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
  this file that you edit manually will be over-written when the file is
  regenerated.
}

interface

uses  Dialogs, SysUtils, Classes, CocoBase, mwStringHashList;

const
  maxT = 9;

type
  SymbolSet = array[0..maxT div setsize] of TBitSet;

  EMSGParser = class(Exception);
  TMSGParser = class;

  TMSGParserScanner = class(TCocoRScanner)
  Private
    FOwner:           TMSGParser;
    fLastCommentList: TCommentList;
    fHashList:        TmwStringHashList;
    function Comment: Boolean;
  Protected
    procedure NextCh; Override;
  Public
    constructor Create;
    destructor Destroy; Override;

    procedure Get(var sym: Integer); Override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner: TMSGParser Read fOwner Write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TMSGParserScanner }

  TMSGParser = class(TCocoRGrammar)
  Private
    { strictly internal variables }
    symSet: array[0..0] of SymbolSet; // symSet[0] = allSyncSyms
    fInternalGrammarComment: TCommentEvent;

    function GetMajorVersion: Integer;
    function GetMinorVersion: Integer;
    function GetRelease: Integer;
    function GetBuild: Integer;
    function GetBuildDate: TDateTime;
    function GetVersionComment: String;
    function GetGrammarAuthor: String;
    function GetGrammarCopyright: String;
    function GetVersion: String;
    procedure SetVersion(const Value: String);
    function _In(var s: SymbolSet; x: Integer): Boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _MSGParser;
    procedure _MSGEntry;

  Private
    fOutputStream:   TMemoryStream;
    fSubSelectDepth: Integer;
    fInNaturalJoin:  Boolean;

    procedure Init;
    procedure Final;
    property OutputStream: TMemoryStream Read fOutputStream Write fOutputStream;

  Protected
    { Protected Declarations }
    procedure Get; Override;
    property InternalGrammarComment: TCommentEvent Read fInternalGrammarComment Write fInternalGrammarComment;
  Public
    { Public Declarations }
    constructor Create(AOwner: TComponent); Override;
    destructor Destroy; Override;

    function ErrorStr(const ErrorCode: Integer; const Data: String): String; Override;
    procedure Execute;
    function GetScanner: TMSGParserScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property MajorVersion: Integer Read GetMajorVersion;
    property MinorVersion: Integer Read GetMinorVersion;
    property Release: Integer Read GetRelease;
    property Build: Integer Read GetBuild;
    property BuildDate: TDateTime Read GetBuildDate;
    property VersionComment: String Read GetVersionComment;
    property GrammarAuthor: String Read GetGrammarAuthor;
    property GrammarCopyright: String Read GetGrammarCopyright;

  Published

  Published
    { Published Declarations }
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
    property Version: String Read GetVersion Write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TMSGParser }

type
  MSGEntry = record
    beforeline_comments: TCommentList;
    add_linebreak: Boolean;
    index:      Integer;
    voicefile:  String;
    messagestr: String;
  end;

type
  MessageFile = record
    msgfilename: String;
    entries:     array of ^MSGEntry;
    entrycnt:    Integer;
  end;

var
  CurrentMessageFile: Messagefile;



implementation



const

  EOFSYMB = 0;
  identifierSym = 1;
  numberSym = 2;
  hexnumberSym = 3;
  _stringSym = 4;
  _msgentrySym = 5;
  charSym = 6;
  librarySym = 7;
  endoflineSym = 8;
  NOSYMB  = 9;
  _noSym  = NOSYMB;   {error token code}

 { --------------------------------------------------------------------------- }
 { Arbitrary Code from ATG file }

const
  PadLen = 20;



function PadR(S: String; Ch: Char; L: Integer): String;
var
  i: Integer;
begin
  for i := 1 to L - (Length(s)) do
    s := s + Ch;
  Result := s;
end;


procedure TMSGParser.Init;
begin
  OutputStream.Clear;

end;

procedure TMSGParser.Final;
begin
  OutputStream.Position := 0;
  OutputStream.SaveToStream(ListStream);
  OutputStream.Clear;
end;

function parse_string(zstr: String): String;
var
  t: Integer;
var
  temp: String;
var
  len: Integer;
begin
  ;
  Result := '';
  len := 0;
  temp := '';
  //writeln ('Parsing string: ',zstr);
  t := pos('{', zstr) + 1;
  len := length(zstr);
  while (zstr[t] <> '}') do
  begin
    ;
    //writeln (zstr[t]);

    temp := temp + zstr[t];

    Inc(t);
  end;
  Result := temp;
end;



(* End of Arbitrary Code *)



 { --------------------------------------------------------------------------- }
 { ---- implementation for TMSGParserScanner ---- }

procedure TMSGParserScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  SrcStream.Seek(BufferPosition, soFromBeginning);
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) or ((CurrInputCh = _LF) and (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, IntToStr(CurrLine), CurrLine);
    StartOfLine := BufferPosition;
  end;
end;  {NextCh}

function TMSGParserScanner.Comment: Boolean;
var
  level: Integer;
  CommentColumn: Integer;
  CommentLine: Integer;
  startLine: Integer;
  oldLineStart: Longint;
  CommentStr: String;
begin
  level  := 1;
  startLine := CurrLine;
  oldLineStart := StartOfLine;
  CommentStr := CharAt(BufferPosition);
  CommentColumn := BufferPosition - StartOfLine - 1;
  CommentLine := CurrLine;
  Result := False;
  if (CurrInputCh = '#') then
  begin
    NextCh;
    CommentStr := CommentStr + CharAt(BufferPosition);
    while True do
    begin
      if (CurrInputCh = CHR(13)) then
      begin
        level := level - 1;
        NumEOLInComment := CurrLine - startLine;
        NextCh;
        CommentStr := CommentStr + CharAt(BufferPosition);
        if level = 0 then
        begin
          Result := True;
          fLastCommentList.Add(CommentStr, CommentLine, CommentColumn);
          Exit;
        end;
      end
      else if CurrInputCh = _EF then
      begin
        Result := False;
        fLastCommentList.Add(CommentStr, CommentLine, CommentColumn);
        Exit;
      end
      else
      begin
        NextCh;
        CommentStr := CommentStr + CharAt(BufferPosition);
      end;
    end; { WHILE TRUE }
  end;
end;  { Comment }


procedure TMSGParserScanner.Get(var sym: Integer);
var
  state: Integer;
  breakcnt: integer;
begin   {Get}
breakcnt:=0;
  while (CurrInputCh = ' ') or ((CurrInputCh >= CHR(1)) and (CurrInputCh <= ' ')) do
  begin
    if currinputch = CHR(13) then
    begin
    inc(breakcnt);
      if CurrentMessageFile.entrycnt > 0 then
      begin
    //    ShowMessage('Add linebreak!');
        if breakcnt>1 then
        CurrentMessageFile.entries[CurrentMessageFile.entrycnt].add_linebreak := True;
      end;

    end;
    NextCh;
  end;
  if ((CurrInputCh = '#')) and Comment then
  begin
    Get(sym);
    exit;
  end;
  CurrentSymbol.pos := NextSymbol.Pos;
  NextSymbol.Pos := BufferPosition;
  CurrentSymbol.col := NextSymbol.Col;
  NextSymbol.Col := BufferPosition - StartOfLine;
  CurrentSymbol.line := NextSymbol.Line;
  NextSymbol.Line := CurrLine;
  CurrentSymbol.Len := NextSymbol.Len;
  NextSymbol.Len := 0;
  ContextLen := 0;
  state := StartState[Ord(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while True do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit;
    end;
    case state of
      1: if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or (CurrInputCh >= 'A') and (CurrInputCh <= 'Z') or (CurrInputCh = '_')) then
        begin

        end
        else
        begin
          sym := identifierSym;
          exit;
        end;
      2: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else if ((CurrInputCh = 'L') or (CurrInputCh = 'U')) then
        begin
          state := 18;
        end
        else if (CurrInputCh = '.') then
        begin
          state := 3;
        end
        else
        begin
          sym := numberSym;
          exit;
        end;
      3: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else if ((CurrInputCh = 'L') or (CurrInputCh = 'U')) then
        begin
          state := 18;
        end
        else
        begin
          sym := numberSym;
          exit;
        end;
      4: if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or (CurrInputCh >= 'A') and (CurrInputCh <= 'F')) then
        begin
          state := 5;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      5: if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or (CurrInputCh >= 'A') and (CurrInputCh <= 'F')) then
        begin

        end
        else if ((CurrInputCh = 'L') or (CurrInputCh = 'U')) then
        begin
          state := 19;
        end
        else
        begin
          sym := hexnumberSym;
          exit;
        end;
      6: if ((CurrInputCh >= ' ') and (CurrInputCh <= '!') or (CurrInputCh >= '#')) then
        begin

        end
        else if (CurrInputCh = '"') then
        begin
          state := 7;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      7:
      begin
        sym := _stringSym;
        exit;
      end;
      8: if ((CurrInputCh = CHR(10)) or (CurrInputCh = CHR(13)) or (CurrInputCh >= ' ') and (CurrInputCh <= '"') or
          (CurrInputCh >= '$') and (CurrInputCh <= 'z') or (CurrInputCh = '|') or (CurrInputCh >= '~')) then
        begin
        end
        else if (CurrInputCh = '}') then
        begin
          state := 9;
        end
        else if (CurrInputCh = '#') then
        begin
          state := 20;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      9:
      begin
        sym := _msgentrySym;
        exit;
      end;
      10: if ((CurrInputCh >= ' ') and (CurrInputCh <= '&') or (CurrInputCh >= '(') and (CurrInputCh <= '[') or (CurrInputCh >= ']')) then
        begin
          state := 11;
        end
        else if (CurrInputCh = '\') then
        begin
          state := 21;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      11: if (CurrInputCh = CHR(39)) then
        begin
          state := 12;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      12:
      begin
        sym := charSym;
        exit;
      end;
      13: if ((CurrInputCh = '.') or (CurrInputCh >= '0') and (CurrInputCh <= ':') or (CurrInputCh >= 'A') and
          (CurrInputCh <= 'Z') or (CurrInputCh = '\')) then
        begin
          state := 14;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      14: if ((CurrInputCh = '.') or (CurrInputCh >= '0') and (CurrInputCh <= ':') or (CurrInputCh >= 'A') and
          (CurrInputCh <= 'Z') or (CurrInputCh = '\')) then
        begin

        end
        else if (CurrInputCh = '>') then
        begin
          state := 15;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      15:
      begin
        sym := librarySym;
        exit;
      end;
      16:
      begin
        sym := endoflineSym;
        exit;
      end;
      17: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 2;
        end
        else if ((CurrInputCh = 'L') or (CurrInputCh = 'U')) then
        begin
          state := 18;
        end
        else if (CurrInputCh = '.') then
        begin
          state := 3;
        end
        else if (CurrInputCh = 'X') then
        begin
          state := 4;
        end
        else
        begin
          sym := numberSym;
          exit;
        end;
      18:
      begin
        sym := numberSym;
        exit;
      end;
      19:
      begin
        sym := hexnumberSym;
        exit;
      end;
      20: if ((CurrInputCh = CHR(10)) or (CurrInputCh = CHR(13)) or (CurrInputCh >= ' ') and (CurrInputCh <= '"') or
          (CurrInputCh >= '$') and (CurrInputCh <= 'z') or (CurrInputCh = '|') or (CurrInputCh >= '~')) then
        begin
          state := 8;
        end
        else if (CurrInputCh = '#') then
        begin

        end
        else if (CurrInputCh = '}') then
        begin
          state := 9;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      21: if ((CurrInputCh >= ' ') and (CurrInputCh <= '&') or (CurrInputCh >= '(')) then
        begin
          state := 11;
        end
        else if (CurrInputCh = CHR(39)) then
        begin
          state := 12;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      22:
      begin
        sym := EOFSYMB;
        CurrInputCh := #0;
        BufferPosition := BufferPosition - 1;
        exit;
      end;
      else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TMSGParserScanner.Create;
begin
  inherited;
  fHashList := TmwStringHashList.Create(ITinyHash, HashSecondaryOne, IHashCompare);
  fLastCommentList := TCommentList.Create;
  CurrentCh := CapChAt;
  fStartState[0] := 22;
  fStartState[1] := 23;
  fStartState[2] := 23;
  fStartState[3] := 23;
  fStartState[4] := 23;
  fStartState[5] := 23;
  fStartState[6] := 23;
  fStartState[7] := 23;
  fStartState[8] := 23;
  fStartState[9] := 23;
  fStartState[10] := 23;
  fStartState[11] := 23;
  fStartState[12] := 23;
  fStartState[13] := 16;
  fStartState[14] := 23;
  fStartState[15] := 23;
  fStartState[16] := 23;
  fStartState[17] := 23;
  fStartState[18] := 23;
  fStartState[19] := 23;
  fStartState[20] := 23;
  fStartState[21] := 23;
  fStartState[22] := 23;
  fStartState[23] := 23;
  fStartState[24] := 23;
  fStartState[25] := 23;
  fStartState[26] := 23;
  fStartState[27] := 23;
  fStartState[28] := 23;
  fStartState[29] := 23;
  fStartState[30] := 23;
  fStartState[31] := 23;
  fStartState[32] := 23;
  fStartState[33] := 23;
  fStartState[34] := 6;
  fStartState[35] := 23;
  fStartState[36] := 23;
  fStartState[37] := 23;
  fStartState[38] := 23;
  fStartState[39] := 10;
  fStartState[40] := 23;
  fStartState[41] := 23;
  fStartState[42] := 23;
  fStartState[43] := 23;
  fStartState[44] := 23;
  fStartState[45] := 23;
  fStartState[46] := 23;
  fStartState[47] := 23;
  fStartState[48] := 17;
  fStartState[49] := 2;
  fStartState[50] := 2;
  fStartState[51] := 2;
  fStartState[52] := 2;
  fStartState[53] := 2;
  fStartState[54] := 2;
  fStartState[55] := 2;
  fStartState[56] := 2;
  fStartState[57] := 2;
  fStartState[58] := 23;
  fStartState[59] := 23;
  fStartState[60] := 13;
  fStartState[61] := 23;
  fStartState[62] := 23;
  fStartState[63] := 23;
  fStartState[64] := 23;
  fStartState[65] := 1;
  fStartState[66] := 1;
  fStartState[67] := 1;
  fStartState[68] := 1;
  fStartState[69] := 1;
  fStartState[70] := 1;
  fStartState[71] := 1;
  fStartState[72] := 1;
  fStartState[73] := 1;
  fStartState[74] := 1;
  fStartState[75] := 1;
  fStartState[76] := 1;
  fStartState[77] := 1;
  fStartState[78] := 1;
  fStartState[79] := 1;
  fStartState[80] := 1;
  fStartState[81] := 1;
  fStartState[82] := 1;
  fStartState[83] := 1;
  fStartState[84] := 1;
  fStartState[85] := 1;
  fStartState[86] := 1;
  fStartState[87] := 1;
  fStartState[88] := 1;
  fStartState[89] := 1;
  fStartState[90] := 1;
  fStartState[91] := 23;
  fStartState[92] := 23;
  fStartState[93] := 23;
  fStartState[94] := 23;
  fStartState[95] := 1;
  fStartState[96] := 23;
  fStartState[97] := 23;
  fStartState[98] := 23;
  fStartState[99] := 23;
  fStartState[100] := 23;
  fStartState[101] := 23;
  fStartState[102] := 23;
  fStartState[103] := 23;
  fStartState[104] := 23;
  fStartState[105] := 23;
  fStartState[106] := 23;
  fStartState[107] := 23;
  fStartState[108] := 23;
  fStartState[109] := 23;
  fStartState[110] := 23;
  fStartState[111] := 23;
  fStartState[112] := 23;
  fStartState[113] := 23;
  fStartState[114] := 23;
  fStartState[115] := 23;
  fStartState[116] := 23;
  fStartState[117] := 23;
  fStartState[118] := 23;
  fStartState[119] := 23;
  fStartState[120] := 23;
  fStartState[121] := 23;
  fStartState[122] := 23;
  fStartState[123] := 8;
  fStartState[124] := 23;
  fStartState[125] := 23;
  fStartState[126] := 23;
  fStartState[127] := 23;
  fStartState[128] := 23;
  fStartState[129] := 23;
  fStartState[130] := 23;
  fStartState[131] := 23;
  fStartState[132] := 23;
  fStartState[133] := 23;
  fStartState[134] := 23;
  fStartState[135] := 23;
  fStartState[136] := 23;
  fStartState[137] := 23;
  fStartState[138] := 23;
  fStartState[139] := 23;
  fStartState[140] := 23;
  fStartState[141] := 23;
  fStartState[142] := 23;
  fStartState[143] := 23;
  fStartState[144] := 23;
  fStartState[145] := 23;
  fStartState[146] := 23;
  fStartState[147] := 23;
  fStartState[148] := 23;
  fStartState[149] := 23;
  fStartState[150] := 23;
  fStartState[151] := 23;
  fStartState[152] := 23;
  fStartState[153] := 23;
  fStartState[154] := 23;
  fStartState[155] := 23;
  fStartState[156] := 23;
  fStartState[157] := 23;
  fStartState[158] := 23;
  fStartState[159] := 23;
  fStartState[160] := 23;
  fStartState[161] := 23;
  fStartState[162] := 23;
  fStartState[163] := 23;
  fStartState[164] := 23;
  fStartState[165] := 23;
  fStartState[166] := 23;
  fStartState[167] := 23;
  fStartState[168] := 23;
  fStartState[169] := 23;
  fStartState[170] := 23;
  fStartState[171] := 23;
  fStartState[172] := 23;
  fStartState[173] := 23;
  fStartState[174] := 23;
  fStartState[175] := 23;
  fStartState[176] := 23;
  fStartState[177] := 23;
  fStartState[178] := 23;
  fStartState[179] := 23;
  fStartState[180] := 23;
  fStartState[181] := 23;
  fStartState[182] := 23;
  fStartState[183] := 23;
  fStartState[184] := 23;
  fStartState[185] := 23;
  fStartState[186] := 23;
  fStartState[187] := 23;
  fStartState[188] := 23;
  fStartState[189] := 23;
  fStartState[190] := 23;
  fStartState[191] := 23;
  fStartState[192] := 23;
  fStartState[193] := 23;
  fStartState[194] := 23;
  fStartState[195] := 23;
  fStartState[196] := 23;
  fStartState[197] := 23;
  fStartState[198] := 23;
  fStartState[199] := 23;
  fStartState[200] := 23;
  fStartState[201] := 23;
  fStartState[202] := 23;
  fStartState[203] := 23;
  fStartState[204] := 23;
  fStartState[205] := 23;
  fStartState[206] := 23;
  fStartState[207] := 23;
  fStartState[208] := 23;
  fStartState[209] := 23;
  fStartState[210] := 23;
  fStartState[211] := 23;
  fStartState[212] := 23;
  fStartState[213] := 23;
  fStartState[214] := 23;
  fStartState[215] := 23;
  fStartState[216] := 23;
  fStartState[217] := 23;
  fStartState[218] := 23;
  fStartState[219] := 23;
  fStartState[220] := 23;
  fStartState[221] := 23;
  fStartState[222] := 23;
  fStartState[223] := 23;
  fStartState[224] := 23;
  fStartState[225] := 23;
  fStartState[226] := 23;
  fStartState[227] := 23;
  fStartState[228] := 23;
  fStartState[229] := 23;
  fStartState[230] := 23;
  fStartState[231] := 23;
  fStartState[232] := 23;
  fStartState[233] := 23;
  fStartState[234] := 23;
  fStartState[235] := 23;
  fStartState[236] := 23;
  fStartState[237] := 23;
  fStartState[238] := 23;
  fStartState[239] := 23;
  fStartState[240] := 23;
  fStartState[241] := 23;
  fStartState[242] := 23;
  fStartState[243] := 23;
  fStartState[244] := 23;
  fStartState[245] := 23;
  fStartState[246] := 23;
  fStartState[247] := 23;
  fStartState[248] := 23;
  fStartState[249] := 23;
  fStartState[250] := 23;
  fStartState[251] := 23;
  fStartState[252] := 23;
  fStartState[253] := 23;
  fStartState[254] := 23;
  fStartState[255] := 23;
end; {Create}

destructor TMSGParserScanner.Destroy;
begin
  fHashList.Free;
  fHashList := nil;
  if Assigned(fLastCommentList) then
  begin
    fLastCommentList.Free;
    fLastCommentList := nil;
  end;
  inherited;
end;

 { --------------------------------------------------------------------------- }
 { ---- implementation for TMSGParser ---- }

constructor TMSGParser.Create(AOwner: TComponent);
begin
  inherited;
  Scanner := TMSGParserScanner.Create;
  GetScanner.Owner := self;
  fOutputStream := TMemoryStream.Create;


  InitSymSet;
end; {Create}

destructor TMSGParser.Destroy;
begin
  Scanner.Free;
  fOutputStream.Free;

  inherited;
end; {Destroy}

function TMSGParser.ErrorStr(const ErrorCode: Integer; const Data: String): String;
begin
  case ErrorCode of
    0: Result := 'EOF expected';
    1: Result := 'identifier expected';
    2: Result := 'number expected';
    3: Result := 'hexnumber expected';
    4: Result := '_string expected';
    5: Result := '_msgentry expected';
    6: Result := 'char expected';
    7: Result := 'library expected';
    8: Result := 'endofline expected';
    9: Result := 'not expected';


    else
      if Assigned(OnCustomError) then
        Result := OnCustomError(Self, ErrorCode, Data)
      else
      begin
        Result := 'Error: ' + IntToStr(ErrorCode);
        if Trim(Data) > '' then
          Result := Result + ' (' + Data + ')';
      end;
  end;  {case nr}
end; {ErrorStr}

procedure TMSGParser.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  if Assigned(OnStatusUpdate) then
    OnStatusUpdate(Self, 'parsing source', -1);

  { instigate the compilation }
  if Assigned(BeforeParse) then
    BeforeParse(Self);
  Parse;
  if Assigned(AfterParse) then
    AfterParse(Self);

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) or ((GenListWhen = glOnError) and (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful and Assigned(OnSuccess) then
    OnSuccess(Self);
  if (not Successful) and Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TMSGParser.Get;
begin
  repeat

    if GetScanner.fLastCommentList.Count > 0 then
    begin
      if Assigned(fInternalGrammarComment) then
        fInternalGrammarComment(Self, GetScanner.fLastCommentList);
      GetScanner.fLastCommentList.Clear;
    end;

    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
end;  {Get}

function TMSGParser.GetScanner: TMSGParserScanner;
begin
  Result := Scanner as TMSGParserScanner;
end; {GetScanner}

function TMSGParser._In(var s: SymbolSet; x: Integer): Boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TMSGParser._MSGParser;
begin
  CurrentMessageFile.entrycnt := 0;
  _MSGEntry;
  while (fCurrentInputSymbol = _msgentrySym) do
  begin
    _MSGEntry;
  end;
end;

procedure TMSGParser._MSGEntry;
var
  i: Integer;
begin

  setlength(CurrentMessageFile.entries, CurrentMessageFile.entrycnt + 1);
  new(CurrentMessageFile.entries[CurrentMessageFile.entrycnt]);

  CurrentMessageFile.entries[CurrentMessageFile.entrycnt].beforeline_comments := TCommentList.Create;

  if GetScanner.fLastCommentList.Count > 0 then
  begin
    //     writeln('before  line  comments:  ',  GetScanner.fLastCommentList.Text);
    for  i := 0 to GetScanner.fLastCommentList.Count - 1 do
    begin
      CurrentMessageFile.entries[CurrentMessageFile.entrycnt].beforeline_comments.Add(GetScanner.fLastCommentList.Comments[i],
        GetScanner.fLastCommentList.Line[i], GetScanner.fLastCommentList.Column[i]);
    end;


    if Assigned(fInternalGrammarComment) then
      fInternalGrammarComment(Self, GetScanner.fLastCommentList);
    GetScanner.fLastCommentList.Clear;
  end;



  Expect(_msgentrySym);


  CurrentMessageFile.entries[CurrentMessageFile.entrycnt].index := StrToInt(parse_string(lexstring));




  Expect(_msgentrySym);

  CurrentMessageFile.entries[CurrentMessageFile.entrycnt].voicefile := parse_string(lexstring);



  Expect(_msgentrySym);

  CurrentMessageFile.entries[CurrentMessageFile.entrycnt].messagestr := parse_string(lexstring);
  Inc(currentmessagefile.entrycnt);

end;

function TMSGParser.GetMajorVersion: Integer;
begin
  Result := 0;
end;

function TMSGParser.GetMinorVersion: Integer;
begin
  Result := 0;
end;

function TMSGParser.GetRelease: Integer;
begin
  Result := 0;
end;

function TMSGParser.GetBuild: Integer;
begin
  Result := 0;
end;

function TMSGParser.GetBuildDate: TDateTime;
const
  BDate = 39617;
  Hour = 19;
  Min = 20;
begin
  Result := BDate + EncodeTime(Hour, Min, 0, 0);
end;

function TMSGParser.GetVersion: String;
var
  MinorVersionStr: String;
begin
  MinorVersionStr := IntToStr(MinorVersion);
  if (length(MinorVersionStr) > 0) and (MinorVersion > 0) then
    MinorVersionStr := '0' + MinorVersionStr;
  Result := 'Version: ' + IntToStr(MajorVersion) + '.' + MinorVersionStr + ' Release ' + IntToStr(Release) + ' Build ' + IntToStr(Build);
end;

function TMSGParser.GetVersionComment: String;
begin
  Result := 'Fallout 2 MSG Parser';
end;

function TMSGParser.GetGrammarAuthor: String;
begin
  Result := 'T. Pitkänen';
end;

function TMSGParser.GetGrammarCopyright: String;
begin
  Result := '(c) 2008 T. Pitkänen';
end;

procedure TMSGParser.SetVersion(const Value: String);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TMSGParser.Parse;
begin
  errDist := minErrDist;
  GetScanner._Reset;
  Get;
  _MSGParser;
end;  {Parse}

procedure TMSGParser.InitSymSet;
begin
  symSet[0, 0] := [EOFSYMB];
end; {InitSymSet}

end { MSGParser }.

