unit CodeSnippets;




{ CodeSnippets
  Version: 1.0 Release 0 Build 0
  Global Variables parser
  Date of Generation: 17.6.2008 13:50
  Author: T. Pitkänen
  (c) 2008 T. Pitkänen

  This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
  this file that you edit manually will be over-written when the file is
  regenerated.
}

interface

uses  SysUtils, Classes, CocoBase;

const
  maxT = 27;

type
  SymbolSet = array[0..maxT div setsize] of TBitSet;

  ECodeSnippets = class(Exception);
  TCodeSnippets = class;

  TCodeSnippetsScanner = class(TCocoRScanner)
  Private
    FOwner:           TCodeSnippets;
    fLastCommentList: TCommentList;
    procedure CheckLiteral(var Sym: Integer);
    function Equal(s: String): Boolean;
    function Comment: Boolean;
  Protected
    procedure NextCh; Override;
  Public
    constructor Create;
    destructor Destroy; Override;

    procedure Get(var sym: Integer); Override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner: TCodeSnippets Read fOwner Write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TCodeSnippetsScanner }

  TCodeSnippets = class(TCocoRGrammar)
  Private
    { strictly internal variables }
    symSet: array[0..0] of SymbolSet; // symSet[0] = allSyncSyms
    fInternalGrammarComment: TCommentEvent;

    function GetMajorVersion: Integer;
    function GetMinorVersion: Integer;
    function GetRelease: Integer;
    function GetBuild: Integer;
    function GetBuildDate: TDateTime;
    function GetVersionComment: String;
    function GetGrammarAuthor: String;
    function GetGrammarCopyright: String;
    function GetVersion: String;
    procedure SetVersion(const Value: String);
    function _In(var s: SymbolSet; x: Integer): Boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _CodeSnippets;
    procedure _CodePreset;
    procedure _Params;
    procedure _paramtype;

  Private
    fOutputStream:   TMemoryStream;
    fSubSelectDepth: Integer;
    fInNaturalJoin:  Boolean;

    procedure Final;

    property OutputStream: TMemoryStream Read fOutputStream Write fOutputStream;

  Protected
    { Protected Declarations }
    procedure Get; Override;
    property InternalGrammarComment: TCommentEvent Read fInternalGrammarComment Write fInternalGrammarComment;
  Public
    { Public Declarations }
    constructor Create(AOwner: TComponent); Override;
    destructor Destroy; Override;

    function ErrorStr(const ErrorCode: Integer; const Data: String): String; Override;
    procedure Execute;
    function GetScanner: TCodeSnippetsScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property MajorVersion: Integer Read GetMajorVersion;
    property MinorVersion: Integer Read GetMinorVersion;
    property Release: Integer Read GetRelease;
    property Build: Integer Read GetBuild;
    property BuildDate: TDateTime Read GetBuildDate;
    property VersionComment: String Read GetVersionComment;
    property GrammarAuthor: String Read GetGrammarAuthor;
    property GrammarCopyright: String Read GetGrammarCopyright;

  Published
    { Published Declarations }
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
    property Version: String Read GetVersion Write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TCodeSnippets }

  
const

  PARAM_TYPE_INT  = 1;
  PARAM_TYPE_NODE = 2;
  PARAM_TYPE_BOOL = 3;
  PARAM_TYPE_FLOATNODE = 4;
  PARAM_TYPE_STRING = 5;
  PARAM_TYPE_SKILL = 6;
  PARAM_TYPE_STAT = 7;
  PARAM_TYPE_GVAR = 8;
  PARAM_TYPE_LVAR = 9;
  PARAM_TYPE_SVAR = 10;
  PARAM_TYPE_PID  = 11;
  PARAM_TYPE_MVAR = 12;

type
  Param = record
    ParamType: Integer;
    paramname: String;
    paramdesc: String;

  end;


type
  CodeSnippet = record
    InternalName: String;
    DisplayName: String;
    Params: array [0..32] of ^Param;
    ParamCount: Integer;
    Lines:  String;
  end;

var
  CodeSnippetData: array [0..256] of ^CodeSnippet;

var
  CodeSnippetcnt: Integer;
  tempcodesnippet: CodeSnippet;
  temp_param: param;
function GetParamType(ptype: Integer): String;

implementation



const

  EOFSYMB = 0;
  identifierSym = 1;
  numberSym = 2;
  hexnumberSym = 3;
  _stringSym = 4;
  charSym = 5;
  librarySym = 6;
  INTSym  = 7;
  STRINGSym = 8;
  STATSym = 9;
  BOOLSym = 10;
  SKILLSym = 11;
  PID_underscoreIDSym = 12;
  LOCAL_underscoreVARSym = 13;
  MAP_underscoreVARSym = 14;
  GLOBAL_underscoreVARSym = 15;
  NODESym = 16;
  FLOATNODESym = 17;
  _equalSym = 18;
  CODEPRESETSym = 19;
  _lparenSym = 20;
  _commaSym = 21;
  _rparenSym = 22;
  DESCSym = 23;
  _lbraceSym = 24;
  _rbraceSym = 25;
  _semicolonSym = 26;
  NOSYMB  = 27;
  _noSym  = NOSYMB;   {error token code}

 { --------------------------------------------------------------------------- }
 { Arbitrary Code from ATG file }
const
  PadLen = 20;


function PadR(S: String; Ch: Char; L: Integer): String;
var
  i: Integer;
begin
  for i := 1 to L - (Length(s)) do
    s := s + Ch;
  Result := s;
end;




function GetParamType(ptype: Integer): String;
begin
  Result := 'Unknown';
  case ptype of
    PARAM_TYPE_INT:
      Result := 'Integer';
    PARAM_TYPE_NODE:
      Result := 'NodePTR';
    PARAM_TYPE_BOOL:
      Result := 'Boolean';
    PARAM_TYPE_STRING:
      Result := 'String';
    PARAM_TYPE_FLOATNODE:
      Result := 'FloatNodePTR';
    PARAM_TYPE_GVAR:
      Result := 'Global Var';
    PARAM_TYPE_SVAR:
      Result := 'Script Var';
    PARAM_TYPE_MVAR:
      Result := 'Map Var';
    PARAM_TYPE_LVAR:
      Result := 'Local Var';
    PARAM_TYPE_STAT:
      Result := 'Player Stat';
    PARAM_TYPE_SKILL:
      Result := 'Player Skill';
    PARAM_TYPE_PID:
      Result := 'Item/Critter PID';
  end;

end;



procedure TCodeSnippets.Final;
var
  u, t: Integer;
begin
{$IFDEF ParserBuild}
  writeln('Codesnippets: ', codesnippetcnt);
  for t := 0 to codesnippetcnt - 1 do
  begin;
    writeln('#', t + 1, ': ', codesnippetdata[t].internalname, ' (', codesnippetdata[t].displayname, ')');
    for u := 0 to codesnippetdata[t].ParamCount - 1 do
    begin;
      writeln('   param=', u + 1, ': ', GetParamType(codesnippetdata[t].params[u].ParamType),
        ' ', codesnippetdata[t].params[u].paramname, ' (',
        codesnippetdata[t].params[u].paramdesc, ')');
    end;
    writeln;
    writeln(codesnippetdata[t].Lines);
  end;
{$ENDIF}
  OutputStream.Position := 0;
  OutputStream.SaveToStream(ListStream);
  OutputStream.Clear;
end;



procedure AddCOdeSnippet(Data: codesnippet);
begin
  new(codesnippetdata[codesnippetcnt]);
  codesnippetdata[codesnippetcnt]^ := Data;

  Inc(codesnippetcnt);
end;

function parse_string(zstr: String): String;
var
  t: Integer;
var
  temp: String;
var
  len: Integer;
begin
  Result := '';
  len := 0;
  temp := '';
  //writeln ('Parsing string: ',zstr);
  t := pos('"', zstr) + 1;
  len := length(zstr);
  while (zstr[t] <> '"') do
  begin
    //writeln (zstr[t]);
    if (zstr[t] = '\') and (zstr[t + 1] = '"') then
    begin
      temp := temp + '"';
      Inc(t, 1);
    end else
    if (zstr[t] = '\') and (zstr[t + 1] = '\') then
    begin
      temp := temp + '\';
      Inc(t, 1);
    end else
    if (zstr[t] = '\') and (zstr[t + 1] = 't') then
    begin
      temp := temp + #9;
      Inc(t, 1);
    end else
    if (zstr[t] = '\') and (zstr[t + 1] = 'n') then
    begin
      temp := temp + #13#10;
      Inc(t, 1);
    end else

      temp := temp + zstr[t];

    Inc(t);
  end;
  Result := temp;
end;



(* End of Arbitrary Code *)



 { --------------------------------------------------------------------------- }
 { ---- implementation for TCodeSnippetsScanner ---- }

procedure TCodeSnippetsScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  SrcStream.Seek(BufferPosition, soFromBeginning);
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) or ((CurrInputCh = _LF) and (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, IntToStr(CurrLine), CurrLine);
    StartOfLine := BufferPosition;
  end;
end;  {NextCh}

function TCodeSnippetsScanner.Comment: Boolean;
var
  level: Integer;
  CommentColumn: Integer;
  CommentLine: Integer;
  startLine: Integer;
  oldLineStart: Longint;
  CommentStr: String;
begin
  level  := 1;
  startLine := CurrLine;
  oldLineStart := StartOfLine;
  CommentStr := CharAt(BufferPosition);
  CommentColumn := BufferPosition - StartOfLine - 1;
  CommentLine := CurrLine;
  Result := False;
  if (CurrInputCh = '/') then
  begin
    NextCh;
    CommentStr := CommentStr + CharAt(BufferPosition);
    if (CurrInputCh = '*') then
    begin
      NextCh;
      CommentStr := CommentStr + CharAt(BufferPosition);
      while True do
      begin
        if (CurrInputCh = '*') then
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
          if (CurrInputCh = '/') then
          begin
            level := level - 1;
            NextCh;
            CommentStr := CommentStr + CharAt(BufferPosition);
            if level = 0 then
            begin
              Result := True;
              fLastCommentList.Add(CommentStr, CommentLine, CommentColumn);
              Exit;
            end;
          end;
        end
        else if CurrInputCh = _EF then
        begin
          Result := False;
          fLastCommentList.Add(CommentStr, CommentLine, CommentColumn);
          Exit;
        end
        else
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
        end;
      end; { WHILE TRUE }
    end
    else
    begin
      if (CurrInputCh = _CR) or (CurrInputCh = _LF) then
      begin
        CurrLine := CurrLine - 1;
        StartOfLine := oldLineStart;
      end;
      BufferPosition := BufferPosition - 1;
      CurrInputCh := LastInputCh;
      Result := False;
    end;
  end;
  Result := False;
  if (CurrInputCh = '/') then
  begin
    NextCh;
    CommentStr := CommentStr + CharAt(BufferPosition);
    if (CurrInputCh = '/') then
    begin
      NextCh;
      CommentStr := CommentStr + CharAt(BufferPosition);
      while True do
      begin
        if (CurrInputCh = CHR(13)) then
        begin
          level := level - 1;
          NumEOLInComment := CurrLine - startLine;
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
          if level = 0 then
          begin
            Result := True;
            fLastCommentList.Add(CommentStr, CommentLine, CommentColumn);
            Exit;
          end;
        end
        else if CurrInputCh = _EF then
        begin
          Result := False;
          fLastCommentList.Add(CommentStr, CommentLine, CommentColumn);
          Exit;
        end
        else
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
        end;
      end; { WHILE TRUE }
    end
    else
    begin
      if (CurrInputCh = _CR) or (CurrInputCh = _LF) then
      begin
        CurrLine := CurrLine - 1;
        StartOfLine := oldLineStart;
      end;
      BufferPosition := BufferPosition - 1;
      CurrInputCh := LastInputCh;
      Result := False;
    end;
  end;
end;  { Comment }

function TCodeSnippetsScanner.Equal(s: String): Boolean;
var
  i: Integer;
  q: Longint;
begin
  if NextSymbol.Len <> Length(s) then
  begin
    Result := False;
    EXIT;
  end;
  i := 1;
  q := bpCurrToken;
  while i <= NextSymbol.Len do
  begin
    if CurrentCh(q) <> s[i] then
    begin
      Result := False;
      EXIT;
    end;
    Inc(i);
    Inc(q);
  end;
  Result := True;
end;  {Equal}

procedure TCodeSnippetsScanner.CheckLiteral(var Sym: Integer);
begin
  case CurrentCh(bpCurrToken) of
    'B': if Equal('BOOL') then
      begin
        sym := BOOLSym;
      end;

    'C': if Equal('CODEPRESET') then
      begin
        sym := CODEPRESETSym;
      end;

    'D': if Equal('DESC') then
      begin
        sym := DESCSym;
      end;

    'F': if Equal('FLOATNODE') then
      begin
        sym := FLOATNODESym;
      end;

    'G': if Equal('GLOBAL_VAR') then
      begin
        sym := GLOBAL_underscoreVARSym;
      end;

    'I': if Equal('INT') then
      begin
        sym := INTSym;
      end;

    'L': if Equal('LOCAL_VAR') then
      begin
        sym := LOCAL_underscoreVARSym;
      end;

    'M': if Equal('MAP_VAR') then
      begin
        sym := MAP_underscoreVARSym;
      end;

    'N': if Equal('NODE') then
      begin
        sym := NODESym;
      end;

    'P': if Equal('PID_ID') then
      begin
        sym := PID_underscoreIDSym;
      end;

    'S': if Equal('SKILL') then
      begin
        sym := SKILLSym;
      end
      else if Equal('STAT') then
      begin
        sym := STATSym;
      end
      else if Equal('STRING') then
      begin
        sym := STRINGSym;
      end;

    else
    begin
    end
  end;
end; {CheckLiteral}


procedure TCodeSnippetsScanner.Get(var sym: Integer);
var
  state: Integer;
begin   {Get}
  while (CurrInputCh = ' ') or ((CurrInputCh >= CHR(1)) and (CurrInputCh <= ' ')) do
    NextCh;
  if ((CurrInputCh = '/') or (CurrInputCh = '/')) and Comment then
  begin
    Get(sym);
    exit;
  end;
  CurrentSymbol.pos := NextSymbol.Pos;
  NextSymbol.Pos := BufferPosition;
  CurrentSymbol.col := NextSymbol.Col;
  NextSymbol.Col := BufferPosition - StartOfLine;
  CurrentSymbol.line := NextSymbol.Line;
  NextSymbol.Line := CurrLine;
  CurrentSymbol.Len := NextSymbol.Len;
  NextSymbol.Len := 0;
  ContextLen := 0;
  state := StartState[Ord(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while True do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit;
    end;
    case state of
      1: if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or (CurrInputCh >= 'A') and (CurrInputCh <= 'Z') or (CurrInputCh = '_')) then
        begin

        end
        else
        begin
          sym := identifierSym;
          CheckLiteral(sym);
          exit;
        end;
      2: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 3;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      3: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else if ((CurrInputCh = 'L') or (CurrInputCh = 'U')) then
        begin
          state := 17;
        end
        else if (CurrInputCh = '.') then
        begin
          state := 4;
        end
        else
        begin
          sym := numberSym;
          exit;
        end;
      4: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else if ((CurrInputCh = 'L') or (CurrInputCh = 'U')) then
        begin
          state := 17;
        end
        else
        begin
          sym := numberSym;
          exit;
        end;
      5: if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or (CurrInputCh >= 'A') and (CurrInputCh <= 'F')) then
        begin
          state := 6;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      6: if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or (CurrInputCh >= 'A') and (CurrInputCh <= 'F')) then
        begin

        end
        else if ((CurrInputCh = 'L') or (CurrInputCh = 'U')) then
        begin
          state := 18;
        end
        else
        begin
          sym := hexnumberSym;
          exit;
        end;
      7: if ((CurrInputCh >= ' ') and (CurrInputCh <= '!') or (CurrInputCh >= '#')) then
        begin
          state := 8;
        end
        else if (CurrInputCh = '"') then
        begin
          state := 9;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      8: if ((CurrInputCh >= ' ') and (CurrInputCh <= '!') or (CurrInputCh >= '#')) then
        begin

        end
        else if (CurrInputCh = '"') then
        begin
          state := 9;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      9:
      begin
        sym := _stringSym;
        exit;
      end;
      10: if ((CurrInputCh >= ' ') and (CurrInputCh <= '&') or (CurrInputCh >= '(') and (CurrInputCh <= '[') or (CurrInputCh >= ']')) then
        begin
          state := 11;
        end
        else if (CurrInputCh = '\') then
        begin
          state := 19;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      11: if (CurrInputCh = CHR(39)) then
        begin
          state := 12;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      12:
      begin
        sym := charSym;
        exit;
      end;
      13: if ((CurrInputCh = '.') or (CurrInputCh >= '0') and (CurrInputCh <= ':') or (CurrInputCh >= 'A') and
          (CurrInputCh <= 'Z') or (CurrInputCh = '\')) then
        begin
          state := 14;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      14: if ((CurrInputCh = '.') or (CurrInputCh >= '0') and (CurrInputCh <= ':') or (CurrInputCh >= 'A') and
          (CurrInputCh <= 'Z') or (CurrInputCh = '\')) then
        begin

        end
        else if (CurrInputCh = '>') then
        begin
          state := 15;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      15:
      begin
        sym := librarySym;
        exit;
      end;
      16: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 3;
        end
        else if ((CurrInputCh = 'L') or (CurrInputCh = 'U')) then
        begin
          state := 17;
        end
        else if (CurrInputCh = '.') then
        begin
          state := 4;
        end
        else if (CurrInputCh = 'X') then
        begin
          state := 5;
        end
        else
        begin
          sym := numberSym;
          exit;
        end;
      17:
      begin
        sym := numberSym;
        exit;
      end;
      18:
      begin
        sym := hexnumberSym;
        exit;
      end;
      19: if ((CurrInputCh >= ' ') and (CurrInputCh <= '&') or (CurrInputCh >= '(')) then
        begin
          state := 11;
        end
        else if (CurrInputCh = CHR(39)) then
        begin
          state := 12;
        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      20:
      begin
        sym := _equalSym;
        exit;
      end;
      21:
      begin
        sym := _lparenSym;
        exit;
      end;
      22:
      begin
        sym := _commaSym;
        exit;
      end;
      23:
      begin
        sym := _rparenSym;
        exit;
      end;
      24:
      begin
        sym := _lbraceSym;
        exit;
      end;
      25:
      begin
        sym := _rbraceSym;
        exit;
      end;
      26:
      begin
        sym := _semicolonSym;
        exit;
      end;
      27:
      begin
        sym := EOFSYMB;
        CurrInputCh := #0;
        BufferPosition := BufferPosition - 1;
        exit;
      end;
      else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TCodeSnippetsScanner.Create;
begin
  inherited;
  fLastCommentList := TCommentList.Create;
  CurrentCh := CapChAt;
  fStartState[0] := 27;
  fStartState[1] := 28;
  fStartState[2] := 28;
  fStartState[3] := 28;
  fStartState[4] := 28;
  fStartState[5] := 28;
  fStartState[6] := 28;
  fStartState[7] := 28;
  fStartState[8] := 28;
  fStartState[9] := 28;
  fStartState[10] := 28;
  fStartState[11] := 28;
  fStartState[12] := 28;
  fStartState[13] := 28;
  fStartState[14] := 28;
  fStartState[15] := 28;
  fStartState[16] := 28;
  fStartState[17] := 28;
  fStartState[18] := 28;
  fStartState[19] := 28;
  fStartState[20] := 28;
  fStartState[21] := 28;
  fStartState[22] := 28;
  fStartState[23] := 28;
  fStartState[24] := 28;
  fStartState[25] := 28;
  fStartState[26] := 28;
  fStartState[27] := 28;
  fStartState[28] := 28;
  fStartState[29] := 28;
  fStartState[30] := 28;
  fStartState[31] := 28;
  fStartState[32] := 28;
  fStartState[33] := 28;
  fStartState[34] := 7;
  fStartState[35] := 28;
  fStartState[36] := 28;
  fStartState[37] := 28;
  fStartState[38] := 28;
  fStartState[39] := 10;
  fStartState[40] := 21;
  fStartState[41] := 23;
  fStartState[42] := 28;
  fStartState[43] := 28;
  fStartState[44] := 22;
  fStartState[45] := 2;
  fStartState[46] := 28;
  fStartState[47] := 28;
  fStartState[48] := 16;
  fStartState[49] := 3;
  fStartState[50] := 3;
  fStartState[51] := 3;
  fStartState[52] := 3;
  fStartState[53] := 3;
  fStartState[54] := 3;
  fStartState[55] := 3;
  fStartState[56] := 3;
  fStartState[57] := 3;
  fStartState[58] := 28;
  fStartState[59] := 26;
  fStartState[60] := 13;
  fStartState[61] := 20;
  fStartState[62] := 28;
  fStartState[63] := 28;
  fStartState[64] := 28;
  fStartState[65] := 1;
  fStartState[66] := 1;
  fStartState[67] := 1;
  fStartState[68] := 1;
  fStartState[69] := 1;
  fStartState[70] := 1;
  fStartState[71] := 1;
  fStartState[72] := 1;
  fStartState[73] := 1;
  fStartState[74] := 1;
  fStartState[75] := 1;
  fStartState[76] := 1;
  fStartState[77] := 1;
  fStartState[78] := 1;
  fStartState[79] := 1;
  fStartState[80] := 1;
  fStartState[81] := 1;
  fStartState[82] := 1;
  fStartState[83] := 1;
  fStartState[84] := 1;
  fStartState[85] := 1;
  fStartState[86] := 1;
  fStartState[87] := 1;
  fStartState[88] := 1;
  fStartState[89] := 1;
  fStartState[90] := 1;
  fStartState[91] := 28;
  fStartState[92] := 28;
  fStartState[93] := 28;
  fStartState[94] := 28;
  fStartState[95] := 1;
  fStartState[96] := 28;
  fStartState[97] := 28;
  fStartState[98] := 28;
  fStartState[99] := 28;
  fStartState[100] := 28;
  fStartState[101] := 28;
  fStartState[102] := 28;
  fStartState[103] := 28;
  fStartState[104] := 28;
  fStartState[105] := 28;
  fStartState[106] := 28;
  fStartState[107] := 28;
  fStartState[108] := 28;
  fStartState[109] := 28;
  fStartState[110] := 28;
  fStartState[111] := 28;
  fStartState[112] := 28;
  fStartState[113] := 28;
  fStartState[114] := 28;
  fStartState[115] := 28;
  fStartState[116] := 28;
  fStartState[117] := 28;
  fStartState[118] := 28;
  fStartState[119] := 28;
  fStartState[120] := 28;
  fStartState[121] := 28;
  fStartState[122] := 28;
  fStartState[123] := 24;
  fStartState[124] := 28;
  fStartState[125] := 25;
  fStartState[126] := 28;
  fStartState[127] := 28;
  fStartState[128] := 28;
  fStartState[129] := 28;
  fStartState[130] := 28;
  fStartState[131] := 28;
  fStartState[132] := 28;
  fStartState[133] := 28;
  fStartState[134] := 28;
  fStartState[135] := 28;
  fStartState[136] := 28;
  fStartState[137] := 28;
  fStartState[138] := 28;
  fStartState[139] := 28;
  fStartState[140] := 28;
  fStartState[141] := 28;
  fStartState[142] := 28;
  fStartState[143] := 28;
  fStartState[144] := 28;
  fStartState[145] := 28;
  fStartState[146] := 28;
  fStartState[147] := 28;
  fStartState[148] := 28;
  fStartState[149] := 28;
  fStartState[150] := 28;
  fStartState[151] := 28;
  fStartState[152] := 28;
  fStartState[153] := 28;
  fStartState[154] := 28;
  fStartState[155] := 28;
  fStartState[156] := 28;
  fStartState[157] := 28;
  fStartState[158] := 28;
  fStartState[159] := 28;
  fStartState[160] := 28;
  fStartState[161] := 28;
  fStartState[162] := 28;
  fStartState[163] := 28;
  fStartState[164] := 28;
  fStartState[165] := 28;
  fStartState[166] := 28;
  fStartState[167] := 28;
  fStartState[168] := 28;
  fStartState[169] := 28;
  fStartState[170] := 28;
  fStartState[171] := 28;
  fStartState[172] := 28;
  fStartState[173] := 28;
  fStartState[174] := 28;
  fStartState[175] := 28;
  fStartState[176] := 28;
  fStartState[177] := 28;
  fStartState[178] := 28;
  fStartState[179] := 28;
  fStartState[180] := 28;
  fStartState[181] := 28;
  fStartState[182] := 28;
  fStartState[183] := 28;
  fStartState[184] := 28;
  fStartState[185] := 28;
  fStartState[186] := 28;
  fStartState[187] := 28;
  fStartState[188] := 28;
  fStartState[189] := 28;
  fStartState[190] := 28;
  fStartState[191] := 28;
  fStartState[192] := 28;
  fStartState[193] := 28;
  fStartState[194] := 28;
  fStartState[195] := 28;
  fStartState[196] := 28;
  fStartState[197] := 28;
  fStartState[198] := 28;
  fStartState[199] := 28;
  fStartState[200] := 28;
  fStartState[201] := 28;
  fStartState[202] := 28;
  fStartState[203] := 28;
  fStartState[204] := 28;
  fStartState[205] := 28;
  fStartState[206] := 28;
  fStartState[207] := 28;
  fStartState[208] := 28;
  fStartState[209] := 28;
  fStartState[210] := 28;
  fStartState[211] := 28;
  fStartState[212] := 28;
  fStartState[213] := 28;
  fStartState[214] := 28;
  fStartState[215] := 28;
  fStartState[216] := 28;
  fStartState[217] := 28;
  fStartState[218] := 28;
  fStartState[219] := 28;
  fStartState[220] := 28;
  fStartState[221] := 28;
  fStartState[222] := 28;
  fStartState[223] := 28;
  fStartState[224] := 28;
  fStartState[225] := 28;
  fStartState[226] := 28;
  fStartState[227] := 28;
  fStartState[228] := 28;
  fStartState[229] := 28;
  fStartState[230] := 28;
  fStartState[231] := 28;
  fStartState[232] := 28;
  fStartState[233] := 28;
  fStartState[234] := 28;
  fStartState[235] := 28;
  fStartState[236] := 28;
  fStartState[237] := 28;
  fStartState[238] := 28;
  fStartState[239] := 28;
  fStartState[240] := 28;
  fStartState[241] := 28;
  fStartState[242] := 28;
  fStartState[243] := 28;
  fStartState[244] := 28;
  fStartState[245] := 28;
  fStartState[246] := 28;
  fStartState[247] := 28;
  fStartState[248] := 28;
  fStartState[249] := 28;
  fStartState[250] := 28;
  fStartState[251] := 28;
  fStartState[252] := 28;
  fStartState[253] := 28;
  fStartState[254] := 28;
  fStartState[255] := 28;
end; {Create}

destructor TCodeSnippetsScanner.Destroy;
begin
  if Assigned(fLastCommentList) then
  begin
    fLastCommentList.Free;
    fLastCommentList := nil;
  end;
  inherited;
end;

 { --------------------------------------------------------------------------- }
 { ---- implementation for TCodeSnippets ---- }

constructor TCodeSnippets.Create(AOwner: TComponent);
begin
  inherited;
  Scanner := TCodeSnippetsScanner.Create;
  GetScanner.Owner := self;
  fOutputStream := TMemoryStream.Create;

  InitSymSet;
end; {Create}

destructor TCodeSnippets.Destroy;
begin
  Scanner.Free;
  fOutputStream.Free;

  inherited;
end; {Destroy}

function TCodeSnippets.ErrorStr(const ErrorCode: Integer; const Data: String): String;
begin
  case ErrorCode of
    0: Result  := 'EOF expected';
    1: Result  := 'identifier expected';
    2: Result  := 'number expected';
    3: Result  := 'hexnumber expected';
    4: Result  := '_string expected';
    5: Result  := 'char expected';
    6: Result  := 'library expected';
    7: Result  := '"INT" expected';
    8: Result  := '"STRING" expected';
    9: Result  := '"STAT" expected';
    10: Result := '"BOOL" expected';
    11: Result := '"SKILL" expected';
    12: Result := '"PID_ID" expected';
    13: Result := '"LOCAL_VAR" expected';
    14: Result := '"MAP_VAR" expected';
    15: Result := '"GLOBAL_VAR" expected';
    16: Result := '"NODE" expected';
    17: Result := '"FLOATNODE" expected';
    18: Result := '"=" expected';
    19: Result := '"CODEPRESET" expected';
    20: Result := '"(" expected';
    21: Result := '"," expected';
    22: Result := '")" expected';
    23: Result := '"DESC" expected';
    24: Result := '"{" expected';
    25: Result := '"}" expected';
    26: Result := '";" expected';
    27: Result := 'not expected';
    28: Result := 'invalid paramtype';


    else
      if Assigned(OnCustomError) then
        Result := OnCustomError(Self, ErrorCode, Data)
      else
      begin
        Result := 'Error: ' + IntToStr(ErrorCode);
        if Trim(Data) > '' then
          Result := Result + ' (' + Data + ')';
      end;
  end;  {case nr}
end; {ErrorStr}

procedure TCodeSnippets.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  if Assigned(OnStatusUpdate) then
    OnStatusUpdate(Self, 'parsing source', -1);

  { instigate the compilation }
  if Assigned(BeforeParse) then
    BeforeParse(Self);
  Parse;
  if Assigned(AfterParse) then
    AfterParse(Self);

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) or ((GenListWhen = glOnError) and (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful and Assigned(OnSuccess) then
    OnSuccess(Self);
  if (not Successful) and Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TCodeSnippets.Get;
begin
  repeat

    if GetScanner.fLastCommentList.Count > 0 then
    begin
      if Assigned(fInternalGrammarComment) then
        fInternalGrammarComment(Self, GetScanner.fLastCommentList);
      GetScanner.fLastCommentList.Clear;
    end;

    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
end;  {Get}

function TCodeSnippets.GetScanner: TCodeSnippetsScanner;
begin
  Result := Scanner as TCodeSnippetsScanner;
end; {GetScanner}

function TCodeSnippets._In(var s: SymbolSet; x: Integer): Boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TCodeSnippets._CodeSnippets;
begin
  _CodePreset;
  while (fCurrentInputSymbol = _semicolonSym) do
  begin
    Get;
    _CodePreset;
  end;
  Final;
end;

procedure TCodeSnippets._CodePreset;
begin
  Expect(CODEPRESETSym);
  tempcodesnippet.ParamCount := 0;
  tempcodesnippet.Lines := '';
  Expect(identifierSym);
  tempcodesnippet.internalname := lexstring;
  Expect(_lparenSym);
  _Params;
  new(tempcodesnippet.params[tempcodesnippet.ParamCount]);
  tempcodesnippet.params[tempcodesnippet.ParamCount]^ := temp_param;
  Inc(tempcodesnippet.ParamCount);
  while (fCurrentInputSymbol = _commaSym) do
  begin
    Get;
    _Params;
    new(tempcodesnippet.params[tempcodesnippet.ParamCount]);
    tempcodesnippet.params[tempcodesnippet.ParamCount]^ := temp_param;
    Inc(tempcodesnippet.ParamCount);
  end;
  Expect(_rparenSym);
  Expect(DESCSym);
  Expect(_equalSym);
  Expect(_stringSym);
  tempcodesnippet.displayname := parse_String(lexstring);
  Expect(_lbraceSym);
  Expect(_stringSym);
  tempcodesnippet.Lines := parse_string(lexstring);
  while (fCurrentInputSymbol = _commaSym) do
  begin
    Get;
    Expect(_stringSym);
    tempcodesnippet.Lines := tempcodesnippet.Lines + #13#10 + parse_string(lexstring);
  end;
  Expect(_rbraceSym);
  AddCodeSnippet(tempcodesnippet);
end;

procedure TCodeSnippets._Params;
begin
  _paramtype;
  Expect(identifierSym);
  temp_param.paramname := lexstring;
  Expect(_equalSym);
  Expect(_stringSym);
  temp_param.paramdesc := parse_string(lexstring);
end;

procedure TCodeSnippets._paramtype;
begin
  case fCurrentInputSymbol of
    INTSym:
    begin
      Get;
      temp_param.paramtype := PARAM_TYPE_INT;
    end;
    STRINGSym:
    begin
      Get;
      temp_param.paramtype := PARAM_TYPE_STrING;
    end;
    STATSym:
    begin
      Get;
      temp_param.paramtype := PARAM_TYPE_STAT;
    end;
    BOOLSym:
    begin
      Get;
      temp_param.paramtype := PARAM_TYPE_BOOL;
    end;
    SKILLSym:
    begin
      Get;
      temp_param.paramtype := PARAM_TYPE_SKILL;
    end;
    PID_underscoreIDSym:
    begin
      Get;
      temp_param.paramtype := PARAM_TYPE_PID;
    end;
    LOCAL_underscoreVARSym:
    begin
      Get;
      temp_param.paramtype := PARAM_TYPE_LVAR;
    end;
    MAP_underscoreVARSym:
    begin
      Get;
      temp_param.paramtype := PARAM_TYPE_MVAR;
    end;
    GLOBAL_underscoreVARSym:
    begin
      Get;
      temp_param.paramtype := PARAM_TYPE_GVAR;
    end;
    NODESym:
    begin
      Get;
      temp_param.paramtype := PARAM_TYPE_NODE;
    end;
    FLOATNODESym:
    begin
      Get;
      temp_param.paramtype := PARAM_TYPE_FLOATNODE;
    end;
    else
    begin
      SynError(28);
    end;
  end;
  if GetScanner.fLastCommentList.Count > 0 then
  begin
    if Assigned(fInternalGrammarComment) then
      fInternalGrammarComment(Self, GetScanner.fLastCommentList);
    GetScanner.fLastCommentList.Clear;
  end;
end;

function TCodeSnippets.GetMajorVersion: Integer;
begin
  Result := 1;
end;

function TCodeSnippets.GetMinorVersion: Integer;
begin
  Result := 0;
end;

function TCodeSnippets.GetRelease: Integer;
begin
  Result := 0;
end;

function TCodeSnippets.GetBuild: Integer;
begin
  Result := 0;
end;

function TCodeSnippets.GetBuildDate: TDateTime;
const
  BDate = 39616;
  Hour = 13;
  Min = 50;
begin
  Result := BDate + EncodeTime(Hour, Min, 0, 0);
end;

function TCodeSnippets.GetVersion: String;
var
  MinorVersionStr: String;
begin
  MinorVersionStr := IntToStr(MinorVersion);
  if (length(MinorVersionStr) > 0) and (MinorVersion > 0) then
    MinorVersionStr := '0' + MinorVersionStr;
  Result := 'Version: ' + IntToStr(MajorVersion) + '.' + MinorVersionStr + ' Release ' + IntToStr(Release) + ' Build ' + IntToStr(Build);
end;

function TCodeSnippets.GetVersionComment: String;
begin
  Result := 'Global Variables parser';
end;

function TCodeSnippets.GetGrammarAuthor: String;
begin
  Result := 'T. Pitkänen';
end;

function TCodeSnippets.GetGrammarCopyright: String;
begin
  Result := '(c) 2008 T. Pitkänen';
end;

procedure TCodeSnippets.SetVersion(const Value: String);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TCodeSnippets.Parse;
begin
  errDist := minErrDist;
  GetScanner._Reset;
  Get;
  _CodeSnippets;
end;  {Parse}

procedure TCodeSnippets.InitSymSet;
begin
  symSet[0, 0] := [EOFSYMB];
  symSet[0, 1] := [];
end; {InitSymSet}

end { CodeSnippets }.

