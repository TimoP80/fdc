unit ParseInclude;




{ ParseInclude
  Version: 1.0 Release 0 Build 222
  SSL Include files parser
  Date of Generation: 21.11.2005 18:18
  Author: T. Pitkänen
  (c) 2003 Dj Unique

  This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
  this file that you edit manually will be over-written when the file is
  regenerated.
}

interface
uses  Classes, CocoBase, jclStrings, mwStringHashList, SysUtils, Variants;
const
  maxT      = 18;
type
  SymbolSet = array[0..maxT div setsize] of TBitSet;

  EParseInclude        = class(Exception);
  TParseInclude        = class;

  TParseIncludeScanner = class(TCocoRScanner)
  private
    FOwner:    TParseInclude;
    fHashList: TmwStringHashList;
    procedure CheckLiteral(var Sym: integer);
    function GetNextSymbolString: string;
    function Comment: boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;
    destructor Destroy; override;

    procedure Get(var sym: integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner: TParseInclude Read fOwner Write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TParseIncludeScanner }

  TParseInclude = class(TCocoRGrammar)
  private
        { strictly internal variables }
    symSet: array[0..0] of SymbolSet; // symSet[0] = allSyncSyms

    function GetMajorVersion: integer;
    function GetMinorVersion: integer;
    function GetRelease: integer;
    function GetBuild: integer;
    function GetBuildDate: TDateTime;
    function GetVersionComment: string;
    function GetGrammarAuthor: string;
    function GetGrammarCopyright: string;
    function GetVersion: string;
    procedure SetVersion(const Value: string);
    function _In(var s: SymbolSet; x: integer): boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _Stuff;
    procedure _ParseInclude;

  private
    fOutputStream:   TMemoryStream;
    fSubSelectDepth: integer;
    fInNaturalJoin:  boolean;

    procedure Init;
    procedure Final;
    procedure WriteStr(S: string);
    property OutputStream: TMemoryStream Read fOutputStream Write fOutputStream;
    property SubSelectDepth: integer Read fSubSelectDepth Write fSubSelectDepth;
    property InNaturalJoin: boolean Read fInNaturalJoin Write fInNaturalJoin;

  protected
    { Protected Declarations }
    procedure Get; override;
  public
    { Public Declarations }
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode: integer; const Data: string): string; override;
    procedure Execute;
    function GetScanner: TParseIncludeScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property MajorVersion: integer Read GetMajorVersion;
    property MinorVersion: integer Read GetMinorVersion;
    property Release: integer Read GetRelease;
    property Build: integer Read GetBuild;
    property BuildDate: TDateTime Read GetBuildDate;
    property VersionComment: string Read GetVersionComment;
    property GrammarAuthor: string Read GetGrammarAuthor;
    property GrammarCopyright: string Read GetGrammarCopyright;

  public

  published
    { Published Declarations }
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
    property Version: string Read GetVersion Write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TParseInclude }

const PTYPE_OBJECTPTR = 10;
const PTYPE_INTEGER   = 11;
const PTYPE_STRING    = 12;
const PTYPE_PROCPTR   = 13;


type IncEntry         = record
    Name:      string;
    hasparams: boolean;
    paramtype: array [0..10] of integer;
    params:    array [0..10] of string;
    paramcnt:  integer;
    category:  string;
    desc:      string;
    Value:     string;
  end;

var incs:    array of ^incentry;
var inc_cnt: integer;



implementation



const

  EOFSYMB     = 0;  identifierSym = 1;  integer_Sym = 2;  _floatSym = 3;
  _stringSym  = 4;  HexLiteralSym = 5;  AddDefineSym = 6;  _lparenSym = 7;
  integerSym  = 8;  procptrSym = 9;  stringSym = 10;  objectptrSym = 11;
  _commaSym   = 12;  _rparenSym = 13;  _equalSym = 14;  descriptionSym = 15;
  categorySym = 16;  _semicolonSym = 17;  NOSYMB = 18;  _noSym = NOSYMB;   {error token code}

 { --------------------------------------------------------------------------- }
 { Arbitrary Code from ATG file }
const
  PadLen = 20;

function parse_string(zstr: string): string;
var t:    integer;
var temp: string;
var len:  integer;
begin;
  len := 0;
temp:='';
  //writeln ('Parsing string: ',zstr);
  t   := pos('"', zstr) + 1;
  len := length(zstr);
  while (zstr[t] <> '"') do
  begin;
    //writeln (zstr[t]);
    if (zstr[t] = '\') and (zstr[t + 1] = '"') then
    begin;
      temp := temp + '"';
      Inc(t, 1);
    end else
    if (zstr[t] = '\') and (zstr[t + 1] = 't') then
    begin;
      temp := temp + #9;
      Inc(t, 1);
    end else
    if (zstr[t] = '\') and (zstr[t + 1] = 'n') then
    begin;
      temp := temp + #13#10;
      Inc(t, 1);
    end else

      temp := temp + zstr[t];

    Inc(t);
  end;
  Result := temp;
end;

function PadR(S: string; Ch: char; L: integer): string;
var
  i: integer;
begin
  for i := 1 to L - (Length(s)) do
    s := s + Ch;
  Result := s;
end;

procedure TParseInclude.Init;
begin

  OutputStream.Clear;
  SubSelectDepth := 0;
end;

procedure TParseInclude.Final;
begin
  OutputStream.Position := 0;
  OutputStream.SaveToStream(ListStream);
  OutputStream.Clear;
end;



procedure TParseInclude.WriteStr(S: string);
begin
  S := S + #13#10;
  OutputStream.WriteBuffer(S[1], length(S));
end;

 (* End of Arbitrary Code *)




 { --------------------------------------------------------------------------- }
 { ---- implementation for TParseIncludeScanner ---- }

procedure TParseIncludeScanner.NextCh;
 { Return global variable ch }
begin
  LastInputCh    := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  SrcStream.Seek(BufferPosition, soFromBeginning);
  CurrInputCh    := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) or ((CurrInputCh = _LF) and (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, IntToStr(CurrLine), CurrLine);
    StartOfLine := BufferPosition;
  end;
end;  {NextCh}

function TParseIncludeScanner.Comment: boolean;
var
  level:        integer;
  startLine:    integer;
  oldLineStart: longint;
  CommentStr:   string;
begin
  level        := 1;
  startLine    := CurrLine;
  oldLineStart := StartOfLine;
  CommentStr   := CharAt(BufferPosition);
  Result       := False;
  if (CurrInputCh = '/') then
  begin
    NextCh;
    CommentStr := CommentStr + CharAt(BufferPosition);
    if (CurrInputCh = '/') then
    begin
      NextCh;
      CommentStr := CommentStr + CharAt(BufferPosition);
      while True do
      begin
        if (CurrInputCh = CHR(13)) then
        begin
          level           := level - 1;
          NumEOLInComment := CurrLine - startLine;
          NextCh;
          CommentStr      := CommentStr + CharAt(BufferPosition);
          if level = 0 then
          begin
            Result := True;
            Exit;
          end;
        end
        else if CurrInputCh = _EF then
        begin
          Result := False;
          Exit;
        end
        else
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
        end;
      end; { WHILE TRUE }
    end
    else
    begin
      if (CurrInputCh = _CR) or (CurrInputCh = _LF) then
      begin
        CurrLine    := CurrLine - 1;
        StartOfLine := oldLineStart;
      end;
      BufferPosition := BufferPosition - 1;
      CurrInputCh := LastInputCh;
      Result := False;
    end;
  end;
  Result := False;
  if (CurrInputCh = '/') then
  begin
    NextCh;
    CommentStr := CommentStr + CharAt(BufferPosition);
    if (CurrInputCh = '*') then
    begin
      NextCh;
      CommentStr := CommentStr + CharAt(BufferPosition);
      while True do
      begin
        if (CurrInputCh = '*') then
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
          if (CurrInputCh = '/') then
          begin
            level := level - 1;
            NextCh;
            CommentStr := CommentStr + CharAt(BufferPosition);
            if level = 0 then
            begin
              Result := True;
              Exit;
            end;
          end;
        end
        else if CurrInputCh = _EF then
        begin
          Result := False;
          Exit;
        end
        else
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
        end;
      end; { WHILE TRUE }
    end
    else
    begin
      if (CurrInputCh = _CR) or (CurrInputCh = _LF) then
      begin
        CurrLine    := CurrLine - 1;
        StartOfLine := oldLineStart;
      end;
      BufferPosition := BufferPosition - 1;
      CurrInputCh := LastInputCh;
      Result := False;
    end;
  end;
end;  { Comment }

function TParseIncludeScanner.GetNextSymbolString: string;
var
  i: integer;
  q: integer;
begin
  Result := '';
  i      := 1;
  q      := bpCurrToken;
  while i <= NextSymbol.Len do
  begin
    Result := Result + CurrentCh(q);
    Inc(q);
    Inc(i);
  end;
end; {GetNextSymbolString}

procedure TParseIncludeScanner.CheckLiteral(var Sym: integer);
var
  SymId:        integer;
  DefaultSymId: integer;
  aToken:       string;
begin
  aToken := GetNextSymbolString;
  if fHashList.Hash(aToken, SymId, DefaultSymId) then
  begin
    sym := SymId;
  end;
end; {CheckLiteral}


procedure TParseIncludeScanner.Get(var sym: integer);
var
  state: integer;
begin   {Get}
  while (CurrInputCh = ' ') or ((CurrInputCh >= CHR(1)) and (CurrInputCh <= ' ')) do
    NextCh;
  if ((CurrInputCh = '/') or (CurrInputCh = '/')) and Comment then
  begin
    Get(sym);
    exit;
  end;
  CurrentSymbol.pos := NextSymbol.Pos;
  NextSymbol.Pos := BufferPosition;
  CurrentSymbol.col := NextSymbol.Col;
  NextSymbol.Col := BufferPosition - StartOfLine;
  CurrentSymbol.line := NextSymbol.Line;
  NextSymbol.Line := CurrLine;
  CurrentSymbol.Len := NextSymbol.Len;
  NextSymbol.Len := 0;
  ContextLen  := 0;
  state       := StartState[Ord(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while True do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym            := EOFSYMB;
      CurrInputCh    := _EF;
      BufferPosition := BufferPosition - 1;
      exit;
    end;
    case state of
      1: if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or (CurrInputCh >= 'A') and
          (CurrInputCh <= 'Z') or (CurrInputCh = '_') or (CurrInputCh >= 'a') and (CurrInputCh <= 'z') or
          (CurrInputCh >= CHR(196)) and (CurrInputCh <= CHR(197)) or (CurrInputCh = CHR(214)) or
          (CurrInputCh >= CHR(228)) and (CurrInputCh <= CHR(229)) or (CurrInputCh = CHR(246))) then
        begin

        end
        else
        begin
          sym := identifierSym;
          CheckLiteral(sym);
          exit;
        end;
      2: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 3;
        end
        else
        begin
          sym   := _noSym;
          exit;
        end;
      3: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else
        begin
          sym := integer_Sym;
          exit;
        end;
      4: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 5;
        end
        else
        begin
          sym   := _noSym;
          exit;
        end;
      5: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else if (CurrInputCh = 'f') then
        begin
          state := 6;
        end
        else
        begin
          sym   := _floatSym;
          exit;
        end;
      6: begin
        sym := _floatSym;
        exit;
      end;
      7: if ((CurrInputCh <= CHR(12)) or (CurrInputCh >= CHR(14)) and (CurrInputCh <= '!') or (CurrInputCh >= '#')) then
        begin

        end
        else if (CurrInputCh = '"') then
        begin
          state := 8;
        end
        else
        begin
          sym   := _noSym;
          exit;
        end;
      8: begin
        sym := _stringSym;
        exit;
      end;
      9: if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or (CurrInputCh >= 'A') and
          (CurrInputCh <= 'Z') or (CurrInputCh = '_') or (CurrInputCh >= 'a') and (CurrInputCh <= 'z') or
          (CurrInputCh >= CHR(196)) and (CurrInputCh <= CHR(197)) or (CurrInputCh = CHR(214)) or
          (CurrInputCh >= CHR(228)) and (CurrInputCh <= CHR(229)) or (CurrInputCh = CHR(246))) then
        begin

        end
        else
        begin
          sym := HexLiteralSym;
          exit;
        end;
      10: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else if (CurrInputCh = '.') then
        begin
          state := 4;
        end
        else
        begin
          sym   := integer_Sym;
          exit;
        end;
      11: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 10;
        end
        else
        begin
          sym   := _noSym;
          exit;
        end;
      12: begin
        sym := _lparenSym;
        exit;
      end;
      13: begin
        sym            := _commaSym;
        exit;
      end;
      14: begin
        sym            := _rparenSym;
        exit;
      end;
      15: begin
        sym            := _equalSym;
        exit;
      end;
      16: begin
        sym            := _semicolonSym;
        exit;
      end;
      17: begin
        sym            := EOFSYMB;
        CurrInputCh    := #0;
        BufferPosition := BufferPosition - 1;
        exit;
      end;
      else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TParseIncludeScanner.Create;
begin
  inherited;
  fHashList := TmwStringHashList.Create(TinyHash, HashSecondaryOne, HashCompare);
  fHashList.AddString('AddDefine', AddDefineSym, AddDefineSym);
  fHashList.AddString('category', categorySym, categorySym);
  fHashList.AddString('description', descriptionSym, descriptionSym);
  fHashList.AddString('integer', integerSym, integerSym);
  fHashList.AddString('objectptr', objectptrSym, objectptrSym);
  fHashList.AddString('procptr', procptrSym, procptrSym);
  fHashList.AddString('string', stringSym, stringSym);
  CurrentCh        := CharAt;
  fStartState[0]   := 17; fStartState[1] := 18; fStartState[2] := 18; fStartState[3] := 18;
  fStartState[4]   := 18; fStartState[5] := 18; fStartState[6] := 18; fStartState[7] := 18;
  fStartState[8]   := 18; fStartState[9] := 18; fStartState[10] := 18; fStartState[11] := 18;
  fStartState[12]  := 18; fStartState[13] := 18; fStartState[14] := 18; fStartState[15] := 18;
  fStartState[16]  := 18; fStartState[17] := 18; fStartState[18] := 18; fStartState[19] := 18;
  fStartState[20]  := 18; fStartState[21] := 18; fStartState[22] := 18; fStartState[23] := 18;
  fStartState[24]  := 18; fStartState[25] := 18; fStartState[26] := 18; fStartState[27] := 18;
  fStartState[28]  := 18; fStartState[29] := 18; fStartState[30] := 18; fStartState[31] := 18;
  fStartState[32]  := 18; fStartState[33] := 18; fStartState[34] := 7; fStartState[35] := 18;
  fStartState[36]  := 9; fStartState[37] := 18; fStartState[38] := 18; fStartState[39] := 18;
  fStartState[40]  := 12; fStartState[41] := 14; fStartState[42] := 18; fStartState[43] := 2;
  fStartState[44]  := 13; fStartState[45] := 11; fStartState[46] := 4; fStartState[47] := 18;
  fStartState[48]  := 10; fStartState[49] := 10; fStartState[50] := 10; fStartState[51] := 10;
  fStartState[52]  := 10; fStartState[53] := 10; fStartState[54] := 10; fStartState[55] := 10;
  fStartState[56]  := 10; fStartState[57] := 10; fStartState[58] := 18; fStartState[59] := 16;
  fStartState[60]  := 18; fStartState[61] := 15; fStartState[62] := 18; fStartState[63] := 18;
  fStartState[64]  := 18; fStartState[65] := 1; fStartState[66] := 1; fStartState[67] := 1;
  fStartState[68]  := 1; fStartState[69] := 1; fStartState[70] := 1; fStartState[71] := 1;
  fStartState[72]  := 1; fStartState[73] := 1; fStartState[74] := 1; fStartState[75] := 1;
  fStartState[76]  := 1; fStartState[77] := 1; fStartState[78] := 1; fStartState[79] := 1;
  fStartState[80]  := 1; fStartState[81] := 1; fStartState[82] := 1; fStartState[83] := 1;
  fStartState[84]  := 1; fStartState[85] := 1; fStartState[86] := 1; fStartState[87] := 1;
  fStartState[88]  := 1; fStartState[89] := 1; fStartState[90] := 1; fStartState[91] := 18;
  fStartState[92]  := 18; fStartState[93] := 18; fStartState[94] := 18; fStartState[95] := 1;
  fStartState[96]  := 18; fStartState[97] := 1; fStartState[98] := 1; fStartState[99] := 1;
  fStartState[100] := 1; fStartState[101] := 1; fStartState[102] := 1; fStartState[103] := 1;
  fStartState[104] := 1; fStartState[105] := 1; fStartState[106] := 1; fStartState[107] := 1;
  fStartState[108] := 1; fStartState[109] := 1; fStartState[110] := 1; fStartState[111] := 1;
  fStartState[112] := 1; fStartState[113] := 1; fStartState[114] := 1; fStartState[115] := 1;
  fStartState[116] := 1; fStartState[117] := 1; fStartState[118] := 1; fStartState[119] := 1;
  fStartState[120] := 1; fStartState[121] := 1; fStartState[122] := 1; fStartState[123] := 18;
  fStartState[124] := 18; fStartState[125] := 18; fStartState[126] := 18; fStartState[127] := 18;
  fStartState[128] := 18; fStartState[129] := 18; fStartState[130] := 18; fStartState[131] := 18;
  fStartState[132] := 18; fStartState[133] := 18; fStartState[134] := 18; fStartState[135] := 18;
  fStartState[136] := 18; fStartState[137] := 18; fStartState[138] := 18; fStartState[139] := 18;
  fStartState[140] := 18; fStartState[141] := 18; fStartState[142] := 18; fStartState[143] := 18;
  fStartState[144] := 18; fStartState[145] := 18; fStartState[146] := 18; fStartState[147] := 18;
  fStartState[148] := 18; fStartState[149] := 18; fStartState[150] := 18; fStartState[151] := 18;
  fStartState[152] := 18; fStartState[153] := 18; fStartState[154] := 18; fStartState[155] := 18;
  fStartState[156] := 18; fStartState[157] := 18; fStartState[158] := 18; fStartState[159] := 18;
  fStartState[160] := 18; fStartState[161] := 18; fStartState[162] := 18; fStartState[163] := 18;
  fStartState[164] := 18; fStartState[165] := 18; fStartState[166] := 18; fStartState[167] := 18;
  fStartState[168] := 18; fStartState[169] := 18; fStartState[170] := 18; fStartState[171] := 18;
  fStartState[172] := 18; fStartState[173] := 18; fStartState[174] := 18; fStartState[175] := 18;
  fStartState[176] := 18; fStartState[177] := 18; fStartState[178] := 18; fStartState[179] := 18;
  fStartState[180] := 18; fStartState[181] := 18; fStartState[182] := 18; fStartState[183] := 18;
  fStartState[184] := 18; fStartState[185] := 18; fStartState[186] := 18; fStartState[187] := 18;
  fStartState[188] := 18; fStartState[189] := 18; fStartState[190] := 18; fStartState[191] := 18;
  fStartState[192] := 18; fStartState[193] := 18; fStartState[194] := 18; fStartState[195] := 18;
  fStartState[196] := 1; fStartState[197] := 1; fStartState[198] := 18; fStartState[199] := 18;
  fStartState[200] := 18; fStartState[201] := 18; fStartState[202] := 18; fStartState[203] := 18;
  fStartState[204] := 18; fStartState[205] := 18; fStartState[206] := 18; fStartState[207] := 18;
  fStartState[208] := 18; fStartState[209] := 18; fStartState[210] := 18; fStartState[211] := 18;
  fStartState[212] := 18; fStartState[213] := 18; fStartState[214] := 1; fStartState[215] := 18;
  fStartState[216] := 18; fStartState[217] := 18; fStartState[218] := 18; fStartState[219] := 18;
  fStartState[220] := 18; fStartState[221] := 18; fStartState[222] := 18; fStartState[223] := 18;
  fStartState[224] := 18; fStartState[225] := 18; fStartState[226] := 18; fStartState[227] := 18;
  fStartState[228] := 1; fStartState[229] := 1; fStartState[230] := 18; fStartState[231] := 18;
  fStartState[232] := 18; fStartState[233] := 18; fStartState[234] := 18; fStartState[235] := 18;
  fStartState[236] := 18; fStartState[237] := 18; fStartState[238] := 18; fStartState[239] := 18;
  fStartState[240] := 18; fStartState[241] := 18; fStartState[242] := 18; fStartState[243] := 18;
  fStartState[244] := 18; fStartState[245] := 18; fStartState[246] := 1; fStartState[247] := 18;
  fStartState[248] := 18; fStartState[249] := 18; fStartState[250] := 18; fStartState[251] := 18;
  fStartState[252] := 18; fStartState[253] := 18; fStartState[254] := 18; fStartState[255] := 18;
end; {Create}

destructor TParseIncludeScanner.Destroy;
begin
  fHashList.Free;
  fHashList := NIL;
  inherited;
end;

 { --------------------------------------------------------------------------- }
 { ---- implementation for TParseInclude ---- }

constructor TParseInclude.Create(AOwner: TComponent);
begin
  inherited;
  Scanner          := TParseIncludeScanner.Create;
  GetScanner.Owner := self;
  fOutputStream    := TMemoryStream.Create;

  InitSymSet;
end; {Create}

destructor TParseInclude.Destroy;
begin
  Scanner.Free;
  fOutputStream.Free;

  inherited;
end; {Destroy}

function TParseInclude.ErrorStr(const ErrorCode: integer; const Data: string): string;
begin
  case ErrorCode of
    0: Result  := 'EOF expected';
    1: Result  := 'identifier expected';
    2: Result  := 'integer value expected';
    3: Result  := '_float expected';
    4: Result  := 'string constant expected';
    5: Result  := 'HexLiteral expected';
    6: Result  := '"AddDefine" expected';
    7: Result  := '"(" expected';
    8: Result  := '"integer" expected';
    9: Result  := '"procptr" expected';
    10: Result := '"string" expected';
    11: Result := '"objectptr" expected';
    12: Result := '"," expected';
    13: Result := '")" expected';
    14: Result := '"=" expected';
    15: Result := '"description" expected';
    16: Result := '"category" expected';
    17: Result := '";" expected';
    18: Result := 'not expected';


    else
      if Assigned(OnCustomError) then
        Result := OnCustomError(Self, ErrorCode, Data)
      else
      begin
        Result := 'Error: ' + IntToStr(ErrorCode);
        if Trim(Data) > '' then
          Result := Result + ' (' + Data + ')';
      end;
  end;  {case nr}
end; {ErrorStr}

procedure TParseInclude.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  if Assigned(OnStatusUpdate) then
    OnStatusUpdate(Self, 'parsing source', -1);

  { instigate the compilation }
  if Assigned(BeforeParse) then
    BeforeParse(Self);
  Parse;
  if Assigned(AfterParse) then
    AfterParse(Self);

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) or ((GenListWhen = glOnError) and (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful and Assigned(OnSuccess) then
    OnSuccess(Self);
  if (not Successful) and Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TParseInclude.Get;
begin
  repeat


    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
    end;
  until fCurrentInputSymbol <= maxT;
end;  {Get}

function TParseInclude.GetScanner: TParseIncludeScanner;
begin
  Result := Scanner as TParseIncludeScanner;
end;  {GetScanner}

function TParseInclude._In(var s: SymbolSet; x: integer): boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TParseInclude._Stuff;begin
  Expect(AddDefineSym);
  Expect(identifierSym);
  setlength(incs, inc_cnt+1);
  new(incs[inc_Cnt]);
  incs[inc_cnt].Name     := lexstring;;
  incs[inc_cnt].paramcnt := 0;
  if (fCurrentInputSymbol = _lparenSym) then begin
    Get;
    if (fCurrentInputSymbol = integerSym) or (fCurrentInputSymbol = procptrSym) or
      (fCurrentInputSymbol = stringSym) or (fCurrentInputSymbol = objectptrSym) then begin
      if (fCurrentInputSymbol = integerSym) then begin
        Get;
        incs[inc_cnt].paramtype[incs[inc_cnt].paramcnt] := PTYPE_INTEGER;
      end else if (fCurrentInputSymbol = procptrSym) then begin
        Get;
        incs[inc_cnt].paramtype[incs[inc_cnt].paramcnt] := PTYPE_PROCPTR;
      end else if (fCurrentInputSymbol = stringSym) then begin
        Get;
        incs[inc_cnt].paramtype[incs[inc_cnt].paramcnt] := PTYPE_STRING;
      end else
      begin
        Get;
        incs[inc_cnt].paramtype[incs[inc_cnt].paramcnt] := PTYPE_OBJECTPTR;
      end;
    end;
    if (fCurrentInputSymbol = identifierSym) then begin
      Get;
      incs[inc_cnt].params[incs[inc_cnt].paramcnt] := lexstring;;
      while (fCurrentInputSymbol = _commaSym) do begin
        Get;
        Inc(incs[inc_cnt].paramcnt);;
        if (fCurrentInputSymbol = integerSym) or (fCurrentInputSymbol = procptrSym) or
          (fCurrentInputSymbol = stringSym) or (fCurrentInputSymbol = objectptrSym) then begin
          if (fCurrentInputSymbol = integerSym) then begin
            Get;
            incs[inc_cnt].paramtype[incs[inc_cnt].paramcnt] := PTYPE_INTEGER;
          end else if (fCurrentInputSymbol = procptrSym) then begin
            Get;
            incs[inc_cnt].paramtype[incs[inc_cnt].paramcnt] := PTYPE_PROCPTR;
          end else if (fCurrentInputSymbol = stringSym) then begin
            Get;
            incs[inc_cnt].paramtype[incs[inc_cnt].paramcnt] := PTYPE_STRING;
          end else
          begin
            Get;
            incs[inc_cnt].paramtype[incs[inc_cnt].paramcnt] := PTYPE_OBJECTPTR;
          end;
        end;
        Expect(identifierSym);
        incs[inc_cnt].params[incs[inc_cnt].paramcnt] := lexstring;;
      end;
    end;
    Expect(_rparenSym);
    Inc(incs[inc_cnt].paramcnt);;
  end;
  if (fCurrentInputSymbol = _equalSym) then begin
    Get;
    Expect(integer_Sym);
    incs[inc_cnt].Value := lexstring;;
  end;
  if (fCurrentInputSymbol = descriptionSym) then begin
    Get;
    Expect(_equalSym);
    Expect(_stringSym);
    incs[inc_cnt].desc     := parse_string(lexstring);;
    Expect(categorySym);
    Expect(_equalSym);
    Expect(identifierSym);
    incs[inc_cnt].category := lexstring;;
  end;
  Expect(_semicolonSym);
  Inc(inc_cnt);;
end;

procedure TParseInclude._ParseInclude;begin
  Init;;
  _Stuff;
  while (fCurrentInputSymbol = AddDefineSym) do begin
    _Stuff;
  end;
  Final;;
end;

function TParseInclude.GetMajorVersion: integer;
begin
  Result := 1;
end;

function TParseInclude.GetMinorVersion: integer;
begin
  Result := 0;
end;

function TParseInclude.GetRelease: integer;
begin
  Result := 0;
end;

function TParseInclude.GetBuild: integer;
begin
  Result := 222;
end;

function TParseInclude.GetBuildDate: TDateTime;
const
  BDate = 38677;
  Hour  = 18;
  Min   = 18;
begin
  Result := BDate + EncodeTime(Hour, Min, 0, 0);
end;

function TParseInclude.GetVersion: string;
var
  MinorVersionStr: string;
begin
  MinorVersionStr := IntToStr(MinorVersion);
  if (length(MinorVersionStr) > 0) and (MinorVersion > 0) then
    MinorVersionStr := '0' + MinorVersionStr;
  Result          := 'Version: ' + IntToStr(MajorVersion) + '.' + MinorVersionStr + ' Release ' +
    IntToStr(Release) + ' Build ' + IntToStr(Build);
end;

function TParseInclude.GetVersionComment: string;
begin
  Result := 'SSL Include files parser';
end;

function TParseInclude.GetGrammarAuthor: string;
begin
  Result := 'T. Pitkänen';
end;

function TParseInclude.GetGrammarCopyright: string;
begin
  Result := '(c) 2003 Dj Unique';
end;

procedure TParseInclude.SetVersion(const Value: string);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TParseInclude.Parse;
begin
  errDist := minErrDist;
  GetScanner._Reset;
  Get;
  _ParseInclude;
end;  {Parse}

procedure TParseInclude.InitSymSet;
begin
  symSet[0, 0] := [EOFSYMB];
  symSet[0, 1] := [];
end; {InitSymSet}

end { ParseInclude }.
    
