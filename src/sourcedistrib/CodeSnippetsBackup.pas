unit CodeSnippetsBackup;




{ CodeSnippets
  Version: 1.0 Release 0 Build 5
  FMFDLGTool Code Snippets parser
  Date of Generation: 9.8.2005 15:36
  Author: T. Pitkänen
  (c) 2005 Dj Unique

  This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
  this file that you edit manually will be over-written when the file is
  regenerated.
}

interface
uses  Classes, CocoBase, jclStrings, mwStringHashList, SysUtils, Variants;
const
  maxT      = 26;
  maxP      = 27;
type
  SymbolSet = array[0..maxT div setsize] of TBitSet;

  ECodeSnippets        = class(Exception);
  TCodeSnippets        = class;

  TCodeSnippetsScanner = class(TCocoRScanner)
  private
    FOwner:    TCodeSnippets;
    fHashList: TmwStringHashList;
    procedure CheckLiteral(var Sym: integer);
    function GetNextSymbolString: string;
    function Comment: boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;
    destructor Destroy; override;

    procedure Get(var sym: integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner: TCodeSnippets Read fOwner Write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TCodeSnippetsScanner }

  TCodeSnippets = class(TCocoRGrammar)
  private
        { strictly internal variables }
    symSet: array[0..1] of SymbolSet; // symSet[0] = allSyncSyms

    function GetMajorVersion: integer;
    function GetMinorVersion: integer;
    function GetRelease: integer;
    function GetBuild: integer;
    function GetBuildDate: TDateTime;
    function GetVersionComment: string;
    function GetGrammarAuthor: string;
    function GetGrammarCopyright: string;
    function GetVersion: string;
    procedure SetVersion(const Value: string);
    function _In(var s: SymbolSet; x: integer): boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _Param;
    procedure _CodePreset;
    procedure _CodeSnippets;

  private
    fOutputStream:   TMemoryStream;
    fSubSelectDepth: integer;
    fInNaturalJoin:  boolean;

    procedure Init;
    procedure Final;
    procedure WriteStr(S: string);
    property OutputStream: TMemoryStream Read fOutputStream Write fOutputStream;
    property SubSelectDepth: integer Read fSubSelectDepth Write fSubSelectDepth;
    property InNaturalJoin: boolean Read fInNaturalJoin Write fInNaturalJoin;

  protected
    { Protected Declarations }
    procedure Get; override;
  public
    { Public Declarations }
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode: integer; const Data: string): string; override;
    procedure Execute;
    function GetScanner: TCodeSnippetsScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property MajorVersion: integer Read GetMajorVersion;
    property MinorVersion: integer Read GetMinorVersion;
    property Release: integer Read GetRelease;
    property Build: integer Read GetBuild;
    property BuildDate: TDateTime Read GetBuildDate;
    property VersionComment: string Read GetVersionComment;
    property GrammarAuthor: string Read GetGrammarAuthor;
    property GrammarCopyright: string Read GetGrammarCopyright;

  public

  published
    { Published Declarations }
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
    property Version: string Read GetVersion Write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TCodeSnippets }

const

  PARAM_TYPE_INT       = 1;
  PARAM_TYPE_NODE      = 2;
  PARAM_TYPE_BOOL      = 3;
  PARAM_TYPE_FLOATNODE = 4;
  PARAM_TYPE_STRING    = 5;
  PARAM_TYPE_SKILL     = 6;
  PARAM_TYPE_STAT      = 7;
  PARAM_TYPE_GVAR      = 8;
  PARAM_TYPE_LVAR      = 9;
  PARAM_TYPE_SVAR      = 10;
  PARAM_TYPE_PID       = 11;
  PARAM_TYPE_MVAR      = 12;

type Param             = record
    ParamType: integer;
    paramname: string;
    paramdesc: string;

  end;


type CodeSnippet = record
    InternalName: string;
    DisplayName:  string;
    Params:       array [0..32] of ^Param;
    ParamCount:   integer;
    Lines:        string;
  end;

var CodeSnippetData: array [0..256] of ^CodeSnippet;
var CodeSnippetcnt:  integer;
function GetParamType(ptype: integer): string;


implementation



const

  EOFSYMB         = 0;  identifierSym = 1;  integer_Sym = 2;  _floatSym = 3;
  _stringSym      = 4;  HexLiteralSym = 5;  boolSym = 6;  intSym = 7;  statSym = 8;
  skillSym        = 9;  script_underscorevarSym = 10;  pid_underscoreidSym = 11;
  map_underscorevarSym = 12;  local_underscorevarSym = 13;  nodeSym = 14;
  floatnodeSym    = 15;  stringSym = 16;  _equalSym = 17;  CodePresetSym = 18;
  _lparenSym      = 19;  _commaSym = 20;  _rparenSym = 21;  descSym = 22;
  _lbraceSym      = 23;  _rbraceSym = 24;  _semicolonSym = 25;  NOSYMB = 26;
  PreProcessorSym = 27;  _noSym = NOSYMB;   {error token code}

 { --------------------------------------------------------------------------- }
 { Arbitrary Code from ATG file }
var temp_param: Param;
const
  PadLen = 20;

function PadR(S: string; Ch: char; L: integer): string;
var
  i: integer;
begin
  for i := 1 to L - (Length(s)) do
    s := s + Ch;
  Result := s;
end;

procedure TCodeSnippets.Init;
begin

  OutputStream.Clear;
  SubSelectDepth := 0;
end;

   (* End of Arbitrary Code *)




 { --------------------------------------------------------------------------- }
 { ---- implementation for TCodeSnippetsScanner ---- }

procedure TCodeSnippetsScanner.NextCh;
 { Return global variable ch }
begin
  LastInputCh    := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  SrcStream.Seek(BufferPosition, soFromBeginning);
  CurrInputCh    := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) or ((CurrInputCh = _LF) and (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, IntToStr(CurrLine), CurrLine);
    StartOfLine := BufferPosition;
  end;
end;  {NextCh}

function TCodeSnippetsScanner.Comment: boolean;
var
  level:        integer;
  startLine:    integer;
  oldLineStart: longint;
  CommentStr:   string;
begin
  level        := 1;
  startLine    := CurrLine;
  oldLineStart := StartOfLine;
  CommentStr   := CharAt(BufferPosition);
  Result       := False;
  if (CurrInputCh = '/') then
  begin
    NextCh;
    CommentStr := CommentStr + CharAt(BufferPosition);
    if (CurrInputCh = '/') then
    begin
      NextCh;
      CommentStr := CommentStr + CharAt(BufferPosition);
      while True do
      begin
        if (CurrInputCh = CHR(13)) then
        begin
          level           := level - 1;
          NumEOLInComment := CurrLine - startLine;
          NextCh;
          CommentStr      := CommentStr + CharAt(BufferPosition);
          if level = 0 then
          begin
            Result := True;
            Exit;
          end;
        end
        else if CurrInputCh = _EF then
        begin
          Result := False;
          Exit;
        end
        else
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
        end;
      end; { WHILE TRUE }
    end
    else
    begin
      if (CurrInputCh = _CR) or (CurrInputCh = _LF) then
      begin
        CurrLine    := CurrLine - 1;
        StartOfLine := oldLineStart;
      end;
      BufferPosition := BufferPosition - 1;
      CurrInputCh := LastInputCh;
      Result := False;
    end;
  end;
  Result := False;
  if (CurrInputCh = '/') then
  begin
    NextCh;
    CommentStr := CommentStr + CharAt(BufferPosition);
    if (CurrInputCh = '*') then
    begin
      NextCh;
      CommentStr := CommentStr + CharAt(BufferPosition);
      while True do
      begin
        if (CurrInputCh = '*') then
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
          if (CurrInputCh = '/') then
          begin
            level := level - 1;
            NextCh;
            CommentStr := CommentStr + CharAt(BufferPosition);
            if level = 0 then
            begin
              Result := True;
              Exit;
            end;
          end;
        end
        else if CurrInputCh = _EF then
        begin
          Result := False;
          Exit;
        end
        else
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
        end;
      end; { WHILE TRUE }
    end
    else
    begin
      if (CurrInputCh = _CR) or (CurrInputCh = _LF) then
      begin
        CurrLine    := CurrLine - 1;
        StartOfLine := oldLineStart;
      end;
      BufferPosition := BufferPosition - 1;
      CurrInputCh := LastInputCh;
      Result := False;
    end;
  end;
end;  { Comment }

function TCodeSnippetsScanner.GetNextSymbolString: string;
var
  i: integer;
  q: integer;
begin
  Result := '';
  i      := 1;
  q      := bpCurrToken;
  while i <= NextSymbol.Len do
  begin
    Result := Result + CurrentCh(q);
    Inc(q);
    Inc(i);
  end;
end; {GetNextSymbolString}

procedure TCodeSnippetsScanner.CheckLiteral(var Sym: integer);
var
  SymId:        integer;
  DefaultSymId: integer;
  aToken:       string;
begin
  aToken := GetNextSymbolString;
  if fHashList.Hash(aToken, SymId, DefaultSymId) then
  begin
    sym := SymId;
  end;
end; {CheckLiteral}


procedure TCodeSnippetsScanner.Get(var sym: integer);
var
  state: integer;
begin   {Get}
  while (CurrInputCh = ' ') or ((CurrInputCh >= CHR(1)) and (CurrInputCh <= ' ')) do
    NextCh;
  if ((CurrInputCh = '/') or (CurrInputCh = '/')) and Comment then
  begin
    Get(sym);
    exit;
  end;
  CurrentSymbol.pos := NextSymbol.Pos;
  NextSymbol.Pos := BufferPosition;
  CurrentSymbol.col := NextSymbol.Col;
  NextSymbol.Col := BufferPosition - StartOfLine;
  CurrentSymbol.line := NextSymbol.Line;
  NextSymbol.Line := CurrLine;
  CurrentSymbol.Len := NextSymbol.Len;
  NextSymbol.Len := 0;
  ContextLen  := 0;
  state       := StartState[Ord(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while True do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym            := EOFSYMB;
      CurrInputCh    := _EF;
      BufferPosition := BufferPosition - 1;
      exit;
    end;
    case state of
      1: if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or (CurrInputCh >= 'A') and
          (CurrInputCh <= 'Z') or (CurrInputCh = '_') or (CurrInputCh >= 'a') and (CurrInputCh <= 'z') or
          (CurrInputCh >= CHR(196)) and (CurrInputCh <= CHR(197)) or (CurrInputCh = CHR(214)) or
          (CurrInputCh >= CHR(228)) and (CurrInputCh <= CHR(229)) or (CurrInputCh = CHR(246))) then
        begin

        end
        else
        begin
          sym := identifierSym;
          CheckLiteral(sym);
          exit;
        end;
      2: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 3;
        end
        else
        begin
          sym   := _noSym;
          exit;
        end;
      3: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else
        begin
          sym := integer_Sym;
          exit;
        end;
      4: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 5;
        end
        else
        begin
          sym   := _noSym;
          exit;
        end;
      5: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else if (CurrInputCh = 'f') then
        begin
          state := 6;
        end
        else
        begin
          sym   := _floatSym;
          exit;
        end;
      6: begin
        sym := _floatSym;
        exit;
      end;
      7: if ((CurrInputCh <= CHR(12)) or (CurrInputCh >= CHR(14)) and (CurrInputCh <= '!') or
          (CurrInputCh >= '#') and (CurrInputCh <= '[') or (CurrInputCh >= ']')) then
        begin

        end
        else if (CurrInputCh = '"') then
        begin
          state := 8;
        end
        else if (CurrInputCh = '\') then
        begin
          state := 13;
        end
        else
        begin
          sym   := _noSym;
          exit;
        end;
      8: begin
        sym := _stringSym;
        exit;
      end;
      9: if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or (CurrInputCh >= 'A') and
          (CurrInputCh <= 'Z') or (CurrInputCh = '_') or (CurrInputCh >= 'a') and (CurrInputCh <= 'z') or
          (CurrInputCh >= CHR(196)) and (CurrInputCh <= CHR(197)) or (CurrInputCh = CHR(214)) or
          (CurrInputCh >= CHR(228)) and (CurrInputCh <= CHR(229)) or (CurrInputCh = CHR(246))) then
        begin

        end
        else
        begin
          sym := HexLiteralSym;
          exit;
        end;
      10: if not ((CurrInputCh = CHR(13))) then
        begin

        end
        else
        begin
          sym := PreProcessorSym;
          exit;
        end;
      11: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else if (CurrInputCh = '.') then
        begin
          state := 4;
        end
        else
        begin
          sym   := integer_Sym;
          exit;
        end;
      12: if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 11;
        end
        else
        begin
          sym   := _noSym;
          exit;
        end;
      13: if ((CurrInputCh <= CHR(12)) or (CurrInputCh >= CHR(14)) and (CurrInputCh <= '!') or
          (CurrInputCh >= '#') and (CurrInputCh <= '[') or (CurrInputCh >= ']')) then
        begin
          state := 7;
        end
        else if (CurrInputCh = '"') then
        begin
          state := 14;
        end
        else if (CurrInputCh = '\') then
        begin

        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      14: if ((CurrInputCh <= CHR(12)) or (CurrInputCh >= CHR(14)) and (CurrInputCh <= '!') or
          (CurrInputCh >= '#') and (CurrInputCh <= '[') or (CurrInputCh >= ']')) then
        begin
          state := 7;
        end
        else if (CurrInputCh = '"') then
        begin
          state := 8;
        end
        else if (CurrInputCh = '\') then
        begin
          state := 13;
        end
        else
        begin
          sym   := _stringSym;
          exit;
        end;
      15: begin
        sym := _equalSym;
        exit;
      end;
      16: begin
        sym            := _lparenSym;
        exit;
      end;
      17: begin
        sym            := _commaSym;
        exit;
      end;
      18: begin
        sym            := _rparenSym;
        exit;
      end;
      19: begin
        sym            := _lbraceSym;
        exit;
      end;
      20: begin
        sym            := _rbraceSym;
        exit;
      end;
      21: begin
        sym            := _semicolonSym;
        exit;
      end;
      22: begin
        sym            := EOFSYMB;
        CurrInputCh    := #0;
        BufferPosition := BufferPosition - 1;
        exit;
      end;
      else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TCodeSnippetsScanner.Create;
begin
  inherited;
  fHashList := TmwStringHashList.Create(SmallCrcHash, HashSecondaryTwo, HashCompare);
  fHashList.AddString('CodePreset', CodePresetSym, CodePresetSym);
  fHashList.AddString('bool', boolSym, boolSym);
  fHashList.AddString('desc', descSym, descSym);
  fHashList.AddString('floatnode', floatnodeSym, floatnodeSym);
  fHashList.AddString('int', intSym, intSym);
  fHashList.AddString('local_var', local_underscorevarSym, local_underscorevarSym);
  fHashList.AddString('map_var', map_underscorevarSym, map_underscorevarSym);
  fHashList.AddString('node', nodeSym, nodeSym);
  fHashList.AddString('pid_id', pid_underscoreidSym, pid_underscoreidSym);
  fHashList.AddString('script_var', script_underscorevarSym, script_underscorevarSym);
  fHashList.AddString('skill', skillSym, skillSym);
  fHashList.AddString('stat', statSym, statSym);
  fHashList.AddString('string', stringSym, stringSym);
  CurrentCh        := CharAt;
  fStartState[0]   := 22; fStartState[1] := 23; fStartState[2] := 23; fStartState[3] := 23;
  fStartState[4]   := 23; fStartState[5] := 23; fStartState[6] := 23; fStartState[7] := 23;
  fStartState[8]   := 23; fStartState[9] := 23; fStartState[10] := 23; fStartState[11] := 23;
  fStartState[12]  := 23; fStartState[13] := 23; fStartState[14] := 23; fStartState[15] := 23;
  fStartState[16]  := 23; fStartState[17] := 23; fStartState[18] := 23; fStartState[19] := 23;
  fStartState[20]  := 23; fStartState[21] := 23; fStartState[22] := 23; fStartState[23] := 23;
  fStartState[24]  := 23; fStartState[25] := 23; fStartState[26] := 23; fStartState[27] := 23;
  fStartState[28]  := 23; fStartState[29] := 23; fStartState[30] := 23; fStartState[31] := 23;
  fStartState[32]  := 23; fStartState[33] := 23; fStartState[34] := 7; fStartState[35] := 10;
  fStartState[36]  := 9; fStartState[37] := 23; fStartState[38] := 23; fStartState[39] := 23;
  fStartState[40]  := 16; fStartState[41] := 18; fStartState[42] := 23; fStartState[43] := 2;
  fStartState[44]  := 17; fStartState[45] := 12; fStartState[46] := 4; fStartState[47] := 23;
  fStartState[48]  := 11; fStartState[49] := 11; fStartState[50] := 11; fStartState[51] := 11;
  fStartState[52]  := 11; fStartState[53] := 11; fStartState[54] := 11; fStartState[55] := 11;
  fStartState[56]  := 11; fStartState[57] := 11; fStartState[58] := 23; fStartState[59] := 21;
  fStartState[60]  := 23; fStartState[61] := 15; fStartState[62] := 23; fStartState[63] := 23;
  fStartState[64]  := 23; fStartState[65] := 1; fStartState[66] := 1; fStartState[67] := 1;
  fStartState[68]  := 1; fStartState[69] := 1; fStartState[70] := 1; fStartState[71] := 1;
  fStartState[72]  := 1; fStartState[73] := 1; fStartState[74] := 1; fStartState[75] := 1;
  fStartState[76]  := 1; fStartState[77] := 1; fStartState[78] := 1; fStartState[79] := 1;
  fStartState[80]  := 1; fStartState[81] := 1; fStartState[82] := 1; fStartState[83] := 1;
  fStartState[84]  := 1; fStartState[85] := 1; fStartState[86] := 1; fStartState[87] := 1;
  fStartState[88]  := 1; fStartState[89] := 1; fStartState[90] := 1; fStartState[91] := 23;
  fStartState[92]  := 23; fStartState[93] := 23; fStartState[94] := 23; fStartState[95] := 1;
  fStartState[96]  := 23; fStartState[97] := 1; fStartState[98] := 1; fStartState[99] := 1;
  fStartState[100] := 1; fStartState[101] := 1; fStartState[102] := 1; fStartState[103] := 1;
  fStartState[104] := 1; fStartState[105] := 1; fStartState[106] := 1; fStartState[107] := 1;
  fStartState[108] := 1; fStartState[109] := 1; fStartState[110] := 1; fStartState[111] := 1;
  fStartState[112] := 1; fStartState[113] := 1; fStartState[114] := 1; fStartState[115] := 1;
  fStartState[116] := 1; fStartState[117] := 1; fStartState[118] := 1; fStartState[119] := 1;
  fStartState[120] := 1; fStartState[121] := 1; fStartState[122] := 1; fStartState[123] := 19;
  fStartState[124] := 23; fStartState[125] := 20; fStartState[126] := 23; fStartState[127] := 23;
  fStartState[128] := 23; fStartState[129] := 23; fStartState[130] := 23; fStartState[131] := 23;
  fStartState[132] := 23; fStartState[133] := 23; fStartState[134] := 23; fStartState[135] := 23;
  fStartState[136] := 23; fStartState[137] := 23; fStartState[138] := 23; fStartState[139] := 23;
  fStartState[140] := 23; fStartState[141] := 23; fStartState[142] := 23; fStartState[143] := 23;
  fStartState[144] := 23; fStartState[145] := 23; fStartState[146] := 23; fStartState[147] := 23;
  fStartState[148] := 23; fStartState[149] := 23; fStartState[150] := 23; fStartState[151] := 23;
  fStartState[152] := 23; fStartState[153] := 23; fStartState[154] := 23; fStartState[155] := 23;
  fStartState[156] := 23; fStartState[157] := 23; fStartState[158] := 23; fStartState[159] := 23;
  fStartState[160] := 23; fStartState[161] := 23; fStartState[162] := 23; fStartState[163] := 23;
  fStartState[164] := 23; fStartState[165] := 23; fStartState[166] := 23; fStartState[167] := 23;
  fStartState[168] := 23; fStartState[169] := 23; fStartState[170] := 23; fStartState[171] := 23;
  fStartState[172] := 23; fStartState[173] := 23; fStartState[174] := 23; fStartState[175] := 23;
  fStartState[176] := 23; fStartState[177] := 23; fStartState[178] := 23; fStartState[179] := 23;
  fStartState[180] := 23; fStartState[181] := 23; fStartState[182] := 23; fStartState[183] := 23;
  fStartState[184] := 23; fStartState[185] := 23; fStartState[186] := 23; fStartState[187] := 23;
  fStartState[188] := 23; fStartState[189] := 23; fStartState[190] := 23; fStartState[191] := 23;
  fStartState[192] := 23; fStartState[193] := 23; fStartState[194] := 23; fStartState[195] := 23;
  fStartState[196] := 1; fStartState[197] := 1; fStartState[198] := 23; fStartState[199] := 23;
  fStartState[200] := 23; fStartState[201] := 23; fStartState[202] := 23; fStartState[203] := 23;
  fStartState[204] := 23; fStartState[205] := 23; fStartState[206] := 23; fStartState[207] := 23;
  fStartState[208] := 23; fStartState[209] := 23; fStartState[210] := 23; fStartState[211] := 23;
  fStartState[212] := 23; fStartState[213] := 23; fStartState[214] := 1; fStartState[215] := 23;
  fStartState[216] := 23; fStartState[217] := 23; fStartState[218] := 23; fStartState[219] := 23;
  fStartState[220] := 23; fStartState[221] := 23; fStartState[222] := 23; fStartState[223] := 23;
  fStartState[224] := 23; fStartState[225] := 23; fStartState[226] := 23; fStartState[227] := 23;
  fStartState[228] := 1; fStartState[229] := 1; fStartState[230] := 23; fStartState[231] := 23;
  fStartState[232] := 23; fStartState[233] := 23; fStartState[234] := 23; fStartState[235] := 23;
  fStartState[236] := 23; fStartState[237] := 23; fStartState[238] := 23; fStartState[239] := 23;
  fStartState[240] := 23; fStartState[241] := 23; fStartState[242] := 23; fStartState[243] := 23;
  fStartState[244] := 23; fStartState[245] := 23; fStartState[246] := 1; fStartState[247] := 23;
  fStartState[248] := 23; fStartState[249] := 23; fStartState[250] := 23; fStartState[251] := 23;
  fStartState[252] := 23; fStartState[253] := 23; fStartState[254] := 23; fStartState[255] := 23;
end; {Create}

destructor TCodeSnippetsScanner.Destroy;
begin
  fHashList.Free;
  fHashList := NIL;
  inherited;
end;

 { --------------------------------------------------------------------------- }
 { ---- implementation for TCodeSnippets ---- }

constructor TCodeSnippets.Create(AOwner: TComponent);
begin
  inherited;
  Scanner          := TCodeSnippetsScanner.Create;
  GetScanner.Owner := self;
  fOutputStream    := TMemoryStream.Create;

  InitSymSet;
end; {Create}

destructor TCodeSnippets.Destroy;
begin
  Scanner.Free;
  fOutputStream.Free;

  inherited;
end; {Destroy}

function TCodeSnippets.ErrorStr(const ErrorCode: integer; const Data: string): string;
begin
  case ErrorCode of
    0: Result  := 'EOF expected';
    1: Result  := 'identifier expected';
    2: Result  := 'integer value expected';
    3: Result  := '_float expected';
    4: Result  := 'string constant expected';
    5: Result  := 'HexLiteral expected';
    6: Result  := '"bool" expected';
    7: Result  := '"int" expected';
    8: Result  := '"stat" expected';
    9: Result  := '"skill" expected';
    10: Result := '"script_var" expected';
    11: Result := '"pid_id" expected';
    12: Result := '"map_var" expected';
    13: Result := '"local_var" expected';
    14: Result := '"node" expected';
    15: Result := '"floatnode" expected';
    16: Result := '"string" expected';
    17: Result := '"=" expected';
    18: Result := '"CodePreset" expected';
    19: Result := '"(" expected';
    20: Result := '"," expected';
    21: Result := '")" expected';
    22: Result := '"desc" expected';
    23: Result := '"{" expected';
    24: Result := '"}" expected';
    25: Result := '";" expected';
    26: Result := 'not expected';
    27: Result := 'invalid Parameter definition';


    else
      if Assigned(OnCustomError) then
        Result := OnCustomError(Self, ErrorCode, Data)
      else
      begin
        Result := 'Error: ' + IntToStr(ErrorCode);
        if Trim(Data) > '' then
          Result := Result + ' (' + Data + ')';
      end;
  end;  {case nr}
end; {ErrorStr}

procedure TCodeSnippets.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  if Assigned(OnStatusUpdate) then
    OnStatusUpdate(Self, 'parsing source', -1);

  { instigate the compilation }
  if Assigned(BeforeParse) then
    BeforeParse(Self);
  Parse;
  if Assigned(AfterParse) then
    AfterParse(Self);

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) or ((GenListWhen = glOnError) and (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful and Assigned(OnSuccess) then
    OnSuccess(Self);
  if (not Successful) and Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TCodeSnippets.Get;
begin
  repeat


    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
      case fCurrentInputSymbol of
        PreProcessorSym: begin
        end;
      end;
      GetScanner.NextSymbol.Pos  := GetScanner.CurrentSymbol.Pos;
      GetScanner.NextSymbol.Col  := GetScanner.CurrentSymbol.Col;
      GetScanner.NextSymbol.Line := GetScanner.CurrentSymbol.Line;
      GetScanner.NextSymbol.Len  := GetScanner.CurrentSymbol.Len;
    end;
  until fCurrentInputSymbol <= maxT;
end;  {Get}

function TCodeSnippets.GetScanner: TCodeSnippetsScanner;
begin
  Result := Scanner as TCodeSnippetsScanner;
end;  {GetScanner}

function TCodeSnippets._In(var s: SymbolSet; x: integer): boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TCodeSnippets._Param;begin
  case fCurrentInputSymbol of
    boolSym: begin
      Get;
      temp_param.paramtype := PARAM_TYPE_BOOL;;
    end;
    intSym: begin
      Get;
      temp_param.paramtype := PARAM_TYPE_INT;;
    end;
    identifierSym: begin
    end;
    statSym: begin
      Get;
      temp_param.paramtype := PARAM_TYPE_STAT;;
    end;
    skillSym: begin
      Get;
      temp_param.paramtype := PARAM_TYPE_SKILL;;
    end;
    script_underscorevarSym: begin
      Get;
      temp_param.paramtype := PARAM_TYPE_SVAR;;
    end;
    pid_underscoreidSym: begin
      Get;
      temp_param.paramtype := PARAM_TYPE_PID;;
    end;
    map_underscorevarSym: begin
      Get;
      temp_param.paramtype := PARAM_TYPE_MVAR;;
    end;
    local_underscorevarSym: begin
      Get;
      temp_param.paramtype := PARAM_TYPE_LVAR;;
    end;
    nodeSym: begin
      Get;
      temp_param.paramtype := PARAM_TYPE_NODE;;
    end;
    floatnodeSym: begin
      Get;
      temp_param.paramtype := PARAM_TYPE_FLOATNODE;;
    end;
    stringSym: begin
      Get;
      temp_param.paramtype := PARAM_TYPE_STRING;;
    end;
    else
    begin SynError(27);
    end;
  end;
  Expect(identifierSym);
  temp_param.paramname := lexstring;;
  Expect(_equalSym);
  Expect(_stringSym);
  temp_param.paramdesc := parse_string(lexstring);;
end;

procedure TCodeSnippets._CodePreset;begin
  Expect(CodePresetSym);
  Expect(identifierSym);
  new(CodeSnippetData[codesnippetcnt]);
  CodeSnippetData[codesnippetcnt].paramcount := 0;  CodeSnippetData[codesnippetcnt].Lines := '';
  CodeSnippetData[codesnippetcnt].internalname := lexstring;
  ;
  Expect(_lparenSym);
  if _In(symSet[1], fCurrentInputSymbol) then begin
    _Param;
    new(CodeSnippetData[codesnippetcnt].params[CodeSnippetData[codesnippetcnt].paramcount]);
    CodeSnippetData[codesnippetcnt].params[CodeSnippetData[codesnippetcnt].paramcount]^ := temp_param;
    Inc(CodeSnippetData[codesnippetcnt].paramcount);;
    while (fCurrentInputSymbol = _commaSym) do begin
      Get;
      _Param;
      new(CodeSnippetData[codesnippetcnt].params[CodeSnippetData[codesnippetcnt].paramcount]);
      CodeSnippetData[codesnippetcnt].params[CodeSnippetData[codesnippetcnt].paramcount]^ := temp_param;
      Inc(CodeSnippetData[codesnippetcnt].paramcount);;
    end;
  end;
  Expect(_rparenSym);
  Expect(descSym);
  Expect(_equalSym);
  Expect(_stringSym);
  CodeSnippetData[codesnippetcnt].displayname := parse_string(lexstring);;
  Expect(_lbraceSym);
  if (fCurrentInputSymbol = _stringSym) then begin
    Get;
    CodeSnippetData[codesnippetcnt].Lines := parse_string(lexstring) + #13#10;;
    while (fCurrentInputSymbol = _commaSym) do begin
      Get;
      Expect(_stringSym);
      CodeSnippetData[codesnippetcnt].Lines :=
        CodeSnippetData[codesnippetcnt].Lines + parse_string(lexstring) + #13#10;;
    end;
  end;
  Expect(_rbraceSym);
  Expect(_semicolonSym);
  Inc(codesnippetcnt);;
end;

procedure TCodeSnippets._CodeSnippets;begin
  Init;;
  _CodePreset;
  while (fCurrentInputSymbol = CodePresetSym) do begin
    _CodePreset;
  end;
  Final;;
end;

function TCodeSnippets.GetMajorVersion: integer;
begin
  Result := 1;
end;

function TCodeSnippets.GetMinorVersion: integer;
begin
  Result := 0;
end;

function TCodeSnippets.GetRelease: integer;
begin
  Result := 0;
end;

function TCodeSnippets.GetBuild: integer;
begin
  Result := 5;
end;

function TCodeSnippets.GetBuildDate: TDateTime;
const
  BDate = 38573;
  Hour  = 15;
  Min   = 36;
begin
  Result := BDate + EncodeTime(Hour, Min, 0, 0);
end;

function TCodeSnippets.GetVersion: string;
var
  MinorVersionStr: string;
begin
  MinorVersionStr := IntToStr(MinorVersion);
  if (length(MinorVersionStr) > 0) and (MinorVersion > 0) then
    MinorVersionStr := '0' + MinorVersionStr;
  Result          := 'Version: ' + IntToStr(MajorVersion) + '.' + MinorVersionStr + ' Release ' +
    IntToStr(Release) + ' Build ' + IntToStr(Build);
end;

function TCodeSnippets.GetVersionComment: string;
begin
  Result := 'FMFDLGTool Code Snippets parser';
end;

function TCodeSnippets.GetGrammarAuthor: string;
begin
  Result := 'T. Pitkänen';
end;

function TCodeSnippets.GetGrammarCopyright: string;
begin
  Result := '(c) 2005 Dj Unique';
end;

procedure TCodeSnippets.SetVersion(const Value: string);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TCodeSnippets.Parse;
begin
  errDist := minErrDist;
  GetScanner._Reset;
  Get;
  _CodeSnippets;
end;  {Parse}

procedure TCodeSnippets.InitSymSet;
begin
  symSet[0, 0] := [EOFSYMB];
  symSet[0, 1] := [];
  symSet[1, 0] := [identifierSym, boolSym, intSym, statSym, skillSym, script_underscorevarSym,
    pid_underscoreidSym, map_underscorevarSym, local_underscorevarSym, nodeSym, floatnodeSym];
  symSet[1, 1] := [stringSym - 16];
end; {InitSymSet}

end { CodeSnippets }.
                
