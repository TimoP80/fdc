unit SSLParser;




{ SSLParser
  Version: 1.0 Release 0 Build 0
  Fallout 2 SSL Parser
  Date of Generation: 18.6.2008 18:30
  Author: T. Pitkänen
  (c) 2008 T. Pitkänen

  This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
  this file that you edit manually will be over-written when the file is
  regenerated.
}

interface
uses  SysUtils,Classes,CocoBase,mwStringHashList;



const
maxT = 59;
maxP = 60;
type
  SymbolSet = array[0..maxT div setsize] of TBitSet;

  ESSLParser = class(Exception);
  TSSLParser = class;

  TSSLParserScanner = class(TCocoRScanner)
  private
    FOwner : TSSLParser;
    fLastCommentList : TCommentList;
fHashList: TmwStringHashList;
procedure CheckLiteral(var Sym : integer);
function GetNextSymbolString: string;
    function Comment : boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;
destructor Destroy; override;

    procedure Get(var sym : integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner : TSSLParser read fOwner write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TSSLParserScanner }

  TSSLParser = class(TCocoRGrammar)
  private
    { strictly internal variables }
    symSet : array[0..5] of SymbolSet; // symSet[0] = allSyncSyms
    fInternalGrammarComment : TCommentEvent;

    function GetMajorVersion : integer;
    function GetMinorVersion : integer;
    function GetRelease : integer;
    function GetBuild : integer;
    function GetBuildDate : TDateTime;
    function GetVersionComment : string;
    function GetGrammarAuthor : string;
    function GetGrammarCopyright : string;
    function GetVersion : String;
    procedure SetVersion(const Value : string);
    function _In(var s : SymbolSet; x : integer) : boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _ActualParameters;
    procedure _FunctionCall;
    procedure _Primary;
    procedure _UnaryOperator;
    procedure _PostFixExp;
    procedure _UnaryExp;
    procedure _CastExp;
    procedure _MultExp;
    procedure _AddExp;
    procedure _ShiftExp;
    procedure _RelationExp;
    procedure _EqualExp;
    procedure _ANDExp;
    procedure _ExclORExp;
    procedure _InclORExp;
    procedure _LogANDExp;
    procedure _LogORExp;
    procedure _AssignmentOperator;
    procedure _Conditional;
    procedure _LocalDeclaration;
    procedure _Expression;
    procedure _ConstExpression;
    procedure _WhileStatement;
    procedure _SwitchStatement;
    procedure _ReturnStatement;
    procedure _IfStatement;
    procedure _ForStatement;
    procedure _DoStatement;
    procedure _ContinueStatement;
    procedure _BreakStatement;
    procedure _AssignmentExpression;
    procedure _LabelC;
    procedure _Statement;
    procedure _FormalParameter;
    procedure _CompoundStatement;
    procedure _FormalParamList;
    procedure _FunctionBody;
    procedure _FunctionHeader;
    procedure _VarList;
    procedure _FunctionDefinition;
    procedure _Definition;
    procedure _SSLParser;

  private
    fOutputStream : TMemoryStream;
    fSubSelectDepth : integer;
    fInNaturalJoin : boolean;
            
    procedure Init;
    procedure Final;
                
    property OutputStream : TMemoryStream read fOutputStream write fOutputStream;
    
  protected
    { Protected Declarations }
    procedure Get; override;
    property InternalGrammarComment : TCommentEvent read fInternalGrammarComment write fInternalGrammarComment;
  public
    { Public Declarations }
    constructor Create(AOwner : TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode : integer; const Data : string) : string; override;
    procedure Execute;
    function GetScanner : TSSLParserScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property MajorVersion : integer read GetMajorVersion;
    property MinorVersion : integer read GetMinorVersion;
    property Release : integer read GetRelease;
    property Build : integer read GetBuild;
    property BuildDate : TDateTime read GetBuildDate;
    property VersionComment : string read GetVersionComment;
    property GrammarAuthor : string read GetGrammarAuthor;
    property GrammarCopyright : string read GetGrammarCopyright;

  published
    { Published Declarations }
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
property Version : string read GetVersion write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TSSLParser }

implementation



const

  EOFSYMB = 0;  identifierSym = 1;  numberSym = 2;  hexnumberSym = 3;
  _stringSym = 4;  _charSym = 5;  _librarySym = 6;  PROCEDURESym = 7;
  IMPORTSym = 8;  EXPORTSym = 9;  VARIABLESym = 10;  _semicolonSym = 11;
  _commaSym = 12;  _colon_equalSym = 13;  _lparenSym = 14;  _rparenSym = 15;
  CASESym = 16;  _colonSym = 17;  DEFAULTSym = 18;  BREAKSym = 19;
  BEGINSym = 20;  ENDSym = 21;  CONTINUESym = 22;  DOSym = 23;  WHILESym = 24;
  FORSym = 25;  IFSym = 26;  THENSym = 27;  ELSESym = 28;  RETURNSym = 29;
  SWITCHSym = 30;  ANDSym = 31;  ORSym = 32;  BWORSym = 33;  BWANDSym = 34;
  _andSym = 35;  _equal_equalSym = 36;  _bang_equalSym = 37;
  _less_equalSym = 38;  _greater_equalSym = 39;  _lessSym = 40;
  _greaterSym = 41;  _less_lessSym = 42;  _greater_greaterSym = 43;
  _plusSym = 44;  _minusSym = 45;  _starSym = 46;  _slashSym = 47;
  _percentSym = 48;  CALLSym = 49;  _lbrackSym = 50;  _rbrackSym = 51;
  _star_equalSym = 52;  _slash_equalSym = 53;  _percent_equalSym = 54;
  _plus_equalSym = 55;  _minus_equalSym = 56;  _bangSym = 57;  _tildeSym = 58;
  NOSYMB = 59;  PreProcessorSym = 60;  _noSym = NOSYMB;   {error token code}

{ --------------------------------------------------------------------------- }
{ Arbitrary Code from ATG file }
const
  PadLen = 20;
                        
function PadR(S : string; Ch : char; L : integer) : string;
var
  i : integer;
begin
  for i := 1 to L - (Length(s)) do
    s := s + Ch;
  Result := s;
end;

procedure TSSLParser.Init;
begin
  OutputStream.Clear;

 end;

procedure TSSLParser.Final;
begin
   OutputStream.Position := 0;
  OutputStream.SaveToStream(ListStream);
  OutputStream.Clear;
end;
                                 
function parse_string(zstr: string): string;
var t:    integer;
var temp: string;
var len:  integer;
begin;
result:='';
  len := 0;
temp:='';
  //writeln ('Parsing string: ',zstr);
  t   := pos('"', zstr) + 1;
  len := length(zstr);
  while (zstr[t] <> '"') do
  begin;
    //writeln (zstr[t]);
    if (zstr[t] = '\') and (zstr[t + 1] = '"') then
    begin;
      temp := temp + '"';
      Inc(t, 1);
    end else
    if (zstr[t] = '\') and (zstr[t + 1] = '\') then
    begin;
      temp := temp + '\';
      Inc(t, 1);
    end else
    if (zstr[t] = '\') and (zstr[t + 1] = 't') then
    begin;
      temp := temp + #9;
      Inc(t, 1);
    end else
    if (zstr[t] = '\') and (zstr[t + 1] = 'n') then
    begin;
      temp := temp + #13#10;
      Inc(t, 1);
    end else

      temp := temp + zstr[t];

    Inc(t);
  end;
  Result := temp;
end;




(* End of Arbitrary Code *)



{ --------------------------------------------------------------------------- }
{ ---- implementation for TSSLParserScanner ---- }

procedure TSSLParserScanner.NextCh;
{ Return global variable ch }
begin
  LastInputCh := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  SrcStream.Seek(BufferPosition,soFromBeginning);
  CurrInputCh := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) OR ((CurrInputCh = _LF) AND (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner,IntToStr(CurrLine),CurrLine);
    StartOfLine := BufferPosition;
  end
end;  {NextCh}

function TSSLParserScanner.Comment : boolean;
var
  level : integer;
  CommentColumn : integer;
  CommentLine : integer;
  startLine : integer;
  oldLineStart : longint;
  CommentStr : string;
begin
  level := 1;
  startLine := CurrLine;
  oldLineStart := StartOfLine;
  CommentStr := CharAt(BufferPosition);
  CommentColumn := BufferPosition - StartOfLine - 1;
  CommentLine := CurrLine;
Result := false;
if (CurrInputCh = '/') then
  begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '/') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
while true do
begin
if (CurrInputCh = CHR(13)) then
begin
level := level - 1;
NumEOLInComment := CurrLine - startLine;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
fLastCommentList.Add(CommentStr, CommentLine, CommentColumn);
  Exit;
end;
end
else if CurrInputCh = _EF then
begin
  Result := false;
fLastCommentList.Add(CommentStr, CommentLine, CommentColumn);
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
end
else
begin
if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
begin
CurrLine := CurrLine - 1;
StartOfLine := oldLineStart
end;
BufferPosition := BufferPosition - 1;
CurrInputCh := LastInputCh;
Result := false;
end;
end;
Result := false;
if (CurrInputCh = '/') then
  begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '*') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
while true do
begin
if (CurrInputCh = '*') then
begin
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if (CurrInputCh = '/') then
begin
level := level - 1;
NextCh;
CommentStr := CommentStr + CharAt(BufferPosition);
if level = 0 then
begin
  Result := true;
fLastCommentList.Add(CommentStr, CommentLine, CommentColumn);
  Exit;
end
end
end
else if CurrInputCh = _EF then
begin
  Result := false;
fLastCommentList.Add(CommentStr, CommentLine, CommentColumn);
  Exit;
end
else
begin
  NextCh;
  CommentStr := CommentStr + CharAt(BufferPosition);
end;
end; { WHILE TRUE }
end
else
begin
if (CurrInputCh = _CR) OR (CurrInputCh = _LF) then
begin
CurrLine := CurrLine - 1;
StartOfLine := oldLineStart
end;
BufferPosition := BufferPosition - 1;
CurrInputCh := LastInputCh;
Result := false;
end;
end;
end;  { Comment }

function TSSLParserScanner.GetNextSymbolString: string;
var
  i: integer;
  q: integer;
begin
  Result := '';
  i := 1;
  q := bpCurrToken;
  while i <= NextSymbol.Len do
  begin
    Result := Result + CurrentCh(q);
    inc(q);
    inc(i);
  end;
end; {GetNextSymbolString}

procedure TSSLParserScanner.CheckLiteral(var Sym : integer);
var
  SymId : integer;
  DefaultSymId : integer;
  aToken : string;
begin
  aToken := GetNextSymbolString;
  if fHashList.Hash(aToken, SymId, DefaultSymId) then
  begin
      sym := SymId;
  end;
end; {CheckLiteral}


procedure TSSLParserScanner.Get(var sym : integer);
var
  state : integer;
begin   {Get}
while (CurrInputCh = ' ') OR
((CurrInputCh >= CHR(1)) AND (CurrInputCh <= ' ')) do
  NextCh;
if ((CurrInputCh = '/') OR (CurrInputCh = '/')) AND Comment then
begin
  Get(sym);
  exit;
  end;
  CurrentSymbol.pos := NextSymbol.Pos;
  NextSymbol.Pos := BufferPosition;
  CurrentSymbol.col := NextSymbol.Col;
  NextSymbol.Col := BufferPosition - StartOfLine;
  CurrentSymbol.line := NextSymbol.Line;
  NextSymbol.Line := CurrLine;
  CurrentSymbol.Len := NextSymbol.Len;
  NextSymbol.Len := 0;
  ContextLen := 0;
  state := StartState[ORD(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while true do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym := EOFSYMB;
      CurrInputCh := _EF;
      BufferPosition := BufferPosition - 1;
      exit
    end;
    case state of
   1: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '_')) then
begin
 
end
else
begin
sym := identifierSym;
CheckLiteral(sym);
exit;
end;
   2: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 3; 
end
else if (CurrInputCh = '=') then
begin
state := 47; 
end
else
begin
sym := _minusSym;
exit;
end;
   3: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'L') OR
(CurrInputCh = 'U')) then
begin
state := 18; 
end
else if (CurrInputCh = '.') then
begin
state := 4; 
end
else
begin
sym := numberSym;
exit;
end;
   4: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
 
end
else if ((CurrInputCh = 'L') OR
(CurrInputCh = 'U')) then
begin
state := 18; 
end
else
begin
sym := numberSym;
exit;
end;
   5: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F')) then
begin
state := 6; 
end
else
begin
  sym := _noSym;
exit;
end;
   6: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'F')) then
begin
 
end
else if ((CurrInputCh = 'L') OR
(CurrInputCh = 'U')) then
begin
state := 19; 
end
else
begin
sym := hexnumberSym;
exit;
end;
   7: if ((CurrInputCh >= ' ') AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#')) then
begin
state := 8; 
end
else if (CurrInputCh = '"') then
begin
state := 9; 
end
else
begin
  sym := _noSym;
exit;
end;
   8: if ((CurrInputCh >= ' ') AND (CurrInputCh <= '!') OR
(CurrInputCh >= '#')) then
begin
 
end
else if (CurrInputCh = '"') then
begin
state := 9; 
end
else
begin
  sym := _noSym;
exit;
end;
   9: begin
sym := _stringSym;
exit;
end;
  10: if ((CurrInputCh >= ' ') AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(') AND (CurrInputCh <= '[') OR
(CurrInputCh >= ']')) then
begin
state := 11; 
end
else if (CurrInputCh = '\') then
begin
state := 20; 
end
else
begin
  sym := _noSym;
exit;
end;
  11: if (CurrInputCh = CHR(39)) then
begin
state := 12; 
end
else
begin
  sym := _noSym;
exit;
end;
  12: begin
sym := _charSym;
exit;
end;
  13: if ((CurrInputCh = '.') OR
(CurrInputCh >= '0') AND (CurrInputCh <= ':') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '\')) then
begin
state := 14; 
end
else if (CurrInputCh = '=') then
begin
state := 32; 
end
else if (CurrInputCh = '<') then
begin
state := 35; 
end
else
begin
sym := _lessSym;
exit;
end;
  14: if ((CurrInputCh = '.') OR
(CurrInputCh >= '0') AND (CurrInputCh <= ':') OR
(CurrInputCh >= 'A') AND (CurrInputCh <= 'Z') OR
(CurrInputCh = '\')) then
begin
 
end
else if (CurrInputCh = '>') then
begin
state := 15; 
end
else
begin
  sym := _noSym;
exit;
end;
  15: begin
sym := _librarySym;
exit;
end;
  16: if NOT ((CurrInputCh = CHR(13))) then
begin
 
end
else
begin
sym := PreProcessorSym;
exit;
end;
  17: if ((CurrInputCh >= '0') AND (CurrInputCh <= '9')) then
begin
state := 3; 
end
else if ((CurrInputCh = 'L') OR
(CurrInputCh = 'U')) then
begin
state := 18; 
end
else if (CurrInputCh = '.') then
begin
state := 4; 
end
else if (CurrInputCh = 'X') then
begin
state := 5; 
end
else
begin
sym := numberSym;
exit;
end;
  18: begin
sym := numberSym;
exit;
end;
  19: begin
sym := hexnumberSym;
exit;
end;
  20: if ((CurrInputCh >= ' ') AND (CurrInputCh <= '&') OR
(CurrInputCh >= '(')) then
begin
state := 11; 
end
else if (CurrInputCh = CHR(39)) then
begin
state := 12; 
end
else
begin
  sym := _noSym;
exit;
end;
  21: begin
sym := _semicolonSym;
exit;
end;
  22: begin
sym := _commaSym;
exit;
end;
  23: if (CurrInputCh = '=') then
begin
state := 24; 
end
else
begin
sym := _colonSym;
exit;
end;
  24: begin
sym := _colon_equalSym;
exit;
end;
  25: begin
sym := _lparenSym;
exit;
end;
  26: begin
sym := _rparenSym;
exit;
end;
  27: begin
sym := _andSym;
exit;
end;
  28: if (CurrInputCh = '=') then
begin
state := 29; 
end
else
begin
  sym := _noSym;
exit;
end;
  29: begin
sym := _equal_equalSym;
exit;
end;
  30: if (CurrInputCh = '=') then
begin
state := 31; 
end
else
begin
sym := _bangSym;
exit;
end;
  31: begin
sym := _bang_equalSym;
exit;
end;
  32: begin
sym := _less_equalSym;
exit;
end;
  33: if (CurrInputCh = '=') then
begin
state := 34; 
end
else if (CurrInputCh = '>') then
begin
state := 36; 
end
else
begin
sym := _greaterSym;
exit;
end;
  34: begin
sym := _greater_equalSym;
exit;
end;
  35: begin
sym := _less_lessSym;
exit;
end;
  36: begin
sym := _greater_greaterSym;
exit;
end;
  37: if (CurrInputCh = '=') then
begin
state := 46; 
end
else
begin
sym := _plusSym;
exit;
end;
  38: if (CurrInputCh = '=') then
begin
state := 43; 
end
else
begin
sym := _starSym;
exit;
end;
  39: if (CurrInputCh = '=') then
begin
state := 44; 
end
else
begin
sym := _slashSym;
exit;
end;
  40: if (CurrInputCh = '=') then
begin
state := 45; 
end
else
begin
sym := _percentSym;
exit;
end;
  41: begin
sym := _lbrackSym;
exit;
end;
  42: begin
sym := _rbrackSym;
exit;
end;
  43: begin
sym := _star_equalSym;
exit;
end;
  44: begin
sym := _slash_equalSym;
exit;
end;
  45: begin
sym := _percent_equalSym;
exit;
end;
  46: begin
sym := _plus_equalSym;
exit;
end;
  47: begin
sym := _minus_equalSym;
exit;
end;
  48: begin
sym := _tildeSym;
exit;
end;
  49: begin
sym := EOFSYMB;
CurrInputCh := #0;
BufferPosition := BufferPosition - 1;
exit
end;
    else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TSSLParserScanner.Create;
begin
  inherited;
fHashList := TmwStringHashList.Create(ITinyHash, HashSecondaryOne, IHashCompare);
fHashList.AddString('AND', ANDSym, ANDSym);
fHashList.AddString('BEGIN', BEGINSym, BEGINSym);
fHashList.AddString('BREAK', BREAKSym, BREAKSym);
fHashList.AddString('BWAND', BWANDSym, BWANDSym);
fHashList.AddString('BWOR', BWORSym, BWORSym);
fHashList.AddString('CALL', CALLSym, CALLSym);
fHashList.AddString('CASE', CASESym, CASESym);
fHashList.AddString('CONTINUE', CONTINUESym, CONTINUESym);
fHashList.AddString('DEFAULT', DEFAULTSym, DEFAULTSym);
fHashList.AddString('DO', DOSym, DOSym);
fHashList.AddString('ELSE', ELSESym, ELSESym);
fHashList.AddString('END', ENDSym, ENDSym);
fHashList.AddString('EXPORT', EXPORTSym, EXPORTSym);
fHashList.AddString('FOR', FORSym, FORSym);
fHashList.AddString('IF', IFSym, IFSym);
fHashList.AddString('IMPORT', IMPORTSym, IMPORTSym);
fHashList.AddString('OR', ORSym, ORSym);
fHashList.AddString('PROCEDURE', PROCEDURESym, PROCEDURESym);
fHashList.AddString('RETURN', RETURNSym, RETURNSym);
fHashList.AddString('SWITCH', SWITCHSym, SWITCHSym);
fHashList.AddString('THEN', THENSym, THENSym);
fHashList.AddString('VARIABLE', VARIABLESym, VARIABLESym);
fHashList.AddString('WHILE', WHILESym, WHILESym);
fLastCommentList := TCommentList.Create;CurrentCh := CapChAt;
fStartState[  0] := 49; fStartState[  1] := 50; fStartState[  2] := 50; fStartState[  3] := 50; 
fStartState[  4] := 50; fStartState[  5] := 50; fStartState[  6] := 50; fStartState[  7] := 50; 
fStartState[  8] := 50; fStartState[  9] := 50; fStartState[ 10] := 50; fStartState[ 11] := 50; 
fStartState[ 12] := 50; fStartState[ 13] := 50; fStartState[ 14] := 50; fStartState[ 15] := 50; 
fStartState[ 16] := 50; fStartState[ 17] := 50; fStartState[ 18] := 50; fStartState[ 19] := 50; 
fStartState[ 20] := 50; fStartState[ 21] := 50; fStartState[ 22] := 50; fStartState[ 23] := 50; 
fStartState[ 24] := 50; fStartState[ 25] := 50; fStartState[ 26] := 50; fStartState[ 27] := 50; 
fStartState[ 28] := 50; fStartState[ 29] := 50; fStartState[ 30] := 50; fStartState[ 31] := 50; 
fStartState[ 32] := 50; fStartState[ 33] := 30; fStartState[ 34] :=  7; fStartState[ 35] := 16; 
fStartState[ 36] := 50; fStartState[ 37] := 40; fStartState[ 38] := 27; fStartState[ 39] := 10; 
fStartState[ 40] := 25; fStartState[ 41] := 26; fStartState[ 42] := 38; fStartState[ 43] := 37; 
fStartState[ 44] := 22; fStartState[ 45] :=  2; fStartState[ 46] := 50; fStartState[ 47] := 39; 
fStartState[ 48] := 17; fStartState[ 49] :=  3; fStartState[ 50] :=  3; fStartState[ 51] :=  3; 
fStartState[ 52] :=  3; fStartState[ 53] :=  3; fStartState[ 54] :=  3; fStartState[ 55] :=  3; 
fStartState[ 56] :=  3; fStartState[ 57] :=  3; fStartState[ 58] := 23; fStartState[ 59] := 21; 
fStartState[ 60] := 13; fStartState[ 61] := 28; fStartState[ 62] := 33; fStartState[ 63] := 50; 
fStartState[ 64] := 50; fStartState[ 65] :=  1; fStartState[ 66] :=  1; fStartState[ 67] :=  1; 
fStartState[ 68] :=  1; fStartState[ 69] :=  1; fStartState[ 70] :=  1; fStartState[ 71] :=  1; 
fStartState[ 72] :=  1; fStartState[ 73] :=  1; fStartState[ 74] :=  1; fStartState[ 75] :=  1; 
fStartState[ 76] :=  1; fStartState[ 77] :=  1; fStartState[ 78] :=  1; fStartState[ 79] :=  1; 
fStartState[ 80] :=  1; fStartState[ 81] :=  1; fStartState[ 82] :=  1; fStartState[ 83] :=  1; 
fStartState[ 84] :=  1; fStartState[ 85] :=  1; fStartState[ 86] :=  1; fStartState[ 87] :=  1; 
fStartState[ 88] :=  1; fStartState[ 89] :=  1; fStartState[ 90] :=  1; fStartState[ 91] := 41; 
fStartState[ 92] := 50; fStartState[ 93] := 42; fStartState[ 94] := 50; fStartState[ 95] :=  1; 
fStartState[ 96] := 50; fStartState[ 97] := 50; fStartState[ 98] := 50; fStartState[ 99] := 50; 
fStartState[100] := 50; fStartState[101] := 50; fStartState[102] := 50; fStartState[103] := 50; 
fStartState[104] := 50; fStartState[105] := 50; fStartState[106] := 50; fStartState[107] := 50; 
fStartState[108] := 50; fStartState[109] := 50; fStartState[110] := 50; fStartState[111] := 50; 
fStartState[112] := 50; fStartState[113] := 50; fStartState[114] := 50; fStartState[115] := 50; 
fStartState[116] := 50; fStartState[117] := 50; fStartState[118] := 50; fStartState[119] := 50; 
fStartState[120] := 50; fStartState[121] := 50; fStartState[122] := 50; fStartState[123] := 50; 
fStartState[124] := 50; fStartState[125] := 50; fStartState[126] := 48; fStartState[127] := 50; 
fStartState[128] := 50; fStartState[129] := 50; fStartState[130] := 50; fStartState[131] := 50; 
fStartState[132] := 50; fStartState[133] := 50; fStartState[134] := 50; fStartState[135] := 50; 
fStartState[136] := 50; fStartState[137] := 50; fStartState[138] := 50; fStartState[139] := 50; 
fStartState[140] := 50; fStartState[141] := 50; fStartState[142] := 50; fStartState[143] := 50; 
fStartState[144] := 50; fStartState[145] := 50; fStartState[146] := 50; fStartState[147] := 50; 
fStartState[148] := 50; fStartState[149] := 50; fStartState[150] := 50; fStartState[151] := 50; 
fStartState[152] := 50; fStartState[153] := 50; fStartState[154] := 50; fStartState[155] := 50; 
fStartState[156] := 50; fStartState[157] := 50; fStartState[158] := 50; fStartState[159] := 50; 
fStartState[160] := 50; fStartState[161] := 50; fStartState[162] := 50; fStartState[163] := 50; 
fStartState[164] := 50; fStartState[165] := 50; fStartState[166] := 50; fStartState[167] := 50; 
fStartState[168] := 50; fStartState[169] := 50; fStartState[170] := 50; fStartState[171] := 50; 
fStartState[172] := 50; fStartState[173] := 50; fStartState[174] := 50; fStartState[175] := 50; 
fStartState[176] := 50; fStartState[177] := 50; fStartState[178] := 50; fStartState[179] := 50; 
fStartState[180] := 50; fStartState[181] := 50; fStartState[182] := 50; fStartState[183] := 50; 
fStartState[184] := 50; fStartState[185] := 50; fStartState[186] := 50; fStartState[187] := 50; 
fStartState[188] := 50; fStartState[189] := 50; fStartState[190] := 50; fStartState[191] := 50; 
fStartState[192] := 50; fStartState[193] := 50; fStartState[194] := 50; fStartState[195] := 50; 
fStartState[196] := 50; fStartState[197] := 50; fStartState[198] := 50; fStartState[199] := 50; 
fStartState[200] := 50; fStartState[201] := 50; fStartState[202] := 50; fStartState[203] := 50; 
fStartState[204] := 50; fStartState[205] := 50; fStartState[206] := 50; fStartState[207] := 50; 
fStartState[208] := 50; fStartState[209] := 50; fStartState[210] := 50; fStartState[211] := 50; 
fStartState[212] := 50; fStartState[213] := 50; fStartState[214] := 50; fStartState[215] := 50; 
fStartState[216] := 50; fStartState[217] := 50; fStartState[218] := 50; fStartState[219] := 50; 
fStartState[220] := 50; fStartState[221] := 50; fStartState[222] := 50; fStartState[223] := 50; 
fStartState[224] := 50; fStartState[225] := 50; fStartState[226] := 50; fStartState[227] := 50; 
fStartState[228] := 50; fStartState[229] := 50; fStartState[230] := 50; fStartState[231] := 50; 
fStartState[232] := 50; fStartState[233] := 50; fStartState[234] := 50; fStartState[235] := 50; 
fStartState[236] := 50; fStartState[237] := 50; fStartState[238] := 50; fStartState[239] := 50; 
fStartState[240] := 50; fStartState[241] := 50; fStartState[242] := 50; fStartState[243] := 50; 
fStartState[244] := 50; fStartState[245] := 50; fStartState[246] := 50; fStartState[247] := 50; 
fStartState[248] := 50; fStartState[249] := 50; fStartState[250] := 50; fStartState[251] := 50; 
fStartState[252] := 50; fStartState[253] := 50; fStartState[254] := 50; fStartState[255] := 50; 
end; {Create}

destructor TSSLParserScanner.Destroy;
begin
  fHashList.Free;
  fHashList := NIL;
  if Assigned(fLastCommentList) then
  begin
    fLastCommentList.Free;
    fLastCommentList := NIL;
  end;
  inherited;
end;

{ --------------------------------------------------------------------------- }
{ ---- implementation for TSSLParser ---- }

constructor TSSLParser.Create(AOwner : TComponent);
begin
  inherited;
  Scanner := TSSLParserScanner.Create;
  GetScanner.Owner := self;
fOutputStream := TMemoryStream.Create;
  
  InitSymSet;
end; {Create}

destructor TSSLParser.Destroy;
begin
  Scanner.Free;
fOutputStream.Free;
  
  inherited;
end; {Destroy}

function TSSLParser.ErrorStr(const ErrorCode : integer; const Data : string) : string;
begin
  case ErrorCode of
       0 : Result := 'EOF expected';
   1 : Result := 'identifier expected';
   2 : Result := 'number expected';
   3 : Result := 'hexnumber expected';
   4 : Result := '_string expected';
   5 : Result := '_char expected';
   6 : Result := '_library expected';
   7 : Result := '"PROCEDURE" expected';
   8 : Result := '"IMPORT" expected';
   9 : Result := '"EXPORT" expected';
  10 : Result := '"VARIABLE" expected';
  11 : Result := '";" expected';
  12 : Result := '"," expected';
  13 : Result := '":=" expected';
  14 : Result := '"(" expected';
  15 : Result := '")" expected';
  16 : Result := '"CASE" expected';
  17 : Result := '":" expected';
  18 : Result := '"DEFAULT" expected';
  19 : Result := '"BREAK" expected';
  20 : Result := '"BEGIN" expected';
  21 : Result := '"END" expected';
  22 : Result := '"CONTINUE" expected';
  23 : Result := '"DO" expected';
  24 : Result := '"WHILE" expected';
  25 : Result := '"FOR" expected';
  26 : Result := '"IF" expected';
  27 : Result := '"THEN" expected';
  28 : Result := '"ELSE" expected';
  29 : Result := '"RETURN" expected';
  30 : Result := '"SWITCH" expected';
  31 : Result := '"AND" expected';
  32 : Result := '"OR" expected';
  33 : Result := '"BWOR" expected';
  34 : Result := '"BWAND" expected';
  35 : Result := '"&" expected';
  36 : Result := '"==" expected';
  37 : Result := '"!=" expected';
  38 : Result := '"<=" expected';
  39 : Result := '">=" expected';
  40 : Result := '"<" expected';
  41 : Result := '">" expected';
  42 : Result := '"<<" expected';
  43 : Result := '">>" expected';
  44 : Result := '"+" expected';
  45 : Result := '"-" expected';
  46 : Result := '"*" expected';
  47 : Result := '"/" expected';
  48 : Result := '"%" expected';
  49 : Result := '"CALL" expected';
  50 : Result := '"[" expected';
  51 : Result := '"]" expected';
  52 : Result := '"*=" expected';
  53 : Result := '"/=" expected';
  54 : Result := '"%=" expected';
  55 : Result := '"+=" expected';
  56 : Result := '"-=" expected';
  57 : Result := '"!" expected';
  58 : Result := '"~" expected';
  59 : Result := 'not expected';
  60 : Result := 'invalid Primary';
  61 : Result := 'invalid UnaryOperator';
  62 : Result := 'invalid UnaryExp';
  63 : Result := 'invalid AssignmentOperator';
  64 : Result := 'invalid LabelC';
  65 : Result := 'invalid Statement';
  66 : Result := 'invalid VarList';
  67 : Result := 'invalid FunctionDefinition';
  68 : Result := 'invalid Definition';
  69 : Result := 'invalid Definition';


  else
    if Assigned(OnCustomError) then
      Result := OnCustomError(Self, ErrorCode, Data)
    else
    begin
      Result := 'Error: ' + IntToStr(ErrorCode);
      if Trim(Data) > '' then
        Result := Result + ' (' + Data + ')';
    end;
  end;  {case nr}
end; {ErrorStr}

procedure TSSLParser.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  if Assigned(OnStatusUpdate) then
    OnStatusUpdate(Self,'parsing source',-1);

  { instigate the compilation }
  if Assigned(BeforeParse) then
    BeforeParse(Self);
  Parse;
  if Assigned(AfterParse) then
    AfterParse(Self);

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) OR ((GenListWhen = glOnError) AND (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful AND Assigned(OnSuccess) then
    OnSuccess(Self);
  if (NOT Successful) AND Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TSSLParser.Get;
begin
  repeat

if GetScanner.fLastCommentList.Count > 0 then
begin
  if Assigned(fInternalGrammarComment) then
    fInternalGrammarComment(Self,GetScanner.fLastCommentList);
  GetScanner.fLastCommentList.Clear;
end;

    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
case fCurrentInputSymbol of
  PreProcessorSym: begin 
 end;
end;
GetScanner.NextSymbol.Pos := GetScanner.CurrentSymbol.Pos;
GetScanner.NextSymbol.Col := GetScanner.CurrentSymbol.Col;
GetScanner.NextSymbol.Line := GetScanner.CurrentSymbol.Line;
GetScanner.NextSymbol.Len := GetScanner.CurrentSymbol.Len;
    end;
  until fCurrentInputSymbol <= maxT;
end;  {Get}

function TSSLParser.GetScanner : TSSLParserScanner;
begin
  Result := Scanner AS TSSLParserScanner;
end; {GetScanner}

function TSSLParser._In(var s : SymbolSet; x : integer) : boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TSSLParser._ActualParameters;begin
_Expression;
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_Expression;
end;
end;

procedure TSSLParser._FunctionCall;begin
Expect(_lparenSym);
if _In(symSet[1], fCurrentInputSymbol) then begin
_ActualParameters;
end;
Expect(_rparenSym);
end;

procedure TSSLParser._Primary;begin
if (fCurrentInputSymbol = identifierSym) then begin
Get;
end else if (fCurrentInputSymbol = _stringSym) then begin
Get;
end else if (fCurrentInputSymbol = _charSym) then begin
Get;
end else if (fCurrentInputSymbol = numberSym) then begin
Get;
end else if _In(symSet[1], fCurrentInputSymbol) then begin
if (fCurrentInputSymbol = _lparenSym) then begin
Get;
end;
_Expression;
if (fCurrentInputSymbol = _rparenSym) then begin
Get;
end;
end else begin SynError(60);
end;
end;

procedure TSSLParser._UnaryOperator;begin
case fCurrentInputSymbol of
  _plusSym : begin
Get;
    end;
  _minusSym : begin
Get;
    end;
  _starSym : begin
Get;
    end;
  _bangSym : begin
Get;
    end;
  _andSym : begin
Get;
    end;
  _tildeSym : begin
Get;
    end;
else begin SynError(61);
    end;
end;
end;

procedure TSSLParser._PostFixExp;begin
if (fCurrentInputSymbol = CALLSym) then begin
Get;
end;
_Primary;
while (fCurrentInputSymbol = _lparenSym) OR
 (fCurrentInputSymbol = _lbrackSym) do begin
if (fCurrentInputSymbol = _lbrackSym) then begin
Get;
_Expression;
Expect(_rbrackSym);
end else begin
_FunctionCall;
end;
end;
end;

procedure TSSLParser._UnaryExp;begin
if _In(symSet[1], fCurrentInputSymbol) then begin
_PostFixExp;
end else if _In(symSet[1], fCurrentInputSymbol) then begin
_UnaryExp;
end else if _In(symSet[2], fCurrentInputSymbol) then begin
_UnaryOperator;
_CastExp;
end else begin SynError(62);
end;
end;

procedure TSSLParser._CastExp;begin
_UnaryExp;
end;

procedure TSSLParser._MultExp;begin
_CastExp;
while (fCurrentInputSymbol = _starSym) OR
 (fCurrentInputSymbol = _slashSym) OR
 (fCurrentInputSymbol = _percentSym) do begin
if (fCurrentInputSymbol = _starSym) then begin
Get;
end else if (fCurrentInputSymbol = _slashSym) then begin
Get;
end else begin
Get;
end;
_CastExp;
end;
end;

procedure TSSLParser._AddExp;begin
_MultExp;
while (fCurrentInputSymbol = _plusSym) OR
 (fCurrentInputSymbol = _minusSym) do begin
if (fCurrentInputSymbol = _plusSym) then begin
Get;
end else begin
Get;
end;
_MultExp;
end;
end;

procedure TSSLParser._ShiftExp;begin
_AddExp;
while (fCurrentInputSymbol = _less_lessSym) OR
 (fCurrentInputSymbol = _greater_greaterSym) do begin
if (fCurrentInputSymbol = _less_lessSym) then begin
Get;
end else begin
Get;
end;
_AddExp;
end;
end;

procedure TSSLParser._RelationExp;begin
_ShiftExp;
writeln(lexstring);
while (fCurrentInputSymbol = _less_equalSym) OR
 (fCurrentInputSymbol = _greater_equalSym) OR
 (fCurrentInputSymbol = _lessSym) OR
 (fCurrentInputSymbol = _greaterSym) do begin
if (fCurrentInputSymbol = _less_equalSym) then begin
writeln('RELATION EXP <=');
Get;
end else if (fCurrentInputSymbol = _greater_equalSym) then begin
writeln('RELATION EXP >=');
Get;
end else if (fCurrentInputSymbol = _lessSym) then begin
writeln('RELATION EXP <');
Get;
end else begin
writeln('RELATION EXP >');
Get;
end;
_ShiftExp;
end;
end;

procedure TSSLParser._EqualExp;begin
_RelationExp;
while (fCurrentInputSymbol = _equal_equalSym) OR
 (fCurrentInputSymbol = _bang_equalSym) do begin
if (fCurrentInputSymbol = _equal_equalSym) then begin
Get;
end else begin
Get;
end;
_RelationExp;
end;
end;

procedure TSSLParser._ANDExp;begin
_EqualExp;
while (fCurrentInputSymbol = _andSym) do begin
Get;
_EqualExp;
end;
end;

procedure TSSLParser._ExclORExp;begin
_ANDExp;
while (fCurrentInputSymbol = BWANDSym) do begin
Get;
_ANDExp;
end;
end;

procedure TSSLParser._InclORExp;begin
_ExclORExp;
while (fCurrentInputSymbol = BWORSym) do begin
Get;
_ExclORExp;
end;
end;

procedure TSSLParser._LogANDExp;begin
_InclORExp;
while (fCurrentInputSymbol = ORSym) do begin
Get;
_InclORExp;
end;
end;

procedure TSSLParser._LogORExp;begin
_LogANDExp;
while (fCurrentInputSymbol = ANDSym) do begin
Get;
_LogANDExp;
end;
end;

procedure TSSLParser._AssignmentOperator;begin
case fCurrentInputSymbol of
  _colon_equalSym : begin
Get;
    end;
  _star_equalSym : begin
Get;
    end;
  _slash_equalSym : begin
Get;
    end;
  _percent_equalSym : begin
Get;
    end;
  _plus_equalSym : begin
Get;
    end;
  _minus_equalSym : begin
Get;
    end;
else begin SynError(63);
    end;
end;
end;

procedure TSSLParser._Conditional;begin
_LogORExp;
end;

procedure TSSLParser._LocalDeclaration;begin
Expect(VARIABLESym);
Expect(identifierSym);
_VarList;
Expect(_semicolonSym);
end;

procedure TSSLParser._Expression;begin
_Conditional;
while _In(symSet[3], fCurrentInputSymbol) do begin
_AssignmentOperator;
_Expression;
end;
end;

procedure TSSLParser._ConstExpression;begin
_Expression;
end;

procedure TSSLParser._WhileStatement;begin
Expect(WHILESym);
Expect(_lparenSym);
_Expression;
Expect(_rparenSym);
Expect(DOSym);
if (fCurrentInputSymbol = BEGINSym) then begin
Get;
end;
_Statement;
if (fCurrentInputSymbol = ENDSym) then begin
Get;
end;
end;

procedure TSSLParser._SwitchStatement;begin
Expect(SWITCHSym);
Expect(_lparenSym);
_Expression;
Expect(_rparenSym);
_Statement;
end;

procedure TSSLParser._ReturnStatement;begin
Expect(RETURNSym);
if _In(symSet[1], fCurrentInputSymbol) then begin
_Expression;
end;
Expect(_semicolonSym);
end;

procedure TSSLParser._IfStatement;begin
Expect(IFSym);
while _In(symSet[1], fCurrentInputSymbol) do begin
_Expression;
end;
Expect(THENSym);
_Statement;
if (fCurrentInputSymbol = ELSESym) then begin
Get;
_Statement;
end;
end;

procedure TSSLParser._ForStatement;begin
Expect(FORSym);
Expect(_lparenSym);
if _In(symSet[1], fCurrentInputSymbol) then begin
_Expression;
end;
Expect(_semicolonSym);
if _In(symSet[1], fCurrentInputSymbol) then begin
_Expression;
end;
Expect(_semicolonSym);
if _In(symSet[1], fCurrentInputSymbol) then begin
_Expression;
end;
Expect(_rparenSym);
_Statement;
end;

procedure TSSLParser._DoStatement;begin
Expect(DOSym);
_Statement;
Expect(WHILESym);
Expect(_lparenSym);
_Expression;
Expect(_rparenSym);
Expect(_semicolonSym);
end;

procedure TSSLParser._ContinueStatement;begin
Expect(CONTINUESym);
Expect(_semicolonSym);
end;

procedure TSSLParser._BreakStatement;begin
Expect(BREAKSym);
Expect(_semicolonSym);
end;

procedure TSSLParser._AssignmentExpression;begin
_Expression;
if (fCurrentInputSymbol = _semicolonSym) then begin
Get;
end;
end;

procedure TSSLParser._LabelC;begin
if (fCurrentInputSymbol = CASESym) then begin
Get;
_ConstExpression;
Expect(_colonSym);
end else if (fCurrentInputSymbol = DEFAULTSym) then begin
Get;
Expect(_colonSym);
end else begin SynError(64);
end;
end;

procedure TSSLParser._Statement;begin
while (fCurrentInputSymbol = CASESym) OR
 (fCurrentInputSymbol = DEFAULTSym) do begin
_LabelC;
end;
case fCurrentInputSymbol of
  identifierSym, numberSym, _stringSym, _charSym, _lparenSym, _andSym, _plusSym, 
      _minusSym, _starSym, CALLSym, _bangSym, _tildeSym : begin
_AssignmentExpression;
    end;
  BREAKSym : begin
_BreakStatement;
    end;
  BEGINSym : begin
_CompoundStatement;
    end;
  CONTINUESym : begin
_ContinueStatement;
    end;
  DOSym : begin
_DoStatement;
    end;
  FORSym : begin
_ForStatement;
    end;
  IFSym : begin
_IfStatement;
    end;
  RETURNSym : begin
_ReturnStatement;
    end;
  SWITCHSym : begin
_SwitchStatement;
    end;
  WHILESym : begin
_WhileStatement;
    end;
else begin SynError(65);
    end;
end;
end;

procedure TSSLParser._FormalParameter;begin
Expect(VARIABLESym);
if (fCurrentInputSymbol = identifierSym) then begin
Get;
end;
end;

procedure TSSLParser._CompoundStatement;begin
Expect(BEGINSym);
writeln('COMPOUND  STATEMENT!');
if _In(symSet[4], fCurrentInputSymbol) then begin
while (fCurrentInputSymbol = VARIABLESym) do begin
_LocalDeclaration;
end;
while _In(symSet[5], fCurrentInputSymbol) do begin
_Statement;
end;
end;
Expect(ENDSym);
end;

procedure TSSLParser._FormalParamList;begin
_FormalParameter;
while (fCurrentInputSymbol = _commaSym) do begin
Get;
_FormalParameter;
end;
end;

procedure TSSLParser._FunctionBody;begin
_CompoundStatement;
end;

procedure TSSLParser._FunctionHeader;begin
Expect(_lparenSym);
if (fCurrentInputSymbol = VARIABLESym) then begin
_FormalParamList;
end;
Expect(_rparenSym);
end;

procedure TSSLParser._VarList;begin
while (fCurrentInputSymbol = _commaSym) do begin
Get;
Expect(identifierSym);
end;
if (fCurrentInputSymbol = _colon_equalSym) then begin
Get;
if (fCurrentInputSymbol = _stringSym) then begin
Get;
end else if (fCurrentInputSymbol = numberSym) then begin
Get;
end else begin SynError(66);
end;
end;
end;

procedure TSSLParser._FunctionDefinition;begin
writeln('function  def!');
if (fCurrentInputSymbol = _lparenSym) then begin
_FunctionHeader;
end;
if (fCurrentInputSymbol = _semicolonSym) then begin
Get;
writeln('function  header  ENDS!')
end else if (fCurrentInputSymbol = BEGINSym) then begin
_FunctionBody;
end else begin SynError(67);
end;
end;

procedure TSSLParser._Definition;begin
if (fCurrentInputSymbol = PROCEDURESym) then begin
Get;
end else if (fCurrentInputSymbol = IMPORTSym) OR
 (fCurrentInputSymbol = EXPORTSym) OR
 (fCurrentInputSymbol = VARIABLESym) then begin
if (fCurrentInputSymbol = IMPORTSym) OR
 (fCurrentInputSymbol = EXPORTSym) then begin
if (fCurrentInputSymbol = IMPORTSym) then begin
Get;
end else begin
Get;
end;
end;
Expect(VARIABLESym);
end else begin SynError(68);
end;
Expect(identifierSym);
writeln('definition:  ',lexstring);
if (fCurrentInputSymbol = _semicolonSym) OR
 (fCurrentInputSymbol = _lparenSym) OR
 (fCurrentInputSymbol = BEGINSym) then begin
_FunctionDefinition;
end else if (fCurrentInputSymbol = _semicolonSym) OR
 (fCurrentInputSymbol = _commaSym) OR
 (fCurrentInputSymbol = _colon_equalSym) then begin
_VarList;
Expect(_semicolonSym);
end else begin SynError(69);
end;
end;

procedure TSSLParser._SSLParser;begin
while (fCurrentInputSymbol = PROCEDURESym) OR
 (fCurrentInputSymbol = IMPORTSym) OR
 (fCurrentInputSymbol = EXPORTSym) OR
 (fCurrentInputSymbol = VARIABLESym) do begin
_Definition;
end;
if GetScanner.fLastCommentList.Count > 0 then
begin
  if Assigned(fInternalGrammarComment) then
    fInternalGrammarComment(Self,GetScanner.fLastCommentList);
  GetScanner.fLastCommentList.Clear;
end;
end;

function TSSLParser.GetMajorVersion : integer;
begin
  Result := 1;
end;

function TSSLParser.GetMinorVersion : integer;
begin
  Result := 0;
end;

function TSSLParser.GetRelease : integer;
begin
  Result := 0;
end;

function TSSLParser.GetBuild : integer;
begin
  Result := 0;
end;

function TSSLParser.GetBuildDate : TDateTime;
const
  BDate = 39617;
  Hour = 18;
  Min = 30;
begin
  Result := BDate + EncodeTime(Hour, Min, 0 ,0);
end;

function TSSLParser.GetVersion : string;
var
  MinorVersionStr : string;
begin
  MinorVersionStr := IntToStr(MinorVersion);
  if (length(MinorVersionStr) > 0) AND (MinorVersion > 0) then
    MinorVersionStr := '0' + MinorVersionStr;
  Result := 'Version: ' + IntToStr(MajorVersion) + '.' + MinorVersionStr + ' Release '
     + IntToStr(Release) + ' Build ' + IntToStr(Build);
end;

function TSSLParser.GetVersionComment : string;
begin
  Result := 'Fallout 2 SSL Parser';
end;

function TSSLParser.GetGrammarAuthor : string;
begin
  Result := 'T. Pitkänen';
end;

function TSSLParser.GetGrammarCopyright : string;
begin
  Result := '(c) 2008 T. Pitkänen';
end;

procedure TSSLParser.SetVersion(const Value : string);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TSSLParser.Parse;
begin
  errDist := minErrDist;
GetScanner._Reset;
Get;
_SSLParser;
end;  {Parse}

procedure TSSLParser.InitSymSet;
begin
symSet[ 0, 0] := [EOFSYMB];
symSet[ 0, 1] := [];
symSet[ 0, 2] := [];
symSet[ 0, 3] := [];
symSet[ 1, 0] := [identifierSym, numberSym, _stringSym, _charSym, 
                    _lparenSym];
symSet[ 1, 1] := [];
symSet[ 1, 2] := [_andSym-32, _plusSym-32, _minusSym-32, _starSym-32];
symSet[ 1, 3] := [CALLSym-48, _bangSym-48, _tildeSym-48];
symSet[ 2, 0] := [];
symSet[ 2, 1] := [];
symSet[ 2, 2] := [_andSym-32, _plusSym-32, _minusSym-32, _starSym-32];
symSet[ 2, 3] := [_bangSym-48, _tildeSym-48];
symSet[ 3, 0] := [_colon_equalSym];
symSet[ 3, 1] := [];
symSet[ 3, 2] := [];
symSet[ 3, 3] := [_star_equalSym-48, _slash_equalSym-48, _percent_equalSym-48, 
                    _plus_equalSym-48, _minus_equalSym-48];
symSet[ 4, 0] := [identifierSym, numberSym, _stringSym, _charSym, 
                    VARIABLESym, _lparenSym];
symSet[ 4, 1] := [CASESym-16, DEFAULTSym-16, BREAKSym-16, BEGINSym-16, 
                    ENDSym-16, CONTINUESym-16, DOSym-16, WHILESym-16, FORSym-16, 
                    IFSym-16, RETURNSym-16, SWITCHSym-16];
symSet[ 4, 2] := [_andSym-32, _plusSym-32, _minusSym-32, _starSym-32];
symSet[ 4, 3] := [CALLSym-48, _bangSym-48, _tildeSym-48];
symSet[ 5, 0] := [identifierSym, numberSym, _stringSym, _charSym, 
                    _lparenSym];
symSet[ 5, 1] := [CASESym-16, DEFAULTSym-16, BREAKSym-16, BEGINSym-16, 
                    CONTINUESym-16, DOSym-16, WHILESym-16, FORSym-16, IFSym-16, 
                    RETURNSym-16, SWITCHSym-16];
symSet[ 5, 2] := [_andSym-32, _plusSym-32, _minusSym-32, _starSym-32];
symSet[ 5, 3] := [CALLSym-48, _bangSym-48, _tildeSym-48];
end; {InitSymSet}

end { SSLParser }.    
