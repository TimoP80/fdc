(*

---------------------------------------------------------------
FMF Dialogue Tool - dialogue editor for Fallout 2 mods
Copyright (C) 2005-2008 T. Pitkänen
---------------------------------------------------------------
Description:

  This is the FMF file parser unit.
  It was generated with CoCoR/Delphi but I no longer have
  the .atg source file for it.

  It will need to be completely rewritten if there is ever
  going to be any additional fields in the file format

---------------------------------------------------------------

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

*)

unit FMF;




{==============================================================================
FMF
  Version: 1.0 Release 0 Build 252
  Interplay SSL Parser
  Date of Generation: 23.11.2005 18:45
  Author: T. Pitkänen
  (c) 2003 Dj Unique

This unit was generated by Coco/R for Delphi (www.tetzel.com)  Any code in
this file that you edit manually will be over-written when the file is
regenerated.
==============================================================================}

interface

uses
  Classes,
  CocoBaseNew,
  Dialogs,
  mwStringHashList,
  SharedDLGData,
  SysUtils;

const
  maxT      = 85;
  maxP      = 86;

type
  SymbolSet = array[0..maxT div setsize] of TBitSet;

  EFMF        = class(Exception);
  TFMF        = class;

  TFMFScanner = class(TCocoRScanner)
  private
    FOwner :    TFMF;
    fHashList : TmwStringHashList;
    procedure CheckLiteral(var Sym: integer);
    function GetNextSymbolString: string;
    function Comment: boolean;
  protected
    procedure NextCh; override;
  public
    constructor Create;
    destructor Destroy; override;

    procedure Get(var sym: integer); override; // Gets next symbol from source file

    property CurrentSymbol;
    property NextSymbol;
    property OnStatusUpdate;
    property Owner : TFMF Read fOwner Write fOwner;
    property ScannerError;
    property SrcStream;
  end;  { TFMFScanner }

  TFMF = class(TCocoRGrammar)
  private
        { strictly internal variables }
    symSet : array[0..1] of SymbolSet; // symSet[0] = allSyncSyms

    function GetMajorVersion: integer;
    function GetMinorVersion: integer;
    function GetRelease: integer;
    function GetBuild: integer;
    function GetBuildDate: TDateTime;
    function GetVersionComment: string;
    function GetGrammarAuthor: string;
    function GetGrammarCopyright: string;
    function GetVersion: string;
    procedure SetVersion(const Value: string);
    function _In(var s: SymbolSet; x: integer): boolean;
    procedure InitSymSet;

    {Production methods}
    procedure _Globals;
    procedure _TimedEvents;
    procedure _TimedEventData;
    procedure _Nodes;
    procedure _Node;
    procedure _SkillCheck;
    procedure __variable;
    procedure _FloatNodes;
    procedure _CustomScript;
    procedure _CustomProc;
    procedure _StartConditions;
    procedure _StartCond;
    procedure _Conds;
    procedure _ScriptLine;
    procedure _FloatNode;
    procedure _Options;
    procedure _Condition;
    procedure _Main;
    procedure _VarDefs;
    procedure _FMF;

  private
    fOutputStream :   TMemoryStream;
    fSubSelectDepth : integer;
    fInNaturalJoin :  boolean;

    procedure Init;
    procedure Final;
    procedure WriteStr(S: string);
    property OutputStream : TMemoryStream Read fOutputStream Write fOutputStream;
    property SubSelectDepth : integer Read fSubSelectDepth Write fSubSelectDepth;
    property InNaturalJoin : boolean Read fInNaturalJoin Write fInNaturalJoin;

  protected
    { Protected Declarations }
    procedure Get; override;
  public
    { Public Declarations }
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    function ErrorStr(const ErrorCode: integer; const Data: string): string; override;
    procedure Execute;
    function GetScanner: TFMFScanner;
    procedure Parse;

    property ErrorList;
    property ListStream;
    property SourceStream;
    property Successful;
    property MajorVersion : integer Read GetMajorVersion;
    property MinorVersion : integer Read GetMinorVersion;
    property Release : integer Read GetRelease;
    property Build : integer Read GetBuild;
    property BuildDate : TDateTime Read GetBuildDate;
    property VersionComment : string Read GetVersionComment;
    property GrammarAuthor : string Read GetGrammarAuthor;
    property GrammarCopyright : string Read GetGrammarCopyright;

  public

  published
    { Published Declarations }
    property AfterGet;
    property AfterParse;
    property AfterGenList;
    property BeforeGenList;
    property BeforeParse;
    property ClearSourceStream;
    property GenListWhen;
    property SourceFileName;
    property Version : string Read GetVersion Write SetVersion;

    property OnCustomError;
    property OnError;
    property OnFailure;
    property OnStatusUpdate;
    property OnSuccess;
  end; { TFMF }

implementation

{$IFNDEF FMFCBuild}
uses
  debugwnd;

{$ENDIF}
const

  EOFSYMB           = 0;
  identifierSym     = 1;
  integer_Sym       = 2;
  _floatSym         = 3;
  _stringSym        = 4;
  HexLiteralSym     = 5;
  _equal_equalSym   = 6;
  _bang_equalSym    = 7;
  _lessSym          = 8;
  _greaterSym       = 9;
  _greater_equalSym = 10;
  _less_equalSym    = 11;
  LINK_underscoreNEXTSym = 12;
  NONESym           = 13;
  ANDSym            = 14;
  ORSym             = 15;
  INTSym            = 16;
  _equalSym         = 17;
  LINKFLAGSSym      = 18;
  SKILL_underscoreCHECKSym = 19;
  CUSTOM_underscorePROCSym = 20;
  REACTIONSym       = 21;
  REACTION_underscoreBADSym = 22;
  REACTION_underscoreNEUTRALSym = 23;
  REACTION_underscoreGOODSym = 24;
  GENDERSym         = 25;
  FEMALESym         = 26;
  MALESym           = 27;
  PLAYERTEXTSym     = 28;
  LINKTOSym         = 29;
  CONDITIONSSym     = 30;
  _lbraceSym        = 31;
  _commaSym         = 32;
  _rbraceSym        = 33;
  NOTESSym          = 34;
  FLOATNODESym      = 35;
  SSLSym            = 36;
  VAR_underscorePARAMSym = 37;
  EVALSym           = 38;
  VALUE_underscoreTO_underscoreCHECKSym = 39;
  INI_underscoreINDEXSym = 40;
  LINKSym           = 41;
  CONDSym           = 42;
  TARGET_underscoreNODESym = 43;
  START_underscoreCONDITIONSSym = 44;
  DEFAULT_underscoreCONDITIONSym = 45;
  _semicolonSym     = 46;
  ASSOCIATE_underscoreNODESym = 47;
  EXEC_underscoreSCRIPT_underscoreCODESym = 48;
  IMPORTSym         = 49;
  LOCALSym          = 50;
  EXPORTSym         = 51;
  VARSym            = 52;
  VARSSym           = 53;
  DEFINE_underscoreSKILL_underscoreCHECKS = 54;
  SKILL_underscoreNUMSym = 55;
  DIFFICULTY_underscoreMODIFIERSym = 56;
  ONSUCCESSSym      = 57;
  _equal_greaterSym = 58;
  ONFAILURESym      = 59;
  NODESym           = 60;
  IS_underscoreWTGSym = 61;
  TRUESym           = 62;
  FALSESym          = 63;
  INSERT_underscoreCUSTOM_underscoreCODES = 64;
  NPCTEXTSym        = 65;
  NPCFEMALETEXTSym  = 66;
  OPTIONSSym        = 67;
  TIMEEVENTSym      = 68;
  FIXED_underscorePARAM_underscoreNAMESym = 69;
  ENUMSym           = 70;
  ISRANDOMINTERVALSym = 71;
  INTERVALMINSym    = 72;
  INTERVALMAXSym    = 73;
  INTERVALSym       = 74;
  CODESym           = 75;
  DEFAULT_underscoreEVENTSym = 76;
  NPCNAMESym        = 77;
  LOCATIONSym       = 78;
  DESCRIPTIONSym    = 79;
  UNKNOWN_underscoreDESCSym = 80;
  KNOWN_underscoreDESCSym = 81;
  DETAILED_underscoreDESCSym = 82;
  NOSYMB            = 83;
  PreProcessorSym   = 84;
  GLOBALSYM         = 85;
  _noSym            = NOSYMB;   {error token code}

 { --------------------------------------------------------------------------- }
 { Arbitrary Code from ATG file }
var
  tempcondcheck: string;
  tempcondfield: string;
  tempcondval:   string;
  tempcondeval:  string;
  tempcondlink:  integer;

procedure TFMF.Init;
begin
  currentdlg.nodecount := 0;
  OutputStream.Clear;
  currentdlg.floatnodecount := 0;
  currentdlg.varcnt := 0;
  currentdlg.timedeventcnt := 0;
  currentdlg.startconditioncnt := 0;
  SubSelectDepth := 0;
end;

procedure TFMF.Final;
begin
  OutputStream.Position := 0;
  OutputStream.SaveToStream(ListStream);
  OutputStream.Clear;
end;



procedure TFMF.WriteStr(S: string);
begin
  S := S + #13#10;
  OutputStream.WriteBuffer(S[1], length(S));
end;


procedure CreateNewCondition;
var
  temp_cond: condition;
begin
  ;
  temp_cond.check_type  := 0;
  temp_cond.check_field := 0;
  temp_cond.check_eval  := 0;
  temp_cond.link        := tempcondlink;
  if tempcondcheck = 'CHECK_SKILL' then
    temp_cond.check_type := CHECK_TYPE_SKILL
  else
  if tempcondcheck = 'CHECK_STAT' then
    temp_cond.check_type := CHECK_TYPE_STAT
  else
  if tempcondcheck = 'CHECK_MONEY' then
    temp_cond.check_type := CHECK_TYPE_CHECKMONEY
  else
  if tempcondcheck = 'GLOBAL_VARIABLE' then
  begin
    ;
    temp_cond.check_type := CHECK_TYPE_GLOBAL_VARIABLE;
    temp_cond.var_ptr    := tempcondfield;
  end
  else
  if tempcondcheck = 'LOCAL_VARIABLE' then
  begin
    ;
    temp_cond.check_type := CHECK_TYPE_LOCAL_VARIABLE;
    temp_cond.var_ptr    := tempcondfield;

  end
  else
  if tempcondcheck = 'SCRIPT_VARIABLE' then
  begin
    ;
    temp_cond.check_type := CHECK_TYPE_SCRIPT_VARIABLE;
    temp_cond.var_ptr    := tempcondfield;
  end
  else
  if tempcondcheck = 'PLAYER_HAS_ITEM' then
  begin
    ;
    temp_cond.check_type := CHECK_TYPE_ITEM_PLAYER;
    temp_cond.var_ptr    := tempcondfield;
  end;


  if tempcondfield = 'dude_caps' then
    temp_cond.check_field := CHECK_FIELD_DUDE_CAPS
  else
  if tempcondfield = 'strength' then
    temp_cond.check_field := CHECK_FIELD_STAT_ST
  else
  if tempcondfield = 'perception' then
    temp_cond.check_field := CHECK_FIELD_STAT_PE
  else
  if tempcondfield = 'endurance' then
    temp_cond.check_field := CHECK_FIELD_STAT_EN
  else
  if tempcondfield = 'charisma' then
    temp_cond.check_field := CHECK_FIELD_STAT_CH
  else
  if tempcondfield = 'intelligence' then
    temp_cond.check_field := CHECK_FIELD_STAT_IN
  else
  if tempcondfield = 'agility' then
    temp_cond.check_field := CHECK_FIELD_STAT_AG
  else
  if tempcondfield = 'luck' then
    temp_cond.check_field := CHECK_FIELD_STAT_LK
  else
  if tempcondfield = 'armor_class' then
    temp_cond.check_field := CHECK_FIELD_STAT_ARMOR_CLASS
  else
  if tempcondfield = 'carry_amount' then
    temp_cond.check_field := CHECK_FIELD_STAT_CARRY_AMOUNT
  else
  if tempcondfield = 'healing_rate' then
    temp_cond.check_field := CHECK_FIELD_STAT_HEALING_RATE
  else
  if tempcondfield = 'max_hp' then
    temp_cond.check_field := CHECK_FIELD_STAT_MAXIMUM_HIT_POINTS
  else
  if tempcondfield = 'cur_hp' then
    temp_cond.check_field := CHECK_FIELD_STAT_CURRENT_HIT_POINTS
  else
  if tempcondfield = 'cur_rad_lev' then
    temp_cond.check_field := CHECK_FIELD_STAT_CURRENT_RAD_LEVEL
  else
  if tempcondfield = 'cur_poison_lev' then
    temp_cond.check_field := CHECK_FIELD_STAT_CURRENT_POISON_LEVEL
  else

  if tempcondfield = 'small_guns' then
    temp_cond.check_field := CHECK_FIELD_SKILL_SMALLGUNS
  else
  if tempcondfield = 'big_guns' then
    temp_cond.check_field := CHECK_FIELD_SKILL_BIGGUNS
  else
  if tempcondfield = 'energy_weapons' then
    temp_cond.check_field := CHECK_FIELD_SKILL_ENERGYWEAPONS
  else
  if tempcondfield = 'unarmed_combat' then
    temp_cond.check_field := CHECK_FIELD_SKILL_UNARMED
  else
  if tempcondfield = 'melee_combat' then
    temp_cond.check_field := CHECK_FIELD_SKILL_MELEE
  else
  if tempcondfield = 'throwing' then
    temp_cond.check_field := CHECK_FIELD_SKILL_THROWING
  else
  if tempcondfield = 'first_aid' then
    temp_cond.check_field := CHECK_FIELD_SKILL_FIRSTAID
  else
  if tempcondfield = 'doctor' then
    temp_cond.check_field := CHECK_FIELD_SKILL_DOCTOR
  else
  if tempcondfield = 'sneak' then
    temp_cond.check_field := CHECK_FIELD_SKILL_SNEAK
  else
  if tempcondfield = 'lockpick' then
    temp_cond.check_field := CHECK_FIELD_SKILL_LOCKPICK
  else
  if tempcondfield = 'steal' then
    temp_cond.check_field := CHECK_FIELD_SKILL_STEAL
  else
  if tempcondfield = 'traps' then
    temp_cond.check_field := CHECK_FIELD_SKILL_TRAPS
  else
  if tempcondfield = 'science' then
    temp_cond.check_field := CHECK_FIELD_SKILL_SCIENCE
  else
  if tempcondfield = 'repair' then
    temp_cond.check_field := CHECK_FIELD_SKILL_REPAIR
  else
  if tempcondfield = 'speech' then
    temp_cond.check_field := CHECK_FIELD_SKILL_SPEECH
  else
  if tempcondfield = 'barter' then
    temp_cond.check_field := CHECK_FIELD_SKILL_BARTER
  else
  if tempcondfield = 'gambling' then
    temp_cond.check_field := CHECK_FIELD_SKILL_GAMBLING
  else
  if tempcondfield = 'outdoorsman' then
    temp_cond.check_field := CHECK_FIELD_SKILL_OUTDOORSMAN;

  if tempcondeval = '==' then
    temp_cond.check_eval := COMPARE_EQUAL
  else
  if tempcondeval = '!=' then
    temp_cond.check_eval := COMPARE_NOT_EQUAL
  else
  if tempcondeval = '<' then
    temp_cond.check_eval := COMPARE_LESS_THAN
  else
  if tempcondeval = '>' then
    temp_cond.check_eval := COMPARE_LARGER_THAN
  else
  if tempcondeval = '>=' then
    temp_cond.check_eval := COMPARE_LARGER_THAN_OR_EQUAL
  else
  if tempcondeval = '<=' then
    temp_cond.check_eval := COMPARE_LESS_THAN_OR_EQUAL;
  temp_cond.check_value := tempcondval;


  temp_cond.resolved_code := ResolveToSSL(temp_cond);
  try
    new(currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].conditions
      [currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].conditioncnt]);
    currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].conditions[
      currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].
      conditioncnt]^ :=
      temp_cond;
    Inc(currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].conditioncnt);
  except
    on e : Exception do
    begin
      ;
      MessageDlg('ALLOC ERROR!!!!', mtError, [mbOK], 0);
    end;
  end;

end;

function parse_string(zstr: string): string;
var
  t:    integer;
var
  temp: string;
var
  len:  integer;
begin
  ;
  len  := 0;
  temp := '';
 // showmessage ('Parsing string: '+zstr);
  t    := pos('"', zstr) + 1;
  len  := length(zstr);
  while (zstr[t] <> '"') do
  begin
    ;
    //writeln (zstr[t]);
    if (zstr[t] = '\') and (zstr[t + 1] = '"') then
    begin
      ;
      temp := temp + '"';
      Inc(t, 1);
    end
    else
    if (zstr[t] = '\') and (zstr[t + 1] = 't') then
    begin
      ;
      temp := temp + #9;
      Inc(t, 1);
    end
    else
    if (zstr[t] = '\') and (zstr[t + 1] = 'n') then
    begin
      ;
      temp := temp + #13#10;
      Inc(t, 1);
    end
    else

      temp := temp + zstr[t];

    Inc(t);
  end;
  Result := temp;
end;

 (* End of Arbitrary Code *)




 { --------------------------------------------------------------------------- }
 { ---- implementation for TFMFScanner ---- }

procedure TFMFScanner.NextCh;
 { Return global variable ch }
begin
  LastInputCh    := CurrInputCh;
  BufferPosition := BufferPosition + 1;
  SrcStream.Seek(BufferPosition, soFromBeginning);
  CurrInputCh    := CurrentCh(BufferPosition);
  if (CurrInputCh = _EL) or ((CurrInputCh = _LF) and (LastInputCh <> _EL)) then
  begin
    CurrLine := CurrLine + 1;
    if Assigned(OnStatusUpdate) then
      OnStatusUpdate(Owner, cstLineNum, '', CurrLine);
    StartOfLine := BufferPosition;
  end;
end;  {NextCh}

function TFMFScanner.Comment: boolean;
var
  level:        integer;
  startLine:    integer;
  oldLineStart: longint;
  CommentStr:   string;
begin
  level        := 1;
  startLine    := CurrLine;
  oldLineStart := StartOfLine;
  CommentStr   := CharAt(BufferPosition);
  Result       := False;
  if (CurrInputCh = '/') then
  begin
    NextCh;
    CommentStr := CommentStr + CharAt(BufferPosition);
    if (CurrInputCh = '/') then
    begin
      NextCh;
      CommentStr := CommentStr + CharAt(BufferPosition);
      while True do
      begin
        if (CurrInputCh = CHR(13)) then
        begin
          level           := level - 1;
          NumEOLInComment := CurrLine - startLine;
          NextCh;
          CommentStr      := CommentStr + CharAt(BufferPosition);
          if level = 0 then
          begin
            Result := True;
            Exit;
          end;
        end
        else if CurrInputCh = _EF then
        begin
          Result := False;
          Exit;
        end
        else
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
        end;
      end; { WHILE TRUE }
    end
    else
    begin
      if (CurrInputCh = _CR) or (CurrInputCh = _LF) then
      begin
        CurrLine    := CurrLine - 1;
        StartOfLine := oldLineStart;
      end;
      BufferPosition := BufferPosition - 1;
      CurrInputCh := LastInputCh;
      Result := False;
    end;
  end;
  Result := False;
  if (CurrInputCh = '/') then
  begin
    NextCh;
    CommentStr := CommentStr + CharAt(BufferPosition);
    if (CurrInputCh = '*') then
    begin
      NextCh;
      CommentStr := CommentStr + CharAt(BufferPosition);
      while True do
      begin
        if (CurrInputCh = '*') then
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
          if (CurrInputCh = '/') then
          begin
            level := level - 1;
            NextCh;
            CommentStr := CommentStr + CharAt(BufferPosition);
            if level = 0 then
            begin
              Result := True;
              Exit;
            end;
          end;
        end
        else if CurrInputCh = _EF then
        begin
          Result := False;
          Exit;
        end
        else
        begin
          NextCh;
          CommentStr := CommentStr + CharAt(BufferPosition);
        end;
      end; { WHILE TRUE }
    end
    else
    begin
      if (CurrInputCh = _CR) or (CurrInputCh = _LF) then
      begin
        CurrLine    := CurrLine - 1;
        StartOfLine := oldLineStart;
      end;
      BufferPosition := BufferPosition - 1;
      CurrInputCh := LastInputCh;
      Result := False;
    end;
  end;
end;  { Comment }

function TFMFScanner.GetNextSymbolString: string;
var
  i: integer;
  q: integer;
begin
  Result := '';
  i      := 1;
  q      := bpCurrToken;
  while i <= NextSymbol.Len do
  begin
    Result := Result + CurrentCh(q);
    Inc(q);
    Inc(i);
  end;
end; {GetNextSymbolString}

procedure TFMFScanner.CheckLiteral(var Sym: integer);
var
  SymId:        integer;
  DefaultSymId: integer;
  aToken:       string;
begin
  aToken := GetNextSymbolString;
  if fHashList.Hash(aToken, SymId, DefaultSymId) then
  begin
    sym := SymId;
  end;
end; {CheckLiteral}


procedure TFMFScanner.Get(var sym: integer);
var
  state: integer;
begin   {Get}
  while (CurrInputCh = ' ') or ((CurrInputCh >= CHR(1)) and (CurrInputCh <= ' ')) do
    NextCh;
  if ((CurrInputCh = '/') or (CurrInputCh = '/')) and Comment then
  begin
    Get(sym);
    exit;
  end;

  CurrentSymbol.Assign(NextSymbol);

  NextSymbol.Pos  := BufferPosition;
  NextSymbol.Col  := BufferPosition - StartOfLine;
  NextSymbol.Line := CurrLine;
  NextSymbol.Len  := 0;

  ContextLen  := 0;
  state       := StartState[Ord(CurrInputCh)];
  bpCurrToken := BufferPosition;
  while True do
  begin
    NextCh;
    NextSymbol.Len := NextSymbol.Len + 1;
    if BufferPosition > SrcStream.Size then
    begin
      sym            := EOFSYMB;
      CurrInputCh    := _EF;
      BufferPosition := BufferPosition - 1;
      exit;
    end;
    case state of
      1:
        if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or (CurrInputCh >= 'A') and
          (CurrInputCh <= 'Z') or (CurrInputCh = '_') or (CurrInputCh >= CHR(196)) and
          (CurrInputCh <= CHR(197)) or (CurrInputCh = CHR(214)) or (CurrInputCh >= CHR(228)) and
          (CurrInputCh <= CHR(229)) or (CurrInputCh = CHR(246))) then
        begin

        end
        else
        begin
          sym := identifierSym;
          CheckLiteral(sym);
          exit;
        end;
      2:
        if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 3;
        end
        else
        begin
          sym   := _noSym;
          exit;
        end;
      3:
        if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else
        begin
          sym := integer_Sym;
          exit;
        end;
      4:
        if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 5;
        end
        else
        begin
          sym   := _noSym;
          exit;
        end;
      5:
        if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else if (CurrInputCh = 'F') then
        begin
          state := 6;
        end
        else
        begin
          sym   := _floatSym;
          exit;
        end;
      6:
      begin
        sym := _floatSym;
        exit;
      end;
      7:
        if ((CurrInputCh <= CHR(12)) or (CurrInputCh >= CHR(14)) and (CurrInputCh <= '!') or
          (CurrInputCh >= '#') and (CurrInputCh <= '[') or (CurrInputCh >= ']')) then
        begin

        end
        else if (CurrInputCh = '"') then
        begin
          state := 8;
        end
        else if (CurrInputCh = '\') then
        begin
          state := 13;
        end
        else
        begin
          sym   := _noSym;
          exit;
        end;
      8:
      begin
        sym := _stringSym;
        exit;
      end;
      9:
        if ((CurrInputCh >= '0') and (CurrInputCh <= '9') or (CurrInputCh >= 'A') and
          (CurrInputCh <= 'Z') or (CurrInputCh = '_') or (CurrInputCh >= CHR(196)) and
          (CurrInputCh <= CHR(197)) or (CurrInputCh = CHR(214)) or (CurrInputCh >= CHR(228)) and
          (CurrInputCh <= CHR(229)) or (CurrInputCh = CHR(246))) then
        begin

        end
        else
        begin
          sym := HexLiteralSym;
          exit;
        end;
      10:
        if not ((CurrInputCh = CHR(13))) then
        begin

        end
        else
        begin
          sym := PreProcessorSym;
          exit;
        end;
      11:
        if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin

        end
        else if (CurrInputCh = '.') then
        begin
          state := 4;
        end
        else
        begin
          sym   := integer_Sym;
          exit;
        end;
      12:
        if ((CurrInputCh >= '0') and (CurrInputCh <= '9')) then
        begin
          state := 11;
        end
        else
        begin
          sym   := _noSym;
          exit;
        end;
      13:
        if ((CurrInputCh <= CHR(12)) or (CurrInputCh >= CHR(14)) and (CurrInputCh <= '!') or
          (CurrInputCh >= '#') and (CurrInputCh <= '[') or (CurrInputCh >= ']')) then
        begin
          state := 7;
        end
        else if (CurrInputCh = '"') then
        begin
          state := 14;
        end
        else if (CurrInputCh = '\') then
        begin

        end
        else
        begin
          sym := _noSym;
          exit;
        end;
      14:
        if ((CurrInputCh <= CHR(12)) or (CurrInputCh >= CHR(14)) and (CurrInputCh <= '!') or
          (CurrInputCh >= '#') and (CurrInputCh <= '[') or (CurrInputCh >= ']')) then
        begin
          state := 7;
        end
        else if (CurrInputCh = '"') then
        begin
          state := 8;
        end
        else if (CurrInputCh = '\') then
        begin
          state := 13;
        end
        else
        begin
          sym   := _stringSym;
          exit;
        end;
      15:
        if (CurrInputCh = '=') then
        begin
          state := 16;
        end
        else if (CurrInputCh = '>') then
        begin
          state := 27;
        end
        else
        begin
          sym   := _equalSym;
          exit;
        end;
      16:
      begin
        sym := _equal_equalSym;
        exit;
      end;
      17:
        if (CurrInputCh = '=') then
        begin
          state := 18;
        end
        else
        begin
          sym   := _noSym;
          exit;
        end;
      18:
      begin
        sym := _bang_equalSym;
        exit;
      end;
      19:
        if (CurrInputCh = '=') then
        begin
          state := 22;
        end
        else
        begin
          sym   := _lessSym;
          exit;
        end;
      20:
        if (CurrInputCh = '=') then
        begin
          state := 21;
        end
        else
        begin
          sym   := _greaterSym;
          exit;
        end;
      21:
      begin
        sym := _greater_equalSym;
        exit;
      end;
      22:
      begin
        sym            := _less_equalSym;
        exit;
      end;
      23:
      begin
        sym            := _lbraceSym;
        exit;
      end;
      24:
      begin
        sym            := _commaSym;
        exit;
      end;
      25:
      begin
        sym            := _rbraceSym;
        exit;
      end;
      26:
      begin
        sym            := _semicolonSym;
        exit;
      end;
      27:
      begin
        sym            := _equal_greaterSym;
        exit;
      end;
      28:
      begin
        sym            := EOFSYMB;
        CurrInputCh    := #0;
        BufferPosition := BufferPosition - 1;
        exit;
      end;
      else
      begin
        sym := _noSym;
        EXIT;          // NextCh already done
      end;
    end;
  end;
end;  {Get}

constructor TFMFScanner.Create;
begin
  inherited;
  fHashList := TmwStringHashList.Create(ISmallCrcHash, HashSecondaryTwo, IHashCompare);
  fHashList.AddString('AND', ANDSym, ANDSym);
  fHashList.AddString('ASSOCIATE_NODE', ASSOCIATE_underscoreNODESym, ASSOCIATE_underscoreNODESym);
  fHashList.AddString('CODE', CODESym, CODESym);
  fHashList.AddString('COND', CONDSym, CONDSym);
  fHashList.AddString('CONDITIONS', CONDITIONSSym, CONDITIONSSym);
  fHashList.AddString('CUSTOM_PROC', CUSTOM_underscorePROCSym, CUSTOM_underscorePROCSym);
  fHashList.AddString('DEFAULT_CONDITION', DEFAULT_underscoreCONDITIONSym, DEFAULT_underscoreCONDITIONSym);
  fHashList.AddString('DEFAULT_EVENT', DEFAULT_underscoreEVENTSym, DEFAULT_underscoreEVENTSym);
  fHashList.AddString('DEFINE_SKILL_CHECK', DEFINE_underscoreSKILL_underscoreCHECKS,
    DEFINE_underscoreSKILL_underscoreCHECKS);
  fHashList.AddString('DESCRIPTION', DESCRIPTIONSym, DESCRIPTIONSym);
  fHashList.AddString('DETAILED_DESC', DETAILED_underscoreDESCSym, DETAILED_underscoreDESCSym);
  fHashList.AddString('DIFFICULTY_MODIFIER', DIFFICULTY_underscoreMODIFIERSym, DIFFICULTY_underscoreMODIFIERSym);
  fHashList.AddString('ENUM', ENUMSym, ENUMSym);
  fHashList.AddString('EVAL', EVALSym, EVALSym);
  fHashList.AddString('EXEC_SCRIPT_CODE', EXEC_underscoreSCRIPT_underscoreCODESym,
    EXEC_underscoreSCRIPT_underscoreCODESym);
  fHashList.AddString('EXPORT', EXPORTSym, EXPORTSym);
  fHashList.AddString('FALSE', FALSESym, FALSESym);
  fHashList.AddString('FEMALE', FEMALESym, FEMALESym);
  fHashList.AddString('FIXED_PARAM_NAME', FIXED_underscorePARAM_underscoreNAMESym,
    FIXED_underscorePARAM_underscoreNAMESym);
  fHashList.AddString('FLOATNODE', FLOATNODESym, FLOATNODESym);
  fHashList.AddString('GENDER', GENDERSym, GENDERSym);
  fHashList.AddString('GLOBAL', GLOBALSYM, GLOBALSYM);
  fHashList.AddString('IMPORT', IMPORTSym, IMPORTSym);
  fHashList.AddString('INI_INDEX', INI_underscoreINDEXSym, INI_underscoreINDEXSym);
  fHashList.AddString('INSERT_CUSTOM_CODE', INSERT_underscoreCUSTOM_underscoreCODES,
    INSERT_underscoreCUSTOM_underscoreCODES);
  fHashList.AddString('INT', INTSym, INTSym);
  fHashList.AddString('INTERVAL', INTERVALSym, INTERVALSym);
  fHashList.AddString('INTERVALMAX', INTERVALMAXSym, INTERVALMAXSym);
  fHashList.AddString('INTERVALMIN', INTERVALMINSym, INTERVALMINSym);
  fHashList.AddString('ISRANDOMINTERVAL', ISRANDOMINTERVALSym, ISRANDOMINTERVALSym);
  fHashList.AddString('IS_WTG', IS_underscoreWTGSym, IS_underscoreWTGSym);
  fHashList.AddString('KNOWN_DESC', KNOWN_underscoreDESCSym, KNOWN_underscoreDESCSym);
  fHashList.AddString('LINK', LINKSym, LINKSym);
  fHashList.AddString('LINKFLAGS', LINKFLAGSSym, LINKFLAGSSym);
  fHashList.AddString('LINKTO', LINKTOSym, LINKTOSym);
  fHashList.AddString('LINK_NEXT', LINK_underscoreNEXTSym, LINK_underscoreNEXTSym);
  fHashList.AddString('LOCAL', LOCALSym, LOCALSym);
  fHashList.AddString('LOCATION', LOCATIONSym, LOCATIONSym);
  fHashList.AddString('MALE', MALESym, MALESym);
  fHashList.AddString('NODE', NODESym, NODESym);
  fHashList.AddString('NONE', NONESym, NONESym);
  fHashList.AddString('NOTES', NOTESSym, NOTESSym);
  fHashList.AddString('NPCFEMALETEXT', NPCFEMALETEXTSym, NPCFEMALETEXTSym);
  fHashList.AddString('NPCNAME', NPCNAMESym, NPCNAMESym);
  fHashList.AddString('NPCTEXT', NPCTEXTSym, NPCTEXTSym);
  fHashList.AddString('ONFAILURE', ONFAILURESym, ONFAILURESym);
  fHashList.AddString('ONSUCCESS', ONSUCCESSSym, ONSUCCESSSym);
  fHashList.AddString('OPTIONS', OPTIONSSym, OPTIONSSym);
  fHashList.AddString('OR', ORSym, ORSym);
  fHashList.AddString('PLAYERTEXT', PLAYERTEXTSym, PLAYERTEXTSym);
  fHashList.AddString('REACTION', REACTIONSym, REACTIONSym);
  fHashList.AddString('REACTION_BAD', REACTION_underscoreBADSym, REACTION_underscoreBADSym);
  fHashList.AddString('REACTION_GOOD', REACTION_underscoreGOODSym, REACTION_underscoreGOODSym);
  fHashList.AddString('REACTION_NEUTRAL', REACTION_underscoreNEUTRALSym, REACTION_underscoreNEUTRALSym);
  fHashList.AddString('SKILL_CHECK', SKILL_underscoreCHECKSym, SKILL_underscoreCHECKSym);
  fHashList.AddString('SKILL_NUM', SKILL_underscoreNUMSym, SKILL_underscoreNUMSym);
  fHashList.AddString('SSL', SSLSym, SSLSym);
  fHashList.AddString('START_CONDITIONS', START_underscoreCONDITIONSSym, START_underscoreCONDITIONSSym);
  fHashList.AddString('TARGET_NODE', TARGET_underscoreNODESym, TARGET_underscoreNODESym);
  fHashList.AddString('TIMEEVENT', TIMEEVENTSym, TIMEEVENTSym);
  fHashList.AddString('TRUE', TRUESym, TRUESym);
  fHashList.AddString('UNKNOWN_DESC', UNKNOWN_underscoreDESCSym, UNKNOWN_underscoreDESCSym);
  fHashList.AddString('VALUE_TO_CHECK', VALUE_underscoreTO_underscoreCHECKSym, VALUE_underscoreTO_underscoreCHECKSym);
  fHashList.AddString('VAR', VARSym, VARSym);
  fHashList.AddString('VARS', VARSSym, VARSSym);
  fHashList.AddString('VAR_PARAM', VAR_underscorePARAMSym, VAR_underscorePARAMSym);
  CurrentCh        := CapChAt;
  fStartState[0]   := 28;
  fStartState[1]   := 29;
  fStartState[2]   := 29;
  fStartState[3]   := 29;
  fStartState[4]   := 29;
  fStartState[5]   := 29;
  fStartState[6]   := 29;
  fStartState[7]   := 29;
  fStartState[8]   := 29;
  fStartState[9]   := 29;
  fStartState[10]  := 29;
  fStartState[11]  := 29;
  fStartState[12]  := 29;
  fStartState[13]  := 29;
  fStartState[14]  := 29;
  fStartState[15]  := 29;
  fStartState[16]  := 29;
  fStartState[17]  := 29;
  fStartState[18]  := 29;
  fStartState[19]  := 29;
  fStartState[20]  := 29;
  fStartState[21]  := 29;
  fStartState[22]  := 29;
  fStartState[23]  := 29;
  fStartState[24]  := 29;
  fStartState[25]  := 29;
  fStartState[26]  := 29;
  fStartState[27]  := 29;
  fStartState[28]  := 29;
  fStartState[29]  := 29;
  fStartState[30]  := 29;
  fStartState[31]  := 29;
  fStartState[32]  := 29;
  fStartState[33]  := 17;
  fStartState[34]  := 7;
  fStartState[35]  := 10;
  fStartState[36]  := 9;
  fStartState[37]  := 29;
  fStartState[38]  := 29;
  fStartState[39]  := 29;
  fStartState[40]  := 29;
  fStartState[41]  := 29;
  fStartState[42]  := 29;
  fStartState[43]  := 2;
  fStartState[44]  := 24;
  fStartState[45]  := 12;
  fStartState[46]  := 4;
  fStartState[47]  := 29;
  fStartState[48]  := 11;
  fStartState[49]  := 11;
  fStartState[50]  := 11;
  fStartState[51]  := 11;
  fStartState[52]  := 11;
  fStartState[53]  := 11;
  fStartState[54]  := 11;
  fStartState[55]  := 11;
  fStartState[56]  := 11;
  fStartState[57]  := 11;
  fStartState[58]  := 29;
  fStartState[59]  := 26;
  fStartState[60]  := 19;
  fStartState[61]  := 15;
  fStartState[62]  := 20;
  fStartState[63]  := 29;
  fStartState[64]  := 29;
  fStartState[65]  := 1;
  fStartState[66]  := 1;
  fStartState[67]  := 1;
  fStartState[68]  := 1;
  fStartState[69]  := 1;
  fStartState[70]  := 1;
  fStartState[71]  := 1;
  fStartState[72]  := 1;
  fStartState[73]  := 1;
  fStartState[74]  := 1;
  fStartState[75]  := 1;
  fStartState[76]  := 1;
  fStartState[77]  := 1;
  fStartState[78]  := 1;
  fStartState[79]  := 1;
  fStartState[80]  := 1;
  fStartState[81]  := 1;
  fStartState[82]  := 1;
  fStartState[83]  := 1;
  fStartState[84]  := 1;
  fStartState[85]  := 1;
  fStartState[86]  := 1;
  fStartState[87]  := 1;
  fStartState[88]  := 1;
  fStartState[89]  := 1;
  fStartState[90]  := 1;
  fStartState[91]  := 29;
  fStartState[92]  := 29;
  fStartState[93]  := 29;
  fStartState[94]  := 29;
  fStartState[95]  := 1;
  fStartState[96]  := 29;
  fStartState[97]  := 29;
  fStartState[98]  := 29;
  fStartState[99]  := 29;
  fStartState[100] := 29;
  fStartState[101] := 29;
  fStartState[102] := 29;
  fStartState[103] := 29;
  fStartState[104] := 29;
  fStartState[105] := 29;
  fStartState[106] := 29;
  fStartState[107] := 29;
  fStartState[108] := 29;
  fStartState[109] := 29;
  fStartState[110] := 29;
  fStartState[111] := 29;
  fStartState[112] := 29;
  fStartState[113] := 29;
  fStartState[114] := 29;
  fStartState[115] := 29;
  fStartState[116] := 29;
  fStartState[117] := 29;
  fStartState[118] := 29;
  fStartState[119] := 29;
  fStartState[120] := 29;
  fStartState[121] := 29;
  fStartState[122] := 29;
  fStartState[123] := 23;
  fStartState[124] := 29;
  fStartState[125] := 25;
  fStartState[126] := 29;
  fStartState[127] := 29;
  fStartState[128] := 29;
  fStartState[129] := 29;
  fStartState[130] := 29;
  fStartState[131] := 29;
  fStartState[132] := 29;
  fStartState[133] := 29;
  fStartState[134] := 29;
  fStartState[135] := 29;
  fStartState[136] := 29;
  fStartState[137] := 29;
  fStartState[138] := 29;
  fStartState[139] := 29;
  fStartState[140] := 29;
  fStartState[141] := 29;
  fStartState[142] := 29;
  fStartState[143] := 29;
  fStartState[144] := 29;
  fStartState[145] := 29;
  fStartState[146] := 29;
  fStartState[147] := 29;
  fStartState[148] := 29;
  fStartState[149] := 29;
  fStartState[150] := 29;
  fStartState[151] := 29;
  fStartState[152] := 29;
  fStartState[153] := 29;
  fStartState[154] := 29;
  fStartState[155] := 29;
  fStartState[156] := 29;
  fStartState[157] := 29;
  fStartState[158] := 29;
  fStartState[159] := 29;
  fStartState[160] := 29;
  fStartState[161] := 29;
  fStartState[162] := 29;
  fStartState[163] := 29;
  fStartState[164] := 29;
  fStartState[165] := 29;
  fStartState[166] := 29;
  fStartState[167] := 29;
  fStartState[168] := 29;
  fStartState[169] := 29;
  fStartState[170] := 29;
  fStartState[171] := 29;
  fStartState[172] := 29;
  fStartState[173] := 29;
  fStartState[174] := 29;
  fStartState[175] := 29;
  fStartState[176] := 29;
  fStartState[177] := 29;
  fStartState[178] := 29;
  fStartState[179] := 29;
  fStartState[180] := 29;
  fStartState[181] := 29;
  fStartState[182] := 29;
  fStartState[183] := 29;
  fStartState[184] := 29;
  fStartState[185] := 29;
  fStartState[186] := 29;
  fStartState[187] := 29;
  fStartState[188] := 29;
  fStartState[189] := 29;
  fStartState[190] := 29;
  fStartState[191] := 29;
  fStartState[192] := 29;
  fStartState[193] := 29;
  fStartState[194] := 29;
  fStartState[195] := 29;
  fStartState[196] := 1;
  fStartState[197] := 1;
  fStartState[198] := 29;
  fStartState[199] := 29;
  fStartState[200] := 29;
  fStartState[201] := 29;
  fStartState[202] := 29;
  fStartState[203] := 29;
  fStartState[204] := 29;
  fStartState[205] := 29;
  fStartState[206] := 29;
  fStartState[207] := 29;
  fStartState[208] := 29;
  fStartState[209] := 29;
  fStartState[210] := 29;
  fStartState[211] := 29;
  fStartState[212] := 29;
  fStartState[213] := 29;
  fStartState[214] := 1;
  fStartState[215] := 29;
  fStartState[216] := 29;
  fStartState[217] := 29;
  fStartState[218] := 29;
  fStartState[219] := 29;
  fStartState[220] := 29;
  fStartState[221] := 29;
  fStartState[222] := 29;
  fStartState[223] := 29;
  fStartState[224] := 29;
  fStartState[225] := 29;
  fStartState[226] := 29;
  fStartState[227] := 29;
  fStartState[228] := 1;
  fStartState[229] := 1;
  fStartState[230] := 29;
  fStartState[231] := 29;
  fStartState[232] := 29;
  fStartState[233] := 29;
  fStartState[234] := 29;
  fStartState[235] := 29;
  fStartState[236] := 29;
  fStartState[237] := 29;
  fStartState[238] := 29;
  fStartState[239] := 29;
  fStartState[240] := 29;
  fStartState[241] := 29;
  fStartState[242] := 29;
  fStartState[243] := 29;
  fStartState[244] := 29;
  fStartState[245] := 29;
  fStartState[246] := 1;
  fStartState[247] := 29;
  fStartState[248] := 29;
  fStartState[249] := 29;
  fStartState[250] := 29;
  fStartState[251] := 29;
  fStartState[252] := 29;
  fStartState[253] := 29;
  fStartState[254] := 29;
  fStartState[255] := 29;
end; {Create}

destructor TFMFScanner.Destroy;
begin
  fHashList.Free;
  fHashList := NIL;
  inherited;
end;

 { --------------------------------------------------------------------------- }
 { ---- implementation for TFMF ---- }

constructor TFMF.Create(AOwner: TComponent);
begin
  inherited;
  Scanner          := TFMFScanner.Create;
  GetScanner.Owner := self;
  fOutputStream    := TMemoryStream.Create;

  InitSymSet;
end; {Create}

destructor TFMF.Destroy;
begin
  Scanner.Free;
  fOutputStream.Free;

  inherited;
end; {Destroy}

function TFMF.ErrorStr(const ErrorCode: integer; const Data: string): string;
begin
  case ErrorCode of
    0:
      Result := 'EOF expected';
    1:
      Result := 'identifier expected';
    2:
      Result := 'integer value expected';
    3:
      Result := '_float expected';
    4:
      Result := 'string constant expected';
    5:
      Result := 'HexLiteral expected';
    6:
      Result := '"==" expected';
    7:
      Result := '"!=" expected';
    8:
      Result := '"<" expected';
    9:
      Result := '">" expected';
    10:
      Result := '">=" expected';
    11:
      Result := '"<=" expected';
    12:
      Result := '"LINK_NEXT" expected';
    13:
      Result := '"NONE" expected';
    14:
      Result := '"AND" expected';
    15:
      Result := '"OR" expected';
    16:
      Result := '"INT" expected';
    17:
      Result := '"=" expected';
    18:
      Result := '"LINKFLAGS" expected';
    19:
      Result := '"SKILL_CHECK" expected';
    20:
      Result := '"CUSTOM_PROC" expected';
    21:
      Result := '"REACTION" expected';
    22:
      Result := '"REACTION_BAD" expected';
    23:
      Result := '"REACTION_NEUTRAL" expected';
    24:
      Result := '"REACTION_GOOD" expected';
    25:
      Result := '"GENDER" expected';
    26:
      Result := '"FEMALE" expected';
    27:
      Result := '"MALE" expected';
    28:
      Result := '"PLAYERTEXT" expected';
    29:
      Result := '"LINKTO" expected';
    30:
      Result := '"CONDITIONS" expected';
    31:
      Result := '"{" expected';
    32:
      Result := '"," expected';
    33:
      Result := '"}" expected';
    34:
      Result := '"NOTES" expected';
    35:
      Result := '"FLOATNODE" expected';
    36:
      Result := '"SSL" expected';
    37:
      Result := '"VAR_PARAM" expected';
    38:
      Result := '"EVAL" expected';
    39:
      Result := '"VALUE_TO_CHECK" expected';
    40:
      Result := '"INI_INDEX" expected';
    41:
      Result := '"LINK" expected';
    42:
      Result := '"COND" expected';
    43:
      Result := '"TARGET_NODE" expected';
    44:
      Result := '"START_CONDITIONS" expected';
    45:
      Result := '"DEFAULT_CONDITION" expected';
    46:
      Result := '";" expected';
    47:
      Result := '"ASSOCIATE_NODE" expected';
    48:
      Result := '"EXEC_SCRIPT_CODE" expected';
    49:
      Result := '"IMPORT" expected';
    50:
      Result := '"LOCAL" expected';
    51:
      Result := '"EXPORT" expected';
    52:
      Result := '"VAR" expected';
    53:
      Result := '"VARS" expected';
    54:
      Result := '"DEFINE_SKILL_CHECK" expected';
    55:
      Result := '"SKILL_NUM" expected';
    56:
      Result := '"DIFFICULTY_MODIFIER" expected';
    57:
      Result := '"ONSUCCESS" expected';
    58:
      Result := '"=>" expected';
    59:
      Result := '"ONFAILURE" expected';
    60:
      Result := '"NODE" expected';
    61:
      Result := '"IS_WTG" expected';
    62:
      Result := '"TRUE" expected';
    63:
      Result := '"FALSE" expected';
    64:
      Result := '"INSERT_CUSTOM_CODE" expected';
    65:
      Result := '"NPCTEXT" expected';
    66:
      Result := '"NPCFEMALETEXT" expected';
    67:
      Result := '"OPTIONS" expected';
    68:
      Result := '"TIMEEVENT" expected';
    69:
      Result := '"FIXED_PARAM_NAME" expected';
    70:
      Result := '"ENUM" expected';
    71:
      Result := '"ISRANDOMINTERVAL" expected';
    72:
      Result := '"INTERVALMIN" expected';
    73:
      Result := '"INTERVALMAX" expected';
    74:
      Result := '"INTERVAL" expected';
    75:
      Result := '"CODE" expected';
    76:
      Result := '"DEFAULT_EVENT" expected';
    77:
      Result := '"NPCNAME" expected';
    78:
      Result := '"LOCATION" expected';
    79:
      Result := '"DESCRIPTION" expected';
    80:
      Result := '"UNKNOWN_DESC" expected';
    81:
      Result := '"KNOWN_DESC" expected';
    82:
      Result := '"DETAILED_DESC" expected';
    83:
      Result := 'not expected';
    84:
      Result := 'invalid TimedEventData';
    85:
      Result := 'invalid Node';
    86:
      Result := 'invalid _variable';
    87:
      Result := 'invalid Options';
    88:
      Result := 'invalid Options';
    89:
      Result := 'invalid Options';
    90:
      Result := 'invalid Condition';
    91:
      Result := 'invalid Condition';
    92:
      Result := 'invalid Main';


    else
      if Assigned(OnCustomError) then
        Result := OnCustomError(Self, ErrorCode, Data)
      else
      begin
        Result := 'Error: ' + IntToStr(ErrorCode);
        if Trim(Data) > '' then
          Result := Result + ' (' + Data + ')';
      end;
  end;  {case nr}
end; {ErrorStr}

procedure TFMF.Execute;
begin
  ClearErrors;
  ListStream.Clear;
  Extra := 1;

  { if there is a file name then load the file }
  if Trim(SourceFileName) <> '' then
  begin
    GetScanner.SrcStream.Clear;
    GetScanner.SrcStream.LoadFromFile(SourceFileName);
  end;

  { install error reporting procedure }
  GetScanner.ScannerError := StoreError;

  { instigate the compilation }
  DoBeforeParse;
  Parse;
  DoAfterParse;

  { generate the source listing to the ListStream }
  if (GenListWhen = glAlways) or ((GenListWhen = glOnError) and (ErrorList.Count > 0)) then
    GenerateListing;
  if ClearSourceStream then
    GetScanner.SrcStream.Clear;
  ListStream.Position := 0;  // goto the beginning of the stream
  if Successful and Assigned(OnSuccess) then
    OnSuccess(Self);
  if (not Successful) and Assigned(OnFailure) then
    OnFailure(Self, ErrorList.Count);
end;  {Execute}

procedure TFMF.Get;
begin
  repeat
    GetScanner.Get(fCurrentInputSymbol);
    if fCurrentInputSymbol <= maxT then
      errDist := errDist + 1
    else
    begin
      case fCurrentInputSymbol of
        PreProcessorSym:
        begin
        end;
      end;
      GetScanner.NextSymbol.Pos  := GetScanner.CurrentSymbol.Pos;
      GetScanner.NextSymbol.Col  := GetScanner.CurrentSymbol.Col;
      GetScanner.NextSymbol.Line := GetScanner.CurrentSymbol.Line;
      GetScanner.NextSymbol.Len  := GetScanner.CurrentSymbol.Len;
    end;
  until fCurrentInputSymbol <= maxT;
  if Assigned(AfterGet) then
    AfterGet(Self, fCurrentInputSymbol);
end;  {Get}

function TFMF.GetScanner: TFMFScanner;
begin
  Result := Scanner as TFMFScanner;
end;  {GetScanner}

function TFMF._In(var s: SymbolSet; x: integer): boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;  {_In}

procedure TFMF._Globals;
begin
  Expect(NPCNAMESym);
  Expect(_stringSym);
  currentdlg.npcname      := parse_string(lexstring);
  ;
  Expect(LOCATIONSym);
  Expect(_stringSym);
  currentdlg.location     := parse_string(lexstring);
  ;
  Expect(DESCRIPTIONSym);
  Expect(_stringSym);
  currentdlg.description  := parse_string(lexstring);
  Expect(UNKNOWN_underscoreDESCSym);
  Expect(_stringSym);
  currentdlg.unknowndesc  := parse_String(lexstring);
  ;
  Expect(KNOWN_underscoreDESCSym);
  Expect(_stringSym);
  currentdlg.knowndesc    := parse_String(lexstring);
  ;
  Expect(DETAILED_underscoreDESCSym);
  Expect(_stringSym);
  currentdlg.detaileddesc := parse_String(lexstring);
  ;
end;

procedure TFMF._TimedEvents;
begin
  currentdlg.timedeventcnt    := 0;
  ;
  Expect(DEFAULT_underscoreEVENTSym);
  Expect(_equalSym);
  Expect(integer_Sym);
  currentdlg.start_time_event := StrToInt(lexstring);
  ;
  _TimedEventData;
  while (fCurrentInputSymbol = TIMEEVENTSym) do
  begin
    _TimedEventData;
  end;
end;

procedure TFMF._TimedEventData;
begin
  Expect(TIMEEVENTSym);
  new(currentdlg.timedevents[currentdlg.timedeventcnt]);
  currentdlg.timedevents[currentdlg.timedeventcnt].actioncnt := 0;
  ;
  Expect(FIXED_underscorePARAM_underscoreNAMESym);
  Expect(_equalSym);
  Expect(_stringSym);
  currentdlg.timedevents[currentdlg.timedeventcnt].fixedparamname := parse_string(lexstring);
  ;
  Expect(_commaSym);
  Expect(ENUMSym);
  Expect(_equalSym);
  Expect(integer_Sym);
  currentdlg.timedevents[currentdlg.timedeventcnt].fixedparamenumindex := StrToInt(lexstring);
  ;
  Expect(ISRANDOMINTERVALSym);
  Expect(_equalSym);
  if (fCurrentInputSymbol = TRUESym) then
  begin
    Get;
    currentdlg.timedevents[currentdlg.timedeventcnt].israndom := True;
    ;
    Expect(INTERVALMINSym);
    Expect(_equalSym);
    Expect(integer_Sym);
    currentdlg.timedevents[currentdlg.timedeventcnt].mininterval := StrToInt(lexstring);
    ;
    Expect(INTERVALMAXSym);
    Expect(_equalSym);
    Expect(integer_Sym);
    currentdlg.timedevents[currentdlg.timedeventcnt].maxinterval := StrToInt(lexstring);
    ;
  end
  else if (fCurrentInputSymbol = FALSESym) then
  begin
    Get;
    currentdlg.timedevents[currentdlg.timedeventcnt].israndom := False;
    ;
    Expect(INTERVALSym);
    Expect(_equalSym);
    Expect(integer_Sym);
    currentdlg.timedevents[currentdlg.timedeventcnt].interval := StrToInt(lexstring);
    ;
  end
  else
  begin
    SynError(84);
  end;
  Expect(CODESym);
  Expect(_equalSym);
  Expect(_lbraceSym);
  Expect(_stringSym);
  new(currentdlg.timedevents[currentdlg.timedeventcnt].actionlines[currentdlg.timedevents[
    currentdlg.timedeventcnt].actioncnt]);
  currentdlg.timedevents[currentdlg.timedeventcnt].actionlines[currentdlg.timedevents[
    currentdlg.timedeventcnt].actioncnt].linedata := parse_string(lexstring);
  Inc(currentdlg.timedevents[currentdlg.timedeventcnt].actioncnt);
  ;
  while (fCurrentInputSymbol = _commaSym) do
  begin
    Get;
    Expect(_stringSym);
    new(currentdlg.timedevents[currentdlg.timedeventcnt].actionlines[currentdlg.timedevents[
      currentdlg.timedeventcnt].actioncnt]);
    currentdlg.timedevents[currentdlg.timedeventcnt].actionlines[currentdlg.timedevents[
      currentdlg.timedeventcnt].actioncnt].linedata := parse_string(lexstring);
    Inc(currentdlg.timedevents[currentdlg.timedeventcnt].actioncnt);
    ;
  end;
  Expect(_rbraceSym);
  Inc(currentdlg.timedeventcnt);
  ;
end;

procedure TFMF._Nodes;
begin
  _Node;
  while (fCurrentInputSymbol = NODESym) do
  begin
    _Node;
  end;
end;

procedure TFMF._Node;
begin
  Expect(NODESym);
  Expect(_stringSym);
  new(currentdlg.nodes[currentdlg.nodecount]);
  currentdlg.nodes[currentdlg.nodecount].skillcheckcnt := 0;
  currentdlg.nodes[currentdlg.nodecount].hidden        := False;
  currentdlg.nodes[currentdlg.nodecount].customcode    := '';
  currentdlg.nodes[currentdlg.nodecount].is_wtg        := False;
  currentdlg.nodes[currentdlg.nodecount].nodename      := parse_String(lexstring);
  currentdlg.nodes[currentdlg.nodecount].optioncnt     := 0;
  ;
  Expect(NOTESSym);
  Expect(_stringSym);
  currentdlg.nodes[currentdlg.nodecount].notes         := parse_string(lexstring);
  ;
  if (fCurrentInputSymbol = IS_underscoreWTGSym) then
  begin
    Get;
    Expect(_equalSym);
    if (fCurrentInputSymbol = TRUESym) then
    begin
      Get;
      currentdlg.nodes[currentdlg.nodecount].is_wtg := True;
      ;
    end
    else if (fCurrentInputSymbol = FALSESym) then
    begin
      Get;
      currentdlg.nodes[currentdlg.nodecount].is_wtg := False;
      ;
    end
    else
    begin
      SynError(85);
    end;
  end;
  if (fCurrentInputSymbol = DEFINE_underscoreSKILL_underscoreCHECKS) then
  begin
    _SkillCheck;
    while (fCurrentInputSymbol = DEFINE_underscoreSKILL_underscoreCHECKS) do
    begin
      _SkillCheck;
    end;
  end;
  if (fCurrentInputSymbol = INSERT_underscoreCUSTOM_underscoreCODES) then
  begin
    Get;
    Expect(_lbraceSym);
    Expect(_stringSym);
    currentdlg.nodes[currentdlg.nodecount].customcode :=
      currentdlg.nodes[currentdlg.nodecount].customcode + parse_string(lexstring);
    ;
    while (fCurrentInputSymbol = _commaSym) do
    begin
      Get;
      Expect(_stringSym);
      currentdlg.nodes[currentdlg.nodecount].customcode :=
        currentdlg.nodes[currentdlg.nodecount].customcode + parse_string(lexstring);
      ;
    end;
    Expect(_rbraceSym);
  end;
  Expect(_lbraceSym);
  Expect(NPCTEXTSym);
  Expect(_stringSym);
  currentdlg.nodes[currentdlg.nodecount].npctext := parse_string(lexstring);
  ;
  if (fCurrentInputSymbol = NPCFEMALETEXTSym) then
  begin
    Get;
    Expect(_stringSym);
    currentdlg.nodes[currentdlg.nodecount].npctext_female := parse_string(lexstring);
    ;
  end;
  Expect(OPTIONSSym);
  Expect(_lbraceSym);
  if (fCurrentInputSymbol = INTSym) or (fCurrentInputSymbol = LINKFLAGSSym) or
    (fCurrentInputSymbol = REACTIONSym) or (fCurrentInputSymbol = GENDERSym) or
    (fCurrentInputSymbol = PLAYERTEXTSym) then
  begin
    _Options;
    while (fCurrentInputSymbol = INTSym) or (fCurrentInputSymbol = LINKFLAGSSym) or
      (fCurrentInputSymbol = REACTIONSym) or (fCurrentInputSymbol = GENDERSym) or
      (fCurrentInputSymbol = PLAYERTEXTSym) do
    begin
      _Options;
    end;
  end;
  Expect(_rbraceSym);
  Expect(_rbraceSym);
  Inc(currentdlg.nodecount);
  ;
end;

procedure TFMF._SkillCheck;
begin
  Expect(DEFINE_underscoreSKILL_underscoreCHECKS);
  Expect(identifierSym);

  new(currentdlg.nodes[currentdlg.nodecount].skillchecks[currentdlg.nodes[currentdlg.nodecount].skillcheckcnt]);
  currentdlg.nodes[currentdlg.nodecount].skillchecks[currentdlg.nodes[currentdlg.nodecount].skillcheckcnt].
    check_proc_name := lexstring;
  ;
  Expect(_lbraceSym);
  Expect(SKILL_underscoreNUMSym);
  Expect(_equalSym);
  Expect(integer_Sym);

  currentdlg.nodes[currentdlg.nodecount].skillchecks[currentdlg.nodes[currentdlg.nodecount].skillcheckcnt].check_what
  :=
    StrToInt(lexstring);

  ;
  Expect(_semicolonSym);
  Expect(DIFFICULTY_underscoreMODIFIERSym);
  Expect(_equalSym);
  Expect(integer_Sym);

  currentdlg.nodes[currentdlg.nodecount].skillchecks[currentdlg.nodes[currentdlg.nodecount].skillcheckcnt].modifier :=
    StrToInt(lexstring);
  ;
  Expect(_semicolonSym);
  Expect(ONSUCCESSSym);
  Expect(_equal_greaterSym);
  Expect(identifierSym);

  currentdlg.nodes[currentdlg.nodecount].skillchecks[currentdlg.nodes[currentdlg.nodecount].skillcheckcnt].successnode
  :=
    lexstring;

  ;
  Expect(_semicolonSym);
  Expect(ONFAILURESym);
  Expect(_equal_greaterSym);
  Expect(identifierSym);

  currentdlg.nodes[currentdlg.nodecount].skillchecks[currentdlg.nodes[currentdlg.nodecount].skillcheckcnt].failurenode
  :=
    lexstring;

  ;
  Expect(_semicolonSym);
  Expect(_rbraceSym);
  Inc(currentdlg.nodes[currentdlg.nodecount].skillcheckcnt);
  ;
end;

procedure TFMF.__variable;
begin
  new(currentdlg.variables[currentdlg.varcnt]);
  currentdlg.variables[currentdlg.varcnt].flags := VAR_FLAGS_NONE;
  if (fCurrentInputSymbol = IMPORTSym) or (fCurrentInputSymbol = LOCALSym) or
    (fCurrentInputSymbol = EXPORTSym) or (fCurrentInputSymbol = GLOBALSYM) then
  begin
    if (fCurrentInputSymbol = IMPORTSym) then
    begin
      Get;
      currentdlg.variables[currentdlg.varcnt].flags := VAR_FLAGS_IMPORT;
      ;
    end
    else if (fCurrentInputSymbol = LOCALSym) then
    begin
      Get;
      currentdlg.variables[currentdlg.varcnt].flags := VAR_FLAGS_LOCAL;
      ;
    end
    else
    if (fCurrentInputSymbol = EXPORTSym) then
    begin
      Get;
      currentdlg.variables[currentdlg.varcnt].flags := VAR_FLAGS_EXPORT;
    end
    else
    if (fCurrentInputSymbol = GLOBALSYM) then
    begin
      Get;
      MessageDlg('GLOBAL!', mtWarning, [mbOK], 0);
      currentdlg.variables[currentdlg.varcnt].flags := VAR_FLAGS_GLOBAL;
    end;
  end;
  Expect(VARSym);
  Expect(identifierSym);
  currentdlg.variables[currentdlg.varcnt].vartype := -1;
  currentdlg.variables[currentdlg.varcnt].Name    := lexstring;
  ;
  if (fCurrentInputSymbol = NOTESSym) then
  begin
    Get;
    Expect(_stringSym);
    currentdlg.variables[currentdlg.varcnt].notes := parse_String(lexstring);
    ;
  end;
  if (fCurrentInputSymbol = _equalSym) then
  begin
    Get;
    if (fCurrentInputSymbol = _stringSym) then
    begin
      Get;
      currentdlg.variables[currentdlg.varcnt].vartype := VAR_TYPE_STRING;
      currentdlg.variables[currentdlg.varcnt].Value   := parse_String(lexstring);
      ;
    end
    else if (fCurrentInputSymbol = integer_Sym) then
    begin
      Get;
      currentdlg.variables[currentdlg.varcnt].vartype := VAR_TYPE_INT;
      currentdlg.variables[currentdlg.varcnt].Value   := StrToInt(lexstring);
      ;
    end
    else if (fCurrentInputSymbol = _floatSym) then
    begin
      Get;
      currentdlg.variables[currentdlg.varcnt].vartype := VAR_TYPE_FLOAT;
      currentdlg.variables[currentdlg.varcnt].Value   := strtofloat(lexstring);
      ;
    end
    else
    begin
      SynError(86);
    end;
  end;
  Expect(_semicolonSym);
  Inc(currentdlg.varcnt);
  ;
end;

procedure TFMF._FloatNodes;
begin
  _FloatNode;
  while (fCurrentInputSymbol = FLOATNODESym) do
  begin
    _FloatNode;
  end;
end;

procedure TFMF._CustomScript;
begin
  Expect(EXEC_underscoreSCRIPT_underscoreCODESym);
  Expect(_lbraceSym);
  _ScriptLine;
  while (fCurrentInputSymbol = _commaSym) do
  begin
    Get;
    _ScriptLine;
  end;
  Expect(_rbraceSym);
  Expect(_semicolonSym);
end;

procedure TFMF._CustomProc;
begin
  Expect(CUSTOM_underscorePROCSym);
  Expect(identifierSym);
  new(currentdlg.customprocs[currentdlg.customproccnt]);
  currentdlg.customprocs[currentdlg.customproccnt].Lines := '';
  currentdlg.customprocs[currentdlg.customproccnt].Name  := lexstring;
  ;
  Expect(ASSOCIATE_underscoreNODESym);
  Expect(integer_Sym);
  currentdlg.customprocs[currentdlg.customproccnt].associatewithnode := StrToInt(lexstring);
  Expect(_lbraceSym);
  Expect(_stringSym);
  currentdlg.customprocs[currentdlg.customproccnt].Lines :=
    currentdlg.customprocs[currentdlg.customproccnt].Lines + parse_string(lexstring) + #13#10;
  ;
  while (fCurrentInputSymbol = _commaSym) do
  begin
    Get;
    Expect(_stringSym);
    currentdlg.customprocs[currentdlg.customproccnt].Lines :=
      currentdlg.customprocs[currentdlg.customproccnt].Lines + parse_string(lexstring) + #13#10;
    ;
  end;
  Expect(_rbraceSym);
  if procexists(currentdlg.customprocs[currentdlg.customproccnt].Name) = False then
    Inc(currentdlg.customproccnt);
end;

procedure TFMF._StartConditions;
begin
  currentdlg.startconditioncnt := 0;
  ;
  Expect(START_underscoreCONDITIONSSym);
  Expect(DEFAULT_underscoreCONDITIONSym);
  Expect(integer_Sym);
  currentdlg.default_cond      := StrToInt(lexstring);
  ;
  Expect(_lbraceSym);
  _StartCond;
  while (fCurrentInputSymbol = _commaSym) do
  begin
    Get;
    _StartCond;
  end;
  Expect(_rbraceSym);
  Expect(_semicolonSym);
end;

procedure TFMF._StartCond;
begin
  New(currentdlg.startconditions[currentdlg.startconditioncnt]);
  currentdlg.startconditions[currentdlg.startconditioncnt].condcnt := 0;
  Expect(CONDSym);
  Expect(TARGET_underscoreNODESym);
  Expect(_stringSym);
  currentdlg.startconditions[currentdlg.startconditioncnt].goto_node := parse_string(lexstring);
  ;
  Expect(_lbraceSym);
  _Conds;
  while (fCurrentInputSymbol = _commaSym) do
  begin
    Get;
    _Conds;
  end;
  Expect(_rbraceSym);
  Inc(currentdlg.startconditioncnt);
  ;
end;

procedure TFMF._Conds;
begin

  new(currentdlg.startconditions[currentdlg.startconditioncnt].conditions[
    currentdlg.startconditions[currentdlg.startconditioncnt].condcnt]);
  currentdlg.startconditions[currentdlg.startconditioncnt].conditions[currentdlg.startconditions[
    currentdlg.startconditioncnt].condcnt].linkage := LINKAGE_NONE;
  ;
  Expect(SSLSym);
  Expect(_stringSym);
  currentdlg.startconditions[currentdlg.startconditioncnt].conditions[currentdlg.startconditions[
    currentdlg.startconditioncnt].condcnt].resultcode := parse_string(lexstring);
  ;
  Expect(VAR_underscorePARAMSym);
  Expect(_stringSym);
  currentdlg.startconditions[currentdlg.startconditioncnt].conditions[currentdlg.startconditions[
    currentdlg.startconditioncnt].condcnt].parameter := parse_String(lexstring);
  ;
  Expect(EVALSym);
  Expect(integer_Sym);
  currentdlg.startconditions[currentdlg.startconditioncnt].conditions[currentdlg.startconditions[
    currentdlg.startconditioncnt].condcnt].evaluator := StrToInt(lexstring);
  ;
  Expect(VALUE_underscoreTO_underscoreCHECKSym);
  Expect(_stringSym);
  currentdlg.startconditions[currentdlg.startconditioncnt].conditions[currentdlg.startconditions[
    currentdlg.startconditioncnt].condcnt].compareto := parse_string(lexstring);
  ;
  Expect(INI_underscoreINDEXSym);
  Expect(integer_Sym);
  currentdlg.startconditions[currentdlg.startconditioncnt].conditions[currentdlg.startconditions[
    currentdlg.startconditioncnt].condcnt].index_of_selection := StrToInt(lexstring);

  Expect(LINKSym);
  Expect(integer_Sym);
  //  debugmsg('LexString := ' + lexstring);
  currentdlg.startconditions[currentdlg.startconditioncnt].conditions[currentdlg.startconditions
    [currentdlg.startconditioncnt].condcnt].linkage := StrToInt(lexstring);
  ;
  Inc(currentdlg.startconditions[currentdlg.startconditioncnt].condcnt);

end;

procedure TFMF._ScriptLine;
begin
  Expect(_stringSym);
  {$IFNDEF FMFCBuild}
  // form1.executescriptconsole(parse_String(lexstring));;
  {$ELSE}
  writeln ('Ignored script command: ',lexstring);
  {$ENDIF}
end;

procedure TFMF._FloatNode;
begin
  Expect(FLOATNODESym);
  Expect(_stringSym);
  new(currentdlg.floatnodes[currentdlg.floatnodecount]);
  currentdlg.floatnodes[currentdlg.floatnodecount].messagecnt := 0;
  currentdlg.floatnodes[currentdlg.floatnodecount].nodename   := parse_String(lexstring);
  ;
  Expect(NOTESSym);
  Expect(_stringSym);
  currentdlg.floatnodes[currentdlg.floatnodecount].notes      := parse_String(lexstring);
  ;
  Expect(_lbraceSym);
  if (fCurrentInputSymbol = _stringSym) then
  begin
    Get;
    currentdlg.floatnodes[currentdlg.floatnodecount].Messages[currentdlg.floatnodes[
      currentdlg.floatnodecount].messagecnt] := parse_string(lexstring);
    Inc(currentdlg.floatnodes[currentdlg.floatnodecount].messagecnt);
    while (fCurrentInputSymbol = _commaSym) do
    begin
      Get;
      Expect(_stringSym);
      currentdlg.floatnodes[currentdlg.floatnodecount].Messages[currentdlg.floatnodes[
        currentdlg.floatnodecount].messagecnt] := parse_string(lexstring);
      Inc(currentdlg.floatnodes[currentdlg.floatnodecount].messagecnt);
    end;
  end;
  Expect(_rbraceSym);
  Inc(currentdlg.floatnodecount);
  ;
end;

procedure TFMF._Options;
begin
  new(currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt]);
  currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].link_to_proc :=
    False;
  currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].link_to_skillcheck
  :=
    False;

  currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].genderflags := 0;
  currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].conditioncnt :=
    0;
  currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].intcheck    := 4;
  ;
  if (fCurrentInputSymbol = INTSym) then
  begin
    Get;
    Expect(_equalSym);
    Expect(integer_Sym);
    currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].intcheck :=
      StrToInt(lexstring);
    ;
  end;
  if (fCurrentInputSymbol = LINKFLAGSSym) then
  begin
    Get;
    if (fCurrentInputSymbol = SKILL_underscoreCHECKSym) then
    begin
      Get;
      currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].
        link_to_skillcheck :=
        True;
      currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].link_to_proc
      :=
        False;
      ;
    end
    else if (fCurrentInputSymbol = CUSTOM_underscorePROCSym) then
    begin
      Get;
      currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].
        link_to_skillcheck :=
        False;
      currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].link_to_proc
      := True;
      ;
    end
    else
    begin
      SynError(87);
    end;
  end;
  if (fCurrentInputSymbol = REACTIONSym) then
  begin
    Get;
    Expect(_equalSym);
    if (fCurrentInputSymbol = REACTION_underscoreBADSym) then
    begin
      Get;
      currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].reaction :=
        REACTION_BAD;
    end
    else if (fCurrentInputSymbol = REACTION_underscoreNEUTRALSym) then
    begin
      Get;
      currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].reaction :=
        REACTION_NEUTRAL;
    end
    else if (fCurrentInputSymbol = REACTION_underscoreGOODSym) then
    begin
      Get;
      currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].reaction :=
        REACTION_GOOD;
    end
    else
    begin
      SynError(88);
    end;
  end;
  if (fCurrentInputSymbol = GENDERSym) then
  begin
    Get;
    Expect(_equalSym);
    if (fCurrentInputSymbol = FEMALESym) then
    begin
      Get;
      currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].genderflags :=
        GENDER_FEMALE;
    end
    else if (fCurrentInputSymbol = MALESym) then
    begin
      Get;
      currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].genderflags :=
        GENDER_MALE;
      ;
    end
    else
    begin
      SynError(89);
    end;
  end;
  Expect(PLAYERTEXTSym);
  Expect(_stringSym);
  currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].optiontext :=
    parse_string(lexstring);
  ;
  Expect(LINKTOSym);
  Expect(_stringSym);
  currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].nodelink   :=
    parse_string(lexstring);
  ;
  if (fCurrentInputSymbol = CONDITIONSSym) then
  begin
    Get;
    Expect(_lbraceSym);
    _Condition;
    while (fCurrentInputSymbol = _commaSym) do
    begin
      Get;
      _Condition;
    end;
    Expect(_rbraceSym);
  end;
  Expect(NOTESSym);
  Expect(_stringSym);
  currentdlg.nodes[currentdlg.nodecount].options[currentdlg.nodes[currentdlg.nodecount].optioncnt].notes :=
    parse_string(lexstring);
  Inc(currentdlg.nodes[currentdlg.nodecount].optioncnt);
  ;
end;

procedure TFMF._Condition;
begin
  Expect(identifierSym);
  tempcondcheck := lexstring;
  ;
  Expect(identifierSym);
  tempcondfield := lexstring;
  ;
  if (fCurrentInputSymbol < 16) { prevent range error } and (fCurrentInputSymbol in
    [_equal_equalSym, _bang_equalSym, _lessSym, _greaterSym, _greater_equalSym, _less_equalSym]) then
  begin
    case fCurrentInputSymbol of
      _equal_equalSym:
      begin
        Get;
      end;
      _bang_equalSym:
      begin
        Get;
      end;
      _lessSym:
      begin
        Get;
      end;
      _greaterSym:
      begin
        Get;
      end;
      _greater_equalSym:
      begin
        Get;
      end;
      _less_equalSym:
      begin
        Get;
      end;
    end;
    tempcondeval := lexstring;
    ;
    if (fCurrentInputSymbol = integer_Sym) then
    begin
      Get;
    end
    else if (fCurrentInputSymbol = _stringSym) then
    begin
      Get;
    end
    else
    begin
      SynError(90);
    end;
    tempcondval := lexstring;
    ;
  end;
  if (fCurrentInputSymbol = LINK_underscoreNEXTSym) then
  begin
    Get;
    if (fCurrentInputSymbol = NONESym) then
    begin
      Get;
      tempcondlink := LINKAGE_NONE;
      ;
    end
    else if (fCurrentInputSymbol = ANDSym) then
    begin
      Get;
      tempcondlink := LINKAGE_AND;
      ;
    end
    else if (fCurrentInputSymbol = ORSym) then
    begin
      Get;
      tempcondlink := LINKAGE_OR;
      ;
    end
    else
    begin
      SynError(91);
    end;
  end;
  CreateNewCondition;
  ;
end;

procedure TFMF._Main;
begin
  case fCurrentInputSymbol of
    NPCNAMESym:
    begin
      _Globals;
    end;
    DEFAULT_underscoreEVENTSym:
    begin
      _TimedEvents;
    end;
    EXEC_underscoreSCRIPT_underscoreCODESym:
    begin
      _CustomScript;
    end;
    START_underscoreCONDITIONSSym:
    begin
      _StartConditions;
    end;
    FLOATNODESym:
    begin
      _FloatNodes;
    end;
    NODESym:
    begin
      _Nodes;
    end;
    CUSTOM_underscorePROCSym:
    begin
      _CustomProc;
    end;
    else
    begin
      SynError(92);
    end;
  end;
end;

procedure TFMF._VarDefs;
begin
  Expect(VARSSym);
  currentdlg.varcnt := 0;
   Expect(_lbraceSym);
  if (fCurrentInputSymbol = IMPORTSym) or (fCurrentInputSymbol = LOCALSym) or
    (fCurrentInputSymbol = EXPORTSym) or (fCurrentInputSymbol = GLOBALSym) or (fCurrentInputSymbol = VARSym) then
  begin
    __variable;
    while (fCurrentInputSymbol = IMPORTSym) or (fCurrentInputSymbol = LOCALSym) or
      (fCurrentInputSymbol = EXPORTSym) or (fCurrentInputSymbol = GLOBALSym) or (fCurrentInputSymbol = VARSym) do
    begin
      __variable;
    end;
  end;
  Expect(_rbraceSym);
end;

procedure TFMF._FMF;
begin
  Init;
  ;
  if (fCurrentInputSymbol = VARSSym) then
  begin
    _VarDefs;
  end;
  _Main;
  while _In(symSet[1], fCurrentInputSymbol) do
  begin
    _Main;
  end;
  Final;
  ;
end;

function TFMF.GetMajorVersion: integer;
begin
  Result := 1;
end;

function TFMF.GetMinorVersion: integer;
begin
  Result := 0;
end;

function TFMF.GetRelease: integer;
begin
  Result := 0;
end;

function TFMF.GetBuild: integer;
begin
  Result := 252;
end;

function TFMF.GetBuildDate: TDateTime;
const
  BDate = 38679;
  Hour  = 18;
  Min   = 45;
begin
  Result := BDate + EncodeTime(Hour, Min, 0, 0);
end;

function TFMF.GetVersion: string;
var
  MinorVersionStr: string;
begin
  MinorVersionStr := IntToStr(MinorVersion);
  if (length(MinorVersionStr) > 0) and (MinorVersion > 0) then
    MinorVersionStr := '0' + MinorVersionStr;
  Result          := 'Version: ' + IntToStr(MajorVersion) + '.' + MinorVersionStr + ' Release ' +
    IntToStr(Release) + ' Build ' + IntToStr(Build);
end;

function TFMF.GetVersionComment: string;
begin
  Result := 'Interplay SSL Parser';
end;

function TFMF.GetGrammarAuthor: string;
begin
  Result := 'T. Pitkänen';
end;

function TFMF.GetGrammarCopyright: string;
begin
  Result := '(c) 2003 Dj Unique';
end;

procedure TFMF.SetVersion(const Value: string);
begin
  // This is a read only property. However, we want the value
  // to appear in the Object Inspector during design time.
end;

procedure TFMF.Parse;
begin
  errDist := minErrDist;
  GetScanner._Reset;
  Get;
  _FMF;
end;  {Parse}

procedure TFMF.InitSymSet;
begin
  symSet[0, 0] := [EOFSYMB];
  symSet[0, 1] := [];
  symSet[0, 2] := [];
  symSet[0, 3] := [];
  symSet[0, 4] := [];
  symSet[0, 5] := [];
  symSet[1, 0] := [];
  symSet[1, 1] := [CUSTOM_underscorePROCSym - 16];
  symSet[1, 2] := [FLOATNODESym - 32, START_underscoreCONDITIONSSym - 32];
  symSet[1, 3] := [EXEC_underscoreSCRIPT_underscoreCODESym - 48, NODESym - 48];
  symSet[1, 4] := [DEFAULT_underscoreEVENTSym - 64, NPCNAMESym - 64];
  symSet[1, 5] := [];
end; {InitSymSet}

end { FMF }.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
