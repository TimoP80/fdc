library Utility_RenameNodes;

{

This is a plugin generated by the PluginHelper
application. It serves as a starting point for developing plugins
for FMF Dialogue Tool.

Plugin Name: Rename dialogue nodes to NodeXXX
Author: Dj Unique

Description:

This plugin renames all dialogue nodes to the 'Node001', 'Node002', ... naming convention.

}

uses
  Classes, Controls, Dialogs, Forms, pluginfunc, renamesettings in 'renamesettings.pas', SysUtils;
var dlg: pnewdialogue;

{$R *.res}

  function GetPluginName: ShortString; stdcall;
  begin;
    Result := 'Rename dialogue nodes to NodeXXX';
  end;
  function GetPluginDescription: ShortString; stdcall;
  begin;
    Result := 'Node renaming tool';
  end;

  function GetInterfaceVersion: shortstring; stdcall;
  begin;
    Result := interface_version;
  end;


  function CanAddToMenu: boolean; stdcall;
  begin;
    Result := True;
  end;


  function IsStartingNode(nodeind: integer): boolean;
  var
    i, j, t:    integer;
  var
    linksfound: integer;
  begin

    t          := nodeind;
    Result     := False;
    linksfound := 0;
    if t <> -1 then
    begin
      ;
      for i := 0 to dlg.nodecount - 1 do
      begin
        ;
        for j := 0 to dlg.nodes[i].optioncnt - 1 do
        begin
          ;
          if dlg.nodes[i].options[j].nodelink = dlg.nodes[t].nodename then
          begin
            ;
            Inc(linksfound);
          end;
        end;

      end;

    end;
    if linksfound = 0 then
      Result := True
    else
      Result := False;
    //showmessage('Links found: '+inttostr(linksfound));
  end;

  procedure PluginClose; stdcall;
  begin;


  end;


  function GetNodeIndex(Name: string): integer;
  var t: integer;
  begin;
    Result := -1;
    for t := 0 to dlg.nodecount - 1 do
    begin;
      if Name = dlg.nodes[t].nodename then
      begin;
        Result := t;
      end;

    end;

  end;

  procedure RunPlugin(basepath: shortstring); stdcall;
  var sublevel:          integer;
  var mainnode, subnodename, curnode: shortstring;
  var node_basename:     string;
  var sub_subnode, subnode, tha_node: integer;
  var command:           pchar;
  var branchindex:       integer;
  var branchoptionindex: integer;
  var i, b, u, c:        integer;

  begin;
    //str := InputBox('Enter node prefix','Enter node prefix for each new node:','');
    new(dlg);
    dlg   := GetDLGNew;
    form1 := TForm1.Create(NIL);

    form1.showmodal;
    if (dlg.npcname = '') and (form1.radiogroup1.ItemIndex = 1) then
    begin;
      MessageDlg('Unable to perform complex node rename!' + #13 + #10 + '' + #13 + #10 +
        'NPC Name is required but found empty.',
        mtError, [mbOK], 0);
      exit;
    end;

    if form1.modalresult = mrOk then
    begin;
      case form1.radiogroup1.ItemIndex of
        0:
        begin;

          for i := 0 to dlg.nodecount - 1 do
          begin;
            curnode := dlg.nodes[i].nodename;
            ExecuteScriptLines(PChar(format('SetNodeName(''%s'',''Node%0.3d'');', [curnode, i + 1])));
          end;
          command := 'RefreshAll;';
          executescriptlines(command);
          command := 'DialogueChangeNotify;';
          executescriptlines(command);
        end;
        1:
        begin;

          MessageDlg('Complex mode is not finished yet. This' + #13 + #10 + 'option does nothing.',
            mtInformation, [mbOK], 0);
          exit;

          node_basename := dlg.npcname + '_';
          // Complex rename, performs branching... iterate through
          // nodes and player options
          branchindex   := 1;
          i             := 0;
          u             := 0;
          branchindex   := GetNodeIndex(dlg.nodes[i].nodename);
          senddebugmsg('Start!');
          b             := 0;

          i := b;
          if isstartingnode(b) = False then
          begin;
            while (IsStartingNode(b) = False) do
            begin;
              Inc(b);
            end;
          end;

          c := 0;


          while (IsStartingNode(b) = True) do
          begin;
            senddebugmsg(PChar('// Now at node: ' + dlg.nodes[i].nodename + ', option ' + IntToStr(u)));

            senddebugmsg(PChar(dlg.nodes[i].npctext));

            //senddebugmsg(PChar('// Entering option ' + IntToStr(u) + '/' +
            //  IntToStr(dlg.nodes[i].optioncnt) + '  of node.'));
            //senddebugmsg(PChar(' -> ' + dlg.nodes[i].options[u].optiontext));

            sublevel := 0;

            u := 0;
            senddebugmsg('Finding next start node!');

            Inc(b);

            while (IsStartingNode(b) = False) do
            begin;
              Inc(b);
              if b > dlg.nodecount then
                break;
            end;
            senddebugmsg(PChar('B == ' + IntToStr(b)));
            senddebugmsg(PChar('it is ... ' + dlg.nodes[b].nodename + '!'));
            i := b;

          end;
          senddebugmsg('Out of the loop!');
        end;
      end;
    end;


  end;

exports
  GetPluginName,
  PluginClose,
  SetApplicationHandle,
  GetPluginDescription,
  GetInterfaceVersion,
  CanAddToMenu,
  RunPlugin;

begin

end.

